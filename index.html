<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a73e8">
  <meta name="description" content="Professional ESP32-CAM agricultural disease detection system with AI verification, 10-model consensus analysis, and real-time sensor monitoring.">
  <meta name="keywords" content="agriculture, plant disease detection, ESP32-CAM, AI, machine learning, crop health monitoring">
  <meta name="author" content="Smart Agricultural System">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="dns-prefetch" href="https://www.gstatic.com">
  <title>ESP32-CAM Disease Monitor - Smart Agriculture</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Firebase SDK - Using Firestore for all data storage -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
  <style>
    :root {
      /* Modern Google-like Palette (Material 3 inspired) */
      --primary: #0b57d0;
      --primary-container: #d3e3fd;
      --on-primary: #ffffff;
      --on-primary-container: #041e49;
      --secondary: #00639b;
      --surface: #ffffff;
      --surface-container: #f0f4f9;
      --on-surface: #1f1f1f;
      --on-surface-variant: #444746;
      --outline: #747775;
      --outline-variant: #c4c7c5;
      --error: #b3261e;
      --error-container: #f9dedc;
      --success: #146c2e;
      --warn: #ef6c00;
      --elevation-1: 0 1px 3px 0 rgba(0,0,0,0.1), 0 1px 2px -1px rgba(0,0,0,0.1);
      --elevation-2: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -2px rgba(0,0,0,0.1);
      --elevation-3: 0 10px 15px -3px rgba(0,0,0,0.1), 0 4px 6px -4px rgba(0,0,0,0.1);
      --radius: 16px;
      --font-sans: 'Google Sans', 'Roboto', sans-serif;
      --font-body: 'Roboto', sans-serif;
      --transition: all 0.2s cubic-bezier(0.2, 0.0, 0, 1.0);
    }
    @media (prefers-color-scheme: dark) {
      :root {
        --surface: #1e1e1e;
        --surface-container: #121212;
        --on-surface: #e2e2e2;
        --on-surface-variant: #c4c7c5;
        --primary: #a8c7fa;
        --primary-container: #0842a0;
        --on-primary: #062e6f;
        --on-primary-container: #d3e3fd;
      }
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: var(--font-body);
      background-color: #000000;
      color: var(--on-surface);
      padding: 24px;
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
    }
    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 24px;
      animation: fadeIn 0.6s ease-out;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes gradient-animation {
      0% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
      100% {
        background-position: 0% 50%;
      }
    }
    .hero {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      background-size: 200% 200%;
      animation: gradient-animation 10s ease infinite;
      border-radius: 24px;
      padding: 32px;
      color: white;
      box-shadow: var(--elevation-2);
      position: relative;
      overflow: hidden;
    }
    .hero::after {
      content: '';
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 0;
      background: url('data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMiIgY3k9IjIiIHI9IjIiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuMSIvPjwvc3ZnPg==');
      opacity: 0.3;
      pointer-events: none; /* allow clicks through the decorative overlay */
      z-index: 0;
    }
    .hero > * {
      position: relative;
      z-index: 1;
    }
    .hero h1 {
      font-family: var(--font-sans);
      font-size: 28px;
      font-weight: 400;
      margin: 8px 0 4px;
      color: white;
    }
    .hero p {
      font-size: 15px;
      color: rgba(255,255,255,0.9);
      margin: 0;
      font-weight: 300;
    }
    .ip-config {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: wrap;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: var(--transition);
    }
    .ip-config:focus-within {
      border-color: var(--primary);
      box-shadow: var(--elevation-2);
    }
    .ip-config input {
      flex: 1;
      min-width: 200px;
      background: var(--surface-container);
      border: none;
      border-radius: 8px;
      padding: 14px 16px;
      color: var(--on-surface);
      font-size: 16px;
      font-family: 'Roboto Mono', 'Courier New', monospace;
      transition: var(--transition);
    }
    .ip-config input:focus {
      outline: 2px solid var(--primary);
      background: var(--surface);
    }
    .ip-config button {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 24px;
      padding: 0 24px;
      height: 48px;
      font-weight: 500;
      cursor: pointer;
      font-size: 14px;
      font-family: var(--font-sans);
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }
    .ip-config button:hover {
      background: #0b4eb3; /* Slightly darker */
      box-shadow: var(--elevation-2);
      transform: translateY(-1px);
    }
    .status {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
    }
    .chip {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border-radius: 50px; /* Pill shape */
      padding: 12px 20px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      font-size: 14px;
      font-weight: 500;
      color: var(--on-surface);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 0 2px rgba(20, 108, 46, 0.2);
    }
    .dot.offline {
      background: var(--error);
      box-shadow: 0 0 0 2px rgba(179, 38, 30, 0.2);
    }
    .card {
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border-radius: var(--radius);
      padding: 24px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      transition: var(--transition);
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: transform 0.2s cubic-bezier(0.4, 0, 0.2, 1), box-shadow 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    .card:hover {
      transform: translateY(-4px);
      box-shadow: var(--elevation-3);
    }
    .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    h2 {
      font-family: var(--font-sans);
      font-size: 20px;
      font-weight: 400;
      color: var(--on-surface);
    }
    .pill {
      padding: 4px 12px;
      border-radius: 12px;
      background: var(--primary-container);
      color: var(--on-primary-container);
      font-size: 12px;
      font-weight: 600;
    }
    .frame {
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      min-height: 240px;
      display: grid;
      place-items: center;
      position: relative;
    }
    .actions {
      margin-top: 24px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }
    .btn {
      border: none;
      border-radius: 24px;
      padding: 0 24px;
      height: 44px;
      font-weight: 500;
      font-size: 14px;
      cursor: pointer;
      font-family: var(--font-sans);
      transition: var(--transition);
      letter-spacing: 0.25px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
    .btn.pri {
      background: var(--primary);
      color: #fff;
      box-shadow: var(--elevation-1);
    }
    .btn.pri:hover {
      background: #0b4eb3;
      box-shadow: var(--elevation-2);
      transform: translateY(-1px);
    }
    .btn.sec {
      background: transparent;
      color: var(--primary);
      border: 1px solid var(--outline);
    }
    .btn.sec:hover {
      background: var(--primary-container);
      border-color: var(--primary);
      color: var(--on-primary-container);
    }
    .btn.err {
      background: var(--error);
      color: white;
      border: 1px solid var(--error);
    }
    .btn.err:hover {
      background: #d32f2f; /* Darker red */
      border-color: #d32f2f;
    }
    .btn:disabled {
      background: rgba(0,0,0,0.12);
      color: rgba(0,0,0,0.38);
      border: none;
      box-shadow: none;
      cursor: not-allowed;
      transform: none;
    }
    .rc {
      background: var(--surface-container);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(0,0,0,0.05);
    }
    .rc .t { 
      font-family: var(--font-sans);
      font-weight: 500;
      font-size: 16px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .badge {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }
    .badge.ok {
      background: #c4eed0;
      color: var(--success);
    }
    .badge.warn {
      background: #ffebb0;
      color: var(--warn);
    }
    .badge.err {
      background: var(--error-container);
      color: var(--error);
    }
    .ctx {
      background: var(--surface-container);
      border-radius: 12px;
      padding: 20px;
      margin-top: 12px;
    }
    .sc {
      background: var(--surface-container);
      border-radius: 12px;
      padding: 16px;
      text-align: center;
      transition: var(--transition);
    }
    .sc:hover {
      background: #e3e8ef;
    }
    .sc .v {
      font-size: 32px;
      font-family: var(--font-sans);
      font-weight: 400;
      color: var(--primary);
    }
    /* Chart containers */
    .chart-container {
      background: var(--surface);
      border-radius: 12px;
      padding: 16px;
      border: 1px solid var(--surface-container);
      height: 500px;
    }
    .timeline-container {
      position: relative;
      height: 500px;
    }
    /* Plant Selector */
    #plantSelector button {
      background: var(--surface) !important;
      border: 1px solid var(--outline-variant) !important;
      border-radius: 12px !important;
      box-shadow: none !important;
    }
    #plantSelector button:hover {
      background: var(--surface-container) !important;
      border-color: var(--primary) !important;
    }
    /* Scrollbar */
    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: #c4c7c5; border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: #747775; }
    .card-enter {
      animation: card-enter-animation 0.5s ease-out forwards;
      opacity: 0;
      transform: translateY(20px);
    }

    @keyframes card-enter-animation {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 24px;
    }
    section.grid {
      grid-template-columns: 2fr 1fr; /* Make the first column (stream) wider */
    }
    .sg {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .analytics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width: 992px) {
      section.grid {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 768px) {
      body {
        padding: 12px;
        -webkit-text-size-adjust: 100%; /* Prevent font scaling on iOS */
      }
      .wrap {
        gap: 16px;
      }
      .hero {
        padding: 24px 16px;
        text-align: center;
      }
      .hero h1 {
        font-size: 1.5rem; /* 24px */
      }
      .hero p {
        font-size: 0.9rem; /* 14px */
      }
      .card {
        padding: 16px;
      }
      h2 {
        font-size: 1.25rem; /* 20px */
      }
      .grid, .analytics-grid, .sg, .stats-grid, .status {
        grid-template-columns: 1fr;
        gap: 16px;
      }
      .ip-config {
        flex-direction: column;
        align-items: stretch;
      }
      .ip-config input, .ip-config button {
        width: 100%;
        min-width: 0;
      }
      .actions {
        flex-direction: column;
        align-items: stretch;
      }
      .actions .btn {
        width: 100%;
      }
      #plantSelector {
        grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
        gap: 8px;
      }
      .head {
        flex-direction: column;
        align-items: flex-start;
        gap: 12px;
      }
       .head > div {
        width: 100%;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .head > div > .btn {
        flex-grow: 1;
      }
      .history-panel .card {
        flex-direction: column;
      }
      .history-panel .card .history-image {
        max-width: 100%;
        height: auto;
      }

      /* Responsive Table for Results */
      .results-table {
        border-collapse: collapse;
        width: 100%;
      }
      .results-table thead {
        display: none;
      }
      .results-table tr { 
        display: block;
        border: 1px solid var(--outline-variant);
        margin-bottom: 1rem;
        border-radius: 8px;
        padding: 8px;
      }
      .results-table td { 
        display: block;
        border: none;
        border-bottom: 1px solid var(--outline);
        position: relative;
        padding-left: 50% !important; 
        text-align: right;
        padding-top: 12px !important;
        padding-bottom: 12px !important;
        display: flex;
        align-items: center;
        justify-content: flex-end;
      }
      .results-table td:before { 
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        left: 12px;
        width: 45%; 
        padding-right: 10px; 
        white-space: nowrap;
        text-align: left;
        font-weight: bold;
        color: var(--on-surface);
        content: attr(data-label);
      }
      .results-table td:last-child {
        border-bottom: 0;
      }
      .results-table td > div { /* for the feedback buttons */
        width: 100%;
      }

    </style>
</head>
<body>
  <main class="wrap">
    <section class="hero">
      <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                  <p class="translatable">Advanced Crop Diagnostics Platform</p>
                  <h1 class="translatable">Agri-Nigrani: Crop Analysis</h1>
                  <p class="translatable">Real-time analysis, AI-driven insights, and sensor integration.</p>
                </div>
                <div id="languageSelector" style="display: flex; gap: 8px; align-items: center;">
                  <button class="btn sec" onclick="translateToBangla()" title="Switch to Bangla">ржмрж╛ржВрж▓рж╛</button>
                  <button class="btn sec" onclick="translateToEnglish()" title="Switch to English">ENGLISH</button>
                </div>
              </div>
            </section>
        
            <article class="card">
              <div class="head">
                <h2 class="translatable">SYSTEM DASHBOARD</h2>
                <button class="btn sec" onclick="location.reload()"><span>ЁЯФД</span> <span class="translatable">Restart</span></button>
              </div>
              <section class="status">
                <div class="chip"><span class="dot offline" id="espDot"></span><span id="espStatus" class="translatable">ESP</span></div>
                <div class="chip"><span class="dot offline" id="camDot"></span><span id="cs" class="translatable">Camera</span></div>
                <div class="chip"><span class="dot offline" id="mqttDot"></span><span id="mqttStatus" class="translatable">MQTT</span></div>
                <div class="chip"><span class="dot offline" id="firebaseDot"></span><span id="firebaseText" class="translatable">Firebase</span></div>
              </section>
            </article>

    <section class="grid">
      <article class="card">
        <div class="head">
          <h2 class="translatable">Live Camera Stream</h2>
          <span class="pill translatable">Live</span>
        </div>
        <div class="ip-config" style="margin-bottom: 24px; border: none; padding: 0; box-shadow: none; background: transparent;">
          <span style="font-size: 14px; color: var(--on-surface-variant); font-weight: 500;" class="translatable">ESP32 Camera IP:</span>
          <input type="text" id="ipInput" placeholder="10.180.248.XXX" value="10.180.248.33">
          <button onclick="setIP()" class="translatable">Connect</button>
          <span id="connStatus" style="font-size: 13px; color: var(--on-surface-variant);"></span>
        </div>
        <div class="frame">
          <img id="str" alt="Stream" style="display: none;">
          <p id="streamPlaceholder" style="color: var(--on-surface-variant); font-size: 14px;" class="translatable">Enter ESP32 IP address above</p>
        </div>
        
        <!-- Plant Selection -->
        <div style="padding: 20px; background: var(--surface-container); border-radius: 12px; margin-top: 24px;">
          <h4 style="margin: 0 0 12px 0; color: var(--primary); font-size: 14px; font-weight: 600;" class="translatable">
            ЁЯМ▒ Select Crop for Analysis
          </h4>
          <div id="plantSelector" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px;">
            <!-- Plant buttons will be inserted here -->
          </div>
          <div id="selectedPlantInfo" style="margin-top: 12px; padding: 12px; background: var(--surface); border-radius: 8px; border-left: 4px solid var(--primary); box-shadow: var(--elevation-1);">
            <div style="font-size: 13px; font-weight: 500; color: var(--on-surface); margin-bottom: 4px;">
              <span class="translatable">Selected:</span> <span id="selectedPlantName" style="color: var(--primary);">ЁЯМ┐ All Plants</span>
            </div>
            <div style="font-size: 12px; color: var(--on-surface-variant);" id="selectedPlantDesc">Using all 7 AI models for comprehensive analysis</div>
          </div>
        </div>
        
        <div class="actions">
          <button id="visualBtn" class="btn pri" onclick="visualOnly()" disabled><span >ЁЯФН</span> <span class="translatable">Analyze Stream</span></button>
          <button id="toggleBtn" class="btn sec" onclick="toggleStream()" disabled><span >ЁЯУ╣</span> <span class="translatable">Start Stream</span></button>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 class="translatable">Analyze Local Image</h2>
          <span class="pill translatable">Local</span>
        </div>
        <div id="localImagePreview" class="frame" style="display: none;min-height: 240px;"></div>
        <p id="localImagePlaceholder" style="color: var(--on-surface-variant); font-size: 14px; text-align: center;" class="translatable">Select an image to analyze</p>
        <div class="actions">
          <input type="file" id="imageInput" accept="image/*" capture="environment" style="display: none;">
          <button class="btn sec translatable" onclick="document.getElementById('imageInput').click()">Choose Image</button>
          <button id="localAnalyzeBtn" class="btn pri translatable" onclick="analyzeLocalImage()" disabled>Analyze Image</button>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 class="translatable">Diagnostic Results</h2>
        </div>
        <div id="res" class="results">
          <div class="rc">
            <div class="t translatable">Awaiting Analysis</div>
            <p style="color: var(--on-surface-variant); font-size: 14px; margin-bottom: 16px;" class="translatable">Connect to a device and then run diagnostics.</p>
            
            <!-- Disease Detection Models Display -->
            <div style="background: rgba(26, 115, 232, 0.05); border-radius: 8px; padding: 16px; margin-top: 12px;">
              <h4 style="margin: 0 0 12px 0; color: var(--primary); font-size: 14px; font-weight: 600;" class="translatable">
                Active Detection Models
              </h4>
              <div id="modelsList" style="display: flex; flex-direction: column; gap: 8px;">
                <!-- Models will be displayed here -->
              </div>
            </div>
          </div>
        </div>
        <div id="ctx" class="ctx">
          <h4 class="translatable">Context notes</h4>
          <ul>
            <li class="translatable">Awaiting connection...</li>
          </ul>
        </div>
        
        <!-- AI Verification Section Removed -->
      </article>
    </section>

    <article class="card">
      <div class="head">
        <h2 class="translatable">Environment Monitor</h2>
        <div class="chip"><span class="dot" id="arduinoDot"></span><span id="arduinoStatus" class="translatable">Not Connected</span></div>
      </div>
      <div class="sg">
        <div class="sc">
          <div class="l translatable">Temperature</div>
          <div class="v" id="temperature">--</div>
          <div class="u">┬░C</div>
        </div>
        <div class="sc">
          <div class="l translatable">Humidity</div>
          <div class="v" id="humidity">--</div>
          <div class="u">%</div>
        </div>
        <div class="sc">
          <div class="l translatable">Soil Moisture</div>
          <div class="v" id="soilMoisture">--</div>
          <div class="u"></div>
        </div>
      </div>
      <div class="actions">
        <button id="pumpBtn" class="btn pri" onclick="togglePump()"><span class="translatable">Toggle Pump</span></button>
      </div>
    </article>

    <!-- Environment panel removed for visual-only workflow -->

    <article class="card">
      <div class="head">
        <h2 class="translatable">Platform Analytics</h2>
        <div style="display: flex; gap: 8px; align-items: center;">

        </div>
      </div>
      
      <div class="stats-grid" id="statsGrid">
        <div class="stat-box">
          <div class="label translatable">Total Scans</div>
          <div class="value" id="totalScans">0</div>
        </div>
        <div class="stat-box">
          <div class="label translatable">Diseases Detected</div>
          <div class="value" id="diseasesFound">0</div>
          <div class="change up" id="diseaseChange">--</div>
        </div>
        <div class="stat-box">
          <div class="label translatable">Avg. Confidence</div>
          <div class="value" id="avgConfidence">0%</div>
        </div>
        <div class="stat-box">
          <div class="label translatable">Threat Level</div>
          <div class="value" id="riskLevel">Low</div>
        </div>
      </div>

      <div class="analytics-grid">
        <div class="card" style="padding: 12px;">
          <h3 style="font-size: 14px; margin-bottom: 12px; color: var(--on-surface-variant);" class="translatable">Disease Distribution</h3>
          <div class="chart-container">
            <canvas id="diseaseChart"></canvas>
          </div>
        </div>
        
        <div class="card" style="padding: 12px;">
          <h3 style="font-size: 14px; margin-bottom: 12px; color: var(--on-surface-variant);" class="translatable">Confidence Trend</h3>
          <div class="chart-container">
            <canvas id="confidenceChart"></canvas>
          </div>
        </div>
      </div>

      <div class="analytics-grid" style="margin-top: 16px;">
        <!-- Sensor-related charts removed -->
      </div>

      <div style="margin-top: 16px;">
        <div class="card" style="padding: 20px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="font-size: 16px; margin: 0; color: var(--primary); font-weight: 600;" class="translatable">ЁЯОп Model Performance Feedback</h3>
            <button onclick="resetModelFeedback()" style="background: var(--error); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 6px;">
              <span class="translatable">ЁЯЧСя╕П</span>
              <span class="translatable">Reset Feedback Data</span>
            </button>
          </div>
          <div id="modelPrecisionChartContainer" style="height: 500px; width: 100%;">
            <canvas id="modelPrecisionChart"></canvas>
          </div>
          <p style="margin-top: 12px; font-size: 12px; color: var(--on-surface-variant); text-align: center;" class="translatable">Rate model predictions to see real-world accuracy. Higher bars = better performance.</p>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 class="translatable">Diagnostic History</h2>
          <div style="display: flex; gap: 8px; align-items: center;">
            <span class="firebase-status" id="firebaseStatus">
              <span id="firebaseIcon">тЪк</span>
              <span id="firebaseStatusText" class="translatable">Not connected</span>
            </span>
            <button class="btn sec" onclick="syncWithFirebase()"><span class="translatable">ЁЯФД Sync</span></button>
          </div>
        </div>

        <div class="card" style="padding: 12px; margin-bottom: 16px;">
          <h3 style="font-size: 14px; margin-bottom: 12px; color: var(--on-surface-variant);" class="translatable">Detection Timeline</h3>
          <div class="timeline-container">
            <canvas id="timelineChart"></canvas>
          </div>
        </div>

        <div class="card" style="padding: 12px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
            <h3 style="font-size: 14px; margin: 0; color: var(--on-surface-variant);" class="translatable">Analysis Log</h3>
            <div style="display: flex; gap: 8px;">
              <button class="btn sec translatable" onclick="loadFromFirebase()" style="padding: 8px 16px; font-size: 13px;">ЁЯУе Load</button>
              <button class="btn sec translatable" onclick="filterHistory('all')" style="padding: 8px 16px; font-size: 13px;">All</button>
              <button class="btn sec translatable" onclick="filterHistory('diseases')" style="padding: 8px 16px; font-size: 13px;">Diseases</button>
              <button class="btn sec translatable" onclick="filterHistory('healthy')" style="padding: 8px 16px; font-size: 13px;">Healthy</button>
              <button class="btn pri" onclick="clearAnalyticsData()" style="padding: 8px 16px; font-size: 13px;"><span class="translatable">ЁЯЧСя╕П Clear Diagnostic Log</span></button>
            </div>
          </div>
          <div class="history-panel" id="historyPanel">
            <p style="text-align: center; color: var(--on-surface-variant); padding: 32px;" class="translatable">No diagnostic logs yet. Run your first analysis to get started.</p>
          </div>
        </div>
      </article>
    </main>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const cards = document.querySelectorAll('.card');
        cards.forEach((card, index) => {
          card.classList.add('card-enter');
          card.style.animationDelay = `${index * 100}ms`;
        });

        // Handle local image selection
        document.getElementById('imageInput').addEventListener('change', (event) => {
          const file = event.target.files[0];
          if (!file) return;

          const reader = new FileReader();
          reader.onload = (e) => {
            const preview = document.getElementById('localImagePreview');
            const placeholder = document.getElementById('localImagePlaceholder');
            preview.innerHTML = `<img src="${e.target.result}" style="max-width:100%; max-height:400px; border-radius:8px;" alt="Selected image">`;
            preview.style.display = 'block';
            placeholder.style.display = 'none';
            document.getElementById('localAnalyzeBtn').disabled = false;
          };
          reader.readAsDataURL(file);
        });
      });

      
async function infer(base64Image, model) {
  try {
    console.log('Calling model:', model.name);
    const rf = await fetch('https://serverless.roboflow.com/' + model.id + '?api_key=' + K, {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: base64Image
    });

    if (!rf.ok) {
      throw Error('HTTP ' + rf.status);
    }

    const data = await rf.json();
    console.log(model.name + ' response:', data);

    // Apply class name mapping if model returns numeric IDs
    if (CLASS_NAME_MAPPING[model.id] && data.predictions) {
      data.predictions = data.predictions.map(pred => {
        if (CLASS_NAME_MAPPING[model.id][pred.class]) {
          console.log('Mapping class ID "' + pred.class + '" to "' + CLASS_NAME_MAPPING[model.id][pred.class] + '" for ' + model.name);
          return { ...pred, class: CLASS_NAME_MAPPING[model.id][pred.class] };
        }
        return pred;
      });
    }

    return { name: model.name, type: model.type, data: data, error: null, modelId: model.id };
  } catch (e) {
    console.error(model.name + ' error:', e);
    return { name: model.name, type: model.type, data: null, error: e.message, modelId: model.id };
  }
}

function calculateConsensus(results) {
    const diseaseDetections = [];
    const healthyDetections = [];

    results.forEach(r => {
        if (r.error) return;

        let disease = '';
        let conf = 0;

        if (r.type === 'detection' && r.data.predictions && r.data.predictions.length > 0) {
            const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
            disease = top.class;
            conf = top.confidence * 100;

            if (!disease || disease === '' || /^\d+$/.test(disease)) {
                console.warn('тЪая╕П Model "' + r.name + '" returned invalid class name:', disease);
                return;
            }
        } else if (r.type === 'classification' && (r.data.top || r.data.predicted_classes)) {
            disease = r.data.top || r.data.predicted_classes[0];
            conf = (r.data.confidence || 0) * 100;
        }

        const diseaseNormalized = (disease || '').toLowerCase().trim();

        if (conf > 0 && disease) {
            if (diseaseNormalized === 'healthy' || diseaseNormalized === 'no detection') {
                healthyDetections.push({ model: r.name, disease, confidence: conf });
            } else {
                diseaseDetections.push({ model: r.name, disease, confidence: conf });
            }
        }
    });

    let primaryDisease = 'Healthy';
    let primaryConfidence = 0;
    let consensusNote = '';

    if (diseaseDetections.length > 0) {
        const diseaseVotes = {};
        diseaseDetections.forEach(d => {
            const key = d.disease.toLowerCase();
            if (!diseaseVotes[key]) {
                diseaseVotes[key] = { disease: d.disease, votes: 0, totalConf: 0, models: [] };
            }
            diseaseVotes[key].votes++;
            diseaseVotes[key].totalConf += d.confidence;
            diseaseVotes[key].models.push(d.model);
        });

        let bestDisease = null;
        let bestScore = 0;

        for (const key in diseaseVotes) {
            const vote = diseaseVotes[key];
            const avgConf = vote.totalConf / vote.votes;
            const score = (vote.votes * 50) + avgConf;

            if (score > bestScore) {
                bestScore = score;
                bestDisease = vote;
            }
        }

        if (bestDisease) {
            primaryDisease = bestDisease.disease;
            primaryConfidence = bestDisease.totalConf / bestDisease.votes;

            if (healthyDetections.length > 0) {
                consensusNote = 'тЪая╕П Consensus Override: ' + diseaseDetections.length + ' model(s) detected disease, ' +
                    healthyDetections.length + ' said healthy. Prioritizing disease detection.';
            }

            if (bestDisease.votes > 1) {
                consensusNote += ' тЬУ ' + bestDisease.votes + ' models agree on "' + primaryDisease + '"';
            }
        }
    } else if (healthyDetections.length === results.length - results.filter(r => r.error).length) {
        primaryDisease = 'Healthy';
        primaryConfidence = healthyDetections.reduce((sum, h) => sum + h.confidence, 0) / healthyDetections.length;
        consensusNote = 'тЬУ All models agree: Leaf appears healthy';
    }

    return {
        disease: primaryDisease,
        confidence: primaryConfidence,
        note: consensusNote,
        diseaseCount: diseaseDetections.length,
        healthyCount: healthyDetections.length
    };
}

    async function analyzeLocalImage() {
      const imageInput = document.getElementById('imageInput');
      const analyzeBtn = document.getElementById('localAnalyzeBtn');
      if (!imageInput.files || imageInput.files.length === 0) {
        alert('Please select an image first.');
        return;
      }

      // Disable button and show spinner
      analyzeBtn.disabled = true;
      analyzeBtn.innerHTML = '<div style="width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite;"></div><span>' + translateText('Analyzing...') + '</span>';

      const file = imageInput.files[0];
      const reader = new FileReader();
      reader.onloadend = async function() {
        const base64Image = reader.result.split(',')[1];
        
        // Get active models based on plant selection
        const plantName = PLANT_TYPES.find(p => p.id === selectedPlantType)?.name || 'All Plants';
        const activeModels = getActiveModels();

        console.log('Selected plant type:', selectedPlantType);
        console.log('Active models count:', activeModels.length);
        console.log('Active models:', activeModels.map(m => m.name));

        // Show analysis in progress in the results panel
        document.getElementById('res').innerHTML = `<div class="rc"><div class="t">Analyzing local image of ${plantName} with ${activeModels.length} AI models...</div><p style="color: var(--on-surface-variant); font-size: 14px;">Processing image...</p></div>`;

        // Run analysis
        try {
          const results = await Promise.all(activeModels.map(model => infer(base64Image, model)));
          const consensusData = calculateConsensus(results);
          geminiRecommendation = null; // Set to null for local analysis
          showMultiModelResults(results, null, base64Image, consensusData);
        } catch (e) {
          document.getElementById('res').innerHTML = `<div class="rc"><div class="t">Failed<span class="badge err">Error</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">${e.message}</p></div>`;
        } finally {
          // Re-enable button and restore text
          analyzeBtn.disabled = false;
          analyzeBtn.innerHTML = 'Analyze Image';
        }
      }
      reader.readAsDataURL(file);
    }



  </script>


  <!-- Translation feature removed -->
  <script>
    // Simple translation toggles (English <-> Bangla)
    const TRANSLATIONS_BN = {
      /* UI */
      'Advanced Crop Diagnostics Platform': 'ржЙржирзНржиржд ржлрж╕рж▓ ржирж┐рж░рзНржгржпрж╝рзЗрж░ ржкрзНрж▓рзНржпрж╛ржЯржлрж░рзНржо',
      'Agri-Nigrani: Crop Analysis': 'ржХрзГрж╖рж┐-ржирж┐ржЧрзНрж░рж╛ржирж┐: ржлрж╕рж▓ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг',
      'Real-time analysis, AI-driven insights, and sensor integration.': 'рж░рж┐ржпрж╝рзЗрж▓-ржЯрж╛ржЗржо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг, ржПржЖржЗ-ржЪрж╛рж▓рж┐ржд ржЕржирзНрждрж░рзНржжрзГрж╖рзНржЯрж┐ ржПржмржВ рж╕рзЗржирзНрж╕рж░ ржЗржирзНржЯрж┐ржЧрзНрж░рзЗрж╢ржиред',
      'SYSTEM DASHBOARD': 'рж╕рж┐рж╕рзНржЯрзЗржо ржбрзНржпрж╛рж╢ржмрзЛрж░рзНржб',
      'Restart': 'ржкрзБржирж░рж╛ржпрж╝ ржЪрж╛рж▓рзБ ржХрж░рзБржи',
      'ESP': 'ржЗржПрж╕ржкрж┐',
      'Camera': 'ржХрзНржпрж╛ржорзЗрж░рж╛',
      'MQTT': 'ржПржоржХрж┐ржЙржЯрж┐ржЯрж┐',
      'Firebase': 'ржлрж╛ржпрж╝рж╛рж░ржмрзЗрж╕',
      'Live Camera Stream': 'рж▓рж╛ржЗржн ржХрзНржпрж╛ржорзЗрж░рж╛ рж╕рзНржЯрзНрж░рж┐ржо',
      'Live': 'рж▓рж╛ржЗржн',
      'ESP32 Camera IP:': 'ржЗржПрж╕ржкрж┐рзйрзи ржХрзНржпрж╛ржорзЗрж░рж╛ ржЖржЗржкрж┐:',
      'Connect': 'рж╕ржВржпрзЛржЧ ржХрж░рзБржи',
      'Enter ESP32 IP address above': 'ржЙржкрж░рзЗрж░ ржЗржПрж╕ржкрж┐рзйрзи ржЖржЗржкрж┐ ржарж┐ржХрж╛ржирж╛ рж▓рж┐ржЦрзБржи',
      'ЁЯМ▒ Select Crop for Analysis': 'ЁЯМ▒ ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗрж░ ржЬржирзНржп ржлрж╕рж▓ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи',
      'Selected:': 'ржирж┐рж░рзНржмрж╛ржЪрж┐ржд:',
      'Using all 7 AI models for comprehensive analysis': 'рж╕ржорзНржкрзВрж░рзНржг ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗрж░ ржЬржирзНржп рзнржЯрж┐ ржПржЖржЗ ржоржбрзЗрж▓ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ',
      'Analyze Stream': 'рж╕рзНржЯрзНрж░рж┐ржо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рзБржи',
      'Start Stream': 'рж╕рзНржЯрзНрж░рж┐ржо рж╢рзБрж░рзБ ржХрж░рзБржи',
      'Analyze Local Image': 'рж╕рзНржерж╛ржирзАржпрж╝ ржЪрж┐рждрзНрж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рзБржи',
      'Local': 'рж╕рзНржерж╛ржирзАржпрж╝',
      'Select an image to analyze': 'ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗрж░ ржЬржирзНржп ржПржХржЯрж┐ ржЪрж┐рждрзНрж░ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи',
      'Choose Image': 'ржЪрж┐рждрзНрж░ ржирж┐рж░рзНржмрж╛ржЪржи ржХрж░рзБржи',
      'Analyze Image': 'ржЪрж┐рждрзНрж░ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рзБржи',
      'Diagnostic Results': 'ржбрж╛ржпрж╝рж╛ржЧржирж╕рзНржЯрж┐ржХ ржлрж▓рж╛ржлрж▓',
      'Awaiting Analysis': 'ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗ',
      'Connect to a device and then run diagnostics.': 'ржПржХржЯрж┐ ржбрж┐ржнрж╛ржЗрж╕рзЗрж░ рж╕рж╛ржерзЗ рж╕ржВржпрзЛржЧ ржХрж░рзБржи ржПржмржВ рждрж╛рж░ржкрж░ ржбрж╛ржпрж╝рж╛ржЧржирж╕рзНржЯрж┐ржХ ржЪрж╛рж▓рж╛ржиред',
      'Environment Monitor': 'ржкрж░рж┐ржмрзЗрж╢ ржоржирж┐ржЯрж░',
      'Not Connected': 'рж╕ржВржпрзБржХрзНржд ржиржпрж╝',
      'Temperature': 'рждрж╛ржкржорж╛рждрзНрж░рж╛',
      'Humidity': 'ржЖрж░рзНржжрзНрж░рждрж╛',
      'Soil Moisture': 'ржорж╛ржЯрж┐рж░ ржЖрж░рзНржжрзНрж░рждрж╛',
      'Toggle Pump': 'ржкрж╛ржорзНржк ржЪрж╛рж▓рзБ/ржмржирзНржз ржХрж░рзБржи',
      'Platform Analytics': 'ржкрзНрж▓рзНржпрж╛ржЯржлрж░рзНржо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг',
      'Total Scans': 'ржорзЛржЯ рж╕рзНржХрзНржпрж╛ржи',
      'Diseases Detected': 'рж░рзЛржЧ рж╕ржирж╛ржХрзНржд',
      'Avg. Confidence': 'ржЧржбрж╝ ржЖрждрзНржоржмрж┐рж╢рзНржмрж╛рж╕',
      'Threat Level': 'рж╣рзБржоржХрж┐рж░ рж╕рзНрждрж░',
      'Disease Distribution': 'рж░рзЛржЧ ржмрж┐рждрж░ржг',
      'Confidence Trend': 'ржЖрждрзНржоржмрж┐рж╢рзНржмрж╛рж╕ ржкрзНрж░ржмржгрждрж╛',
      'Diagnostic History': 'ржбрж╛ржпрж╝рж╛ржЧржирж╕рзНржЯрж┐ржХ ржЗрждрж┐рж╣рж╛рж╕',
      'Not connected': 'рж╕ржВржпрзБржХрзНржд ржиржпрж╝',
      'Sync': 'рж╕рж┐ржЩрзНржХ',
      'Detection Timeline': 'рж╕ржирж╛ржХрзНрждржХрж░ржг рж╕ржоржпрж╝рж░рзЗржЦрж╛',
      'Analysis Log': 'ржмрж┐рж╢рзНрж▓рзЗрж╖ржг рж▓ржЧ',
      'Load': 'рж▓рзЛржб',
      'All': 'рж╕ржм',
      'Diseases': 'рж░рзЛржЧ',
      'Healthy': 'рж╕рзБрж╕рзНрже',
      'ЁЯЧСя╕П Clear Diagnostic Log': 'ЁЯЧСя╕П ржбрж╛ржпрж╝рж╛ржЧржирж╕рзНржЯрж┐ржХ рж▓ржЧ ржорзБржЫрзБржи',
      'No diagnostic logs yet. Run your first analysis to get started.': 'ржПржЦржиржУ ржХрзЛржиржУ ржбрж╛ржпрж╝рж╛ржЧржирж╕рзНржЯрж┐ржХ рж▓ржЧ ржирзЗржЗред рж╢рзБрж░рзБ ржХрж░рждрзЗ ржЖржкржирж╛рж░ ржкрзНрж░ржержо ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржЪрж╛рж▓рж╛ржиред',

      /* Plants */
      'All Plants (General)': 'рж╕ржм ржлрж╕рж▓ (рж╕рж╛ржзрж╛рж░ржг)',
      'Rice': 'ржзрж╛ржи',
      'Wheat': 'ржЧржо',
      'Chili/Pepper': 'ржорж░рж┐ржЪ/ржХрж╛ржБржЯрж╛ржмрзЗрж▓',
      'Potato': 'ржЖрж▓рзБ',
      'Tomato': 'ржЯржорзЗржЯрзЛ',
      'Eggplant/Brinjal': 'ржмрзЗржЧрзБржи/ржмрзНрж░рж┐ржиржЬрж╛рж▓',
      'models': 'ржоржбрзЗрж▓',

      /* Models */
      'Object Detection (YOLOv8)': 'ржЕржмржЬрзЗржХрзНржЯ рж╕ржирж╛ржХрзНрждржХрж░ржг (YOLOv8)',
      'Rice Disease Detection (YOLOv8s)': 'ржзрж╛ржи рж░рзЛржЧ рж╕ржирж╛ржХрзНрждржХрж░ржг (YOLOv8s)',
      'Wheat Disease (100% Accuracy)': 'ржЧржо рж░рзЛржЧ (рззрзжрзж% ржирж┐рж░рзНржнрзБрж▓рждрж╛)',
      'Chili Plant Disease (81% mAP)': 'ржорж░рж┐ржЪ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ (рзорзз% mAP)',
      'Potato Disease (98.8% mAP)': 'ржЖрж▓рзБ рж░рзЛржЧ (рзпрзо.рзо% mAP)',
      'Tomato Disease (92.3% mAP)': 'ржЯржорзЗржЯрзЛ рж░рзЛржЧ (рзпрзи.рзй% mAP)',
      'Eggplant Disease (47.8% mAP)': 'ржмрзЗржЧрзБржи рж░рзЛржЧ (рзкрзн.рзо% mAP)',

      /* Result / UI strings */
      'Analyzing': 'ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ',
      'with': 'рж╕рж╛ржерзЗ',
      'AI models': 'ржПржЖржЗ ржоржбрзЗрж▓',
      'Multi-Model Analysis': 'ржмрж╣рзБ-ржоржбрзЗрж▓ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг',
      'Captured Image': 'ржзрж░рж╛ ржЪрж┐рждрзНрж░',
      'Image saved to Firebase Firestore': 'ржЪрж┐рждрзНрж░ ржлрж╛ржпрж╝рж╛рж░ржмрзЗрж╕рзЗ рж╕ржВрж░ржХрзНрж╖ржг ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ',
      'Smart Consensus Decision': 'рж╕рзНржорж╛рж░рзНржЯ рж╕ржорзНржоржд рж╕рж┐ржжрзНржзрж╛ржирзНржд',
      'Final Verdict:': 'ржЪрзВржбрж╝рж╛ржирзНржд рж╕рж┐ржжрзНржзрж╛ржирзНржд:',
      'Model(s) Detected Disease': 'ржоржбрзЗрж▓(ржЧрзБрж▓рж┐) рж░рзЛржЧ рж╕ржирж╛ржХрзНржд ржХрж░рзЗржЫрзЗ',
      'Model(s) Said Healthy': 'ржоржбрзЗрж▓(ржЧрзБрж▓рж┐) рж╕рзБрж╕рзНрже ржмрж▓рзЗржЫрзЗ',

      /* Table headers and labels */
      'Model': 'ржоржбрзЗрж▓',
      'Disease Detected': 'рж╕ржирж╛ржХрзНржд рж░рзЛржЧ',
      'Confidence': 'ржЖрждрзНржоржмрж┐рж╢рзНржмрж╛рж╕',
      'Recommended Treatment': 'ржкрзНрж░рж╕рзНрждрж╛ржмрж┐ржд ржЪрж┐ржХрж┐рзОрж╕рж╛',
      'Your Feedback': 'ржЖржкржирж╛рж░ ржкрзНрж░рждрж┐ржХрзНрж░рж┐ржпрж╝рж╛',
      'No detection': 'ржХрзЛржирзЛ рж╕ржирж╛ржХрзНрждржХрж░ржг ржирзЗржЗ',
      'Unknown Disease': 'ржЕржЬрж╛ржирж╛ рж░рзЛржЧ',

      /* Badges */
      'High': 'ржЙржЪрзНржЪ',
      'Medium': 'ржоржзрзНржп',
      'Low': 'ржХржо',
      'Error': 'рждрзНрж░рзБржЯрж┐',
      'Invalid': 'ржЕржмрзИржз',

      /* Common diseases (subset) */
      'Bacterial Spot': 'ржмрзНржпрж╛ржХржЯрзЗрж░рж┐ржпрж╝рж╛рж▓ рж╕рзНржкржЯ',
      'Early Blight': 'ржкрзНрж░рж╛ржержорж┐ржХ ржмрзНрж▓рж╛ржЗржЯ',
      'Late Blight': 'ржкрж░ржмрж░рзНрждрзА ржмрзНрж▓рж╛ржЗржЯ',
      'Leaf Mold': 'ржкрж╛рждрж╛ ржЫрзЗржБрзЬрж╛',
      'Septoria Leaf Spot': 'рж╕рзЗржкрзНржЯрзЛрж░рж┐ржпрж╝рж╛ рж▓рж┐ржл рж╕рзНржкржЯ',
      'Spider Mites': 'ржорж╛ржХрзЬрж╢рж╛ ржХрзАржЯ',
      'Target Spot': 'ржЯрж╛рж░рзНржЧрзЗржЯ рж╕рзНржкржЯ',
      'Mosaic Virus': 'ржорзЛржЬрж╛ржЗржХ ржнрж╛ржЗрж░рж╛рж╕',
      'Yellow Leaf Curl Virus': 'рж╣рж▓рзБржж ржкрж╛рждрж╛рж░ ржХрж╛рж░рзНрж▓ ржнрж╛ржЗрж░рж╛рж╕',
      'Powdery Mildew': 'ржкрж╛ржЙржбрж╛рж░рж┐ ржорж┐рж▓ржбрж┐ржЙ',
      'Rust': 'рж░рж╕рзНржЯ',
      'Anthracnose': 'ржЕрзНржпрж╛ржиржерзНрж░рж╛ржХржирзЛржЬ',
      'Blight': 'ржмрзНрж▓рж╛ржЗржЯ',
      'Scab': 'рж╕рзНржХрзНржпрж╛ржм',
      'Wilt': 'ржЙржЗрж▓рзНржЯ',
      'Downy Mildew': 'ржбрж╛ржЙржирж┐ ржорж┐рж▓ржбрж┐ржЙ',
      'Alternaria': 'ржЕрж▓ржЯрж╛рж░ржирж╛рж░рж┐ржпрж╝рж╛',
      'Fusarium': 'ржлрзБрж╕рж╛рж░рж┐ржпрж╝рж╛ржо',
      'Damping Off': 'ржбрж╛ржорзНржкрж┐ржВ ржЕржл',
      'Fruit Rot': 'ржлрж▓ ржкржЪрж╛',
      'Gray Mold': 'рж╢рзБржБржЯржХрж┐ ржЫрждрзНрж░рж╛ржХ',
      'Stem Rot': 'рждржирзБ ржкржЪрж╛',
      'Root Rot': 'ржорзВрж▓ ржкржЪрж╛',
      'Collar Rot': 'ржХрж▓рж╛рж░ рж░ржЯ',
      'Black Spot': 'ржХрж╛рж▓рзЛ ржжрж╛ржЧ',
      'Brown Spot': 'ржкрж░рзНржг ржжрж╛ржЧ',
      'Bacterial Wilt': 'ржмрзНржпрж╛ржХржЯрзЗрж░рж┐ржпрж╝рж╛рж▓ ржЙржЗрж▓рзНржЯ',
      'Cercospora Leaf Spot': 'рж╕рзЗрж░ржХрж╕рзНржкрзЛрж░рж╛ рж▓рж┐ржл рж╕рзНржкржЯ',
      'Sooty Mold': 'рж╕рзБржЯрж┐ ржЫрждрзНрж░рж╛ржХ',
      'Leaf Blight': 'ржкрж╛рждрж╛ ржмрзНрж▓рж╛ржЗржЯ',
      'Southern Blight': 'рж╕рж╛ржжрж╛рж░рзНржи ржмрзНрж▓рж╛ржЗржЯ',
      'Verticillium Wilt': 'ржнрж╛рж░рзНржЯрж┐рж╕рж┐рж▓рж┐ржпрж╝рж╛ржо ржЙржЗрж▓рзНржЯ',
      'Club Root': 'ржХрзНрж▓рж╛ржм рж░рзБржЯ',
      'Black Rot': 'ржХрж╛рж▓рзЛ ржкржЪрж╛',
      'White Rust': 'рж╕рж╛ржжрж╛ ржЬржВ',
      'Purple Blotch': 'ржмрзЗржЧрзБржирж┐ ржжрж╛ржЧ',
      'Soft Rot': 'ржирж░ржо ржкржЪрж╛',
      'Cucumber Mosaic': 'рж╢рж╕рж╛рж░ ржорзЛржЬрж╛ржЗржХ',
      'Gummy Stem Blight': 'ржЧрж╛ржорж┐ рж╕рзНржЯрзЗржо ржмрзНрж▓рж╛ржЗржЯ',
      'Angular Leaf Spot': 'ржЕрзНржпрж╛ржЩрзНржЧрзБрж▓рж╛рж░ рж▓рж┐ржл рж╕рзНржкржЯ',
      'Bacterial Canker': 'ржмрзНржпрж╛ржХржЯрзЗрж░рж┐ржпрж╝рж╛рж▓ ржХрзНржпрж╛ржирзНржХрж╛рж░',
      'Aphids': 'ржЕрзНржпрж╛ржлрж┐ржбрж╕',
      'Whitefly': 'рж╣рзЛржпрж╝рж╛ржЗржЯржлрзНрж▓рж╛ржЗ',
      'Thrips': 'ржерзНрж░рж┐ржкрж╕',
      'Fruit Borer': 'ржлрж▓ ржмрзЛрж░рж╛рж░',
      'Leaf Miner': 'ржкрж╛рждрж╛ ржЦржиржиржХрж╛рж░рзА',
      'Stem Borer': 'рждржирзБ ржмрзЛрж░рж╛рж░',
      'Cutworm': 'ржХрж╛ржЯржУржпрж╝рж╛рж░рзНржо',
      'Nematodes': 'ржирзЗржорж╛ржЯрзЛржбрж╕',

      /* Runtime / status */
      'Connecting...': 'рж╕ржВржпрзЛржЧ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...',
      'ESP32 reachable': 'ржЗржПрж╕ржкрж┐рзйрзи ржкрзМржБржЫрзЗржЫрзЗ',
      'Cannot reach ESP32 at': 'ржЗржПрж╕ржкрж┐рзйрзи ржкрзМржБржЫрж╛ржирзЛ ржпрж╛ржЪрзНржЫрзЗ ржирж╛',
      'Ready. Click "Start stream" to preview.': 'ржкрзНрж░рж╕рзНрждрзБрждред ржкрзВрж░рзНржмрж░рзВржк ржжрзЗржЦрждрзЗ "рж╕рзНржЯрж╛рж░рзНржЯ рж╕рзНржЯрзНрж░рж┐ржо" ржХрзНрж▓рж┐ржХ ржХрж░рзБржиред',
      'Connection failed. Check:\n1. ESP32 is powered on\n2. WiFi connected\n3. IP is correct: ': 'рж╕ржВржпрзЛржЧ ржмрзНржпрж░рзНржеред ржпрж╛ржЪрж╛ржЗ ржХрж░рзБржи:\n1. ржЗржПрж╕ржкрж┐рзйрзи ржЪрж╛рж▓рзБ ржЖржЫрзЗ\n2. ржУржпрж╝рж╛ржЗржлрж╛ржЗ рж╕ржВржпрзБржХрзНржд ржЖржЫрзЗ\n3. ржЖржЗржкрж┐ рж╕ржарж┐ржХ: ',
      'тП│ Loading...': 'рж▓рзЛржб рж╣ржЪрзНржЫрзЗ...',
      'ЁЯУе Load': 'рж▓рзЛржб',
      'тЭМ Failed to load image': 'ржЪрж┐рждрзНрж░ рж▓рзЛржб ржмрзНржпрж░рзНрже рж╣ржпрж╝рзЗржЫрзЗ',
      'тП│ Syncing...': 'рж╕рж┐ржЩрзНржХ рж╣ржЪрзНржЫрзЗ...',
      'ЁЯФД Sync': 'рж╕рж┐ржЩрзНржХ',
      'Starting...': 'рж╢рзБрж░рзБ рж╣ржЪрзНржЫрзЗ...',
      'Connecting to stream...': 'рж╕рзНржЯрзНрж░рж┐ржорзЗ рж╕ржВржпрзЛржЧ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ...',
      'Initializing stream...': 'рж╕рзНржЯрзНрж░рж┐ржо ржкрзНрж░рж╛ржержорж┐ржХржХрж░ржг...',
      'Stream connected': 'рж╕рзНржЯрзНрж░рж┐ржо рж╕ржВржпрзБржХрзНржд',
      'Stop Live View': 'рж▓рж╛ржЗржн ржнрж┐ржЙ ржмржирзНржз ржХрж░рзБржи',
      'Stop stream': 'рж╕рзНржЯрзНрж░рж┐ржо ржмржирзНржз ржХрж░рзБржи',
      'Start Live View': 'рж▓рж╛ржЗржн ржнрж┐ржЙ рж╢рзБрж░рзБ ржХрж░рзБржи',
      'Stream paused': 'рж╕рзНржЯрзНрж░рж┐ржо ржмрж┐рж░ржд',
      'тЬУ Marked as correct': 'тЬУ рж╕ржарж┐ржХ рж╣рж┐рж╕рзЗржмрзЗ ржЪрж┐рж╣рзНржирж┐ржд',
      'тЬЧ Marked as wrong': 'тЬЧ ржнрзБрж▓ рж╣рж┐рж╕рзЗржмрзЗ ржЪрж┐рж╣рзНржирж┐ржд',
      'Feedback recorded for': 'ржкрзНрж░рждрж┐ржХрзНрж░рж┐ржпрж╝рж╛ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ',
      'Analyzing...': 'ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржЪрж▓ржЫрзЗ...',
      'Capturing and processing image': 'ржЪрж┐рждрзНрж░ ржХрзНржпрж╛ржкржЪрж╛рж░ ржПржмржВ ржкрзНрж░ржХрзНрж░рж┐ржпрж╝рж╛ржХрж░ржг рж╣ржЪрзНржЫрзЗ',

      /* Firebase */
      'Firebase + AI enabled': 'ржлрж╛ржпрж╝рж╛рж░ржмрзЗрж╕ + ржПржЖржЗ рж╕ржХрзНрж░рж┐ржпрж╝',
      'Local storage only': 'рж╢рзБржзрзБржорж╛рждрзНрж░ рж▓рзЛржХрж╛рж▓ рж╕рзНржЯрзЛрж░рзЗржЬ',

      /* Feedback */
      'Feedback recorded for ': 'ржкрзНрж░рждрж┐ржХрзНрж░рж┐ржпрж╝рж╛ рж░рзЗржХрж░рзНржб ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ: ',
      'No image available': 'ржХрзЛржиржУ ржЪрж┐рждрзНрж░ ржирзЗржЗ',

      /* Urgency/Severity */
      'immediate': 'рждрж╛рждреНрдХрд╛рд▓рж┐ржХ',
      'immediate - remove infected plants': 'рждрж╛рждрзНржХрзНрж╖ржгрж┐ржХ - ржЖржХрзНрж░рж╛ржирзНржд ржЧрж╛ржЫ ржЕржкрж╕рж╛рж░ржг ржХрж░рзБржи',
      'within 24-48 hours': 'рзирзк-рзкрзо ржШржгрзНржЯрж╛рж░ ржоржзрзНржпрзЗ',
      'within 24 hours': 'рзирзк ржШржгрзНржЯрж╛рж░ ржоржзрзНржпрзЗ',
      'within 1 week': 'рзз рж╕ржкрзНрждрж╛рж╣рзЗрж░ ржоржзрзНржпрзЗ',
      'routine': 'рж╕рж╛ржзрж╛рж░ржг',
      'mild': 'ржорзГржжрзБ',
      'moderate': 'ржоржзрзНржп',
      'severe': 'ржЧрзБрж░рзБрждрж░',
      'severity': 'рждрзАржмрзНрж░рждрж╛',
      'Connected': 'рж╕ржВржпрзБржХрзНржд',
      'Correct': 'рж╕ржарж┐ржХ',
      'Wrong': 'ржнрзБрж▓',
      'Model:': 'ржоржбрзЗрж▓:'
    };

    // Helper to get current language
    function getLang() {
      try { return localStorage.getItem('lang') || 'en'; } catch(e) { return 'en'; }
    }

    // Translate a single string if available
    function translateText(text) {
      if (!text || typeof text !== 'string') return text;
      const lang = getLang();
      if (lang === 'bn' && TRANSLATIONS_BN[text]) return TRANSLATIONS_BN[text];
      return text;
    }

    // Small key-based getter used by some places (e.g., Gemini blocks)
    function gl(key) {
      const KEYMAP = {
        diseaseExplanation: 'Disease Explanation',
        severity: 'Severity',
        preventiveMeasures: 'Preventive Measures',
        organicTreatment: 'Organic Treatment',
        chemicalTreatment: 'Chemical Treatment',
        riskOfCropLoss: 'Risk of Crop Loss'
      };
      const english = KEYMAP[key] || key;
      return translateText(english);
    }

    function applyTranslation(map) {
      document.querySelectorAll('.translatable').forEach(el => {
        const key = el.textContent.trim();
        if (map[key]) el.textContent = map[key];
      });
    }

    function translateToBangla() {
      applyTranslation(TRANSLATIONS_BN);
      try { localStorage.setItem('lang', 'bn'); } catch(e) { /* ignore */ }
      const bnBtn = document.querySelector('#languageSelector button[onclick="translateToBangla()"]');
      const enBtn = document.querySelector('#languageSelector button[onclick="translateToEnglish()"]');
      if (bnBtn) bnBtn.classList.add('active');
      if (enBtn) enBtn.classList.remove('active');

      // Also re-render dynamic pieces if any are visible
      try { initPlantSelector(); displayActiveModels(); updateFirebaseStatus(firebaseReady); refreshRuntimeTranslations(); } catch(e){ /* ignore */ }
    }

    // Re-apply translations to runtime/hardware status texts where possible
    function refreshRuntimeTranslations() {
      try {
        // ESP / Stream status
        const conn = document.getElementById('connStatus');
        if (conn) {
          const t = conn.textContent || '';
          if (t.includes('ESP32 reachable') || t.includes('ржкрзМржЫрзЗржЫрзЗ')) {
            conn.textContent = 'тЬЕ ' + translateText('ESP32 reachable');
          } else if (t.includes('Cannot reach ESP32') || t.includes('ржкрзМржЫрж╛ржирзЛ')) {
            // Try to keep any IP in the message
            const ipMatch = t.match(/(\d+\.\d+\.\d+\.\d+)/);
            const ip = ipMatch ? ipMatch[0] : '';
            conn.textContent = (ip ? 'тЭМ ' + translateText('Cannot reach ESP32 at') + ' ' + ip : translateText('Cannot reach ESP32 at'));
          } else if (t.includes('Connecting')) {
            conn.textContent = translateText('Connecting...');
          } else if (t.includes('Stream connected') || t.includes('рж╕рзНржЯрзНрж░рж┐ржо')) {
            conn.textContent = 'тЬЕ ' + translateText('Stream connected');
          } else if (t.includes('Using capture polling')) {
            conn.textContent = 'тЪая╕П ' + translateText('Using capture polling');
          }
        }

        const placeholder = document.getElementById('streamPlaceholder');
        if (placeholder) {
          const pt = placeholder.textContent || '';
          if (pt.includes('Ready. Click')) placeholder.textContent = translateText('Ready. Click "Start stream" to preview.');
          if (pt.includes('Connection failed') || pt.includes('рж╕ржВржпрзЛржЧ ржмрзНржпрж░рзНрже')) placeholder.textContent = translateText('Connection failed. Check:\n1. ESP32 is powered on\n2. WiFi connected\n3. IP is correct: ');
        }

        // Arduino / MQTT / Firebase statuses
        const arduinoStatus = document.getElementById('arduinoStatus');
        if (arduinoStatus) {
          const v = arduinoStatus.textContent || '';
          if (v.includes('Connected') || v.includes('рж╕ржВржпрзБржХрзНржд')) arduinoStatus.textContent = translateText('Connected');
          if (v.includes('Not Connected') || v.includes('рж╕ржВржпрзБржХрзНржд ржиржпрж╝')) arduinoStatus.textContent = translateText('Not Connected');
        }

      } catch(e) { /* ignore */ }
    }

    function translateToEnglish() {
      try { localStorage.setItem('lang', 'en'); } catch(e) { /* ignore */ }
      location.reload();
    }

    // Apply persisted language preference on load
    document.addEventListener('DOMContentLoaded', () => {
      try {
        const lang = localStorage.getItem('lang');
        if (lang === 'bn') {
          translateToBangla();
        } else if (lang === 'en') {
          const enBtn = document.querySelector('#languageSelector button[onclick="translateToEnglish()"]');
          const bnBtn = document.querySelector('#languageSelector button[onclick="translateToBangla()"]');
          if (enBtn) enBtn.classList.add('active');
          if (bnBtn) bnBtn.classList.remove('active');
        }
      } catch(e) { /* ignore storage errors */ }
    });
  </script>

  <script>
    // ==================== PRODUCTION CONFIGURATION ====================
    const PRODUCTION_MODE = false; // Set to true to disable debug logging
    // Toggle automatic migration of legacy ESP32 IP from 192.168.1.33 -> 10.180.248.33
    // Default: false to preserve user-set IP addresses (e.g., when your ESP provides 192.168.1.33)
    const ALLOW_AUTO_IP_MIGRATION = false;
    
    // Optimized logging wrapper
    const log = {
      info: (...args) => !PRODUCTION_MODE && console.log(...args),
      warn: (...args) => console.warn(...args),
      error: (...args) => console.error(...args),
      success: (msg) => !PRODUCTION_MODE && console.log('тЬЕ', msg),
      debug: (...args) => !PRODUCTION_MODE && console.log('ЁЯФН', ...args)
    };
    
    // ==================== FIREBASE CONFIGURATION ======================================
    // Firebase project: agriculture-project-diploma
    const firebaseConfig = {
      apiKey: "AIzaSyCluvsF7ChTv1nfm6HzGVbvNZ4MmIwYSqA",
      authDomain: "agriculture-project-diploma.firebaseapp.com",
      databaseURL: "https://agriculture-project-diploma-default-rtdb.firebaseio.com",
      projectId: "agriculture-project-diploma",
      storageBucket: "agriculture-project-diploma.firebasestorage.app",
      messagingSenderId: "821352370665",
      appId: "1:821352370665:web:8133f8dffdb5f84bcbbb78",
      measurementId: "G-C4YL29SEP4"
    };
    
    // Google Cloud services removed - using Firebase Firestore only for storage

    // Initialize Firebase
    let db = null;
    let auth = null;
    let functions = null;
    let firebaseEnabled = false;
    let aiEnabled = false;
    let aiAnalysisEnabled = false;
    let firebaseReady = false;
    let firebaseReadyPromise = null;
    let geminiRecommendation = null;

    try {
      firebase.initializeApp(firebaseConfig);
      db = firebase.firestore();
      auth = firebase.auth();
      functions = firebase.functions();
      
      // Note: Offline persistence is optional and causes deprecation warnings in Firebase 9.22.0+
      // System works fine without it - data is saved to Firebase and localStorage
      
      // Create promise that resolves when Firebase is ready
      firebaseReadyPromise = new Promise((resolve, reject) => {
        // Anonymous authentication for simplicity
        auth.signInAnonymously()
          .then(() => {
            console.log('тЬЕ Firebase authenticated anonymously');
            console.log('User ID:', auth.currentUser.uid);
            firebaseEnabled = true;
            firebaseReady = true;
            aiEnabled = true; // Enable AI features
            updateFirebaseStatus(true);
            console.log('ЁЯдЦ Firebase AI features enabled');
            resolve();
          })
          .catch(err => {
            console.error('тЭМ Firebase auth error:', err);
            updateFirebaseStatus(false);
            reject(err);
          });
      });
      
      console.log('тЬЕ Firebase initialized');
    } catch (error) {
      log.warn('тЪая╕П Firebase not configured or disabled:', error.message);
      log.info('тД╣я╕П System will work with local storage only');
      updateFirebaseStatus(false);
    }

    function updateFirebaseStatus(connected) {
      const statusEl = document.getElementById('firebaseStatus');
      const iconEl = document.getElementById('firebaseIcon');
      const textEl = document.getElementById('firebaseStatusText');
      const firebaseDot = document.getElementById('firebaseDot');
      
      if (connected) {
        if(statusEl) statusEl.className = 'firebase-status connected';
        if(iconEl) iconEl.textContent = 'тЬЕ';
        if(textEl) textEl.textContent = translateText('Firebase + AI enabled');
        if(firebaseDot) firebaseDot.classList.remove('offline');
      } else {
        if(statusEl) statusEl.className = 'firebase-status disconnected';
        if(iconEl) iconEl.textContent = 'тЭМ';
        if(textEl) textEl.textContent = translateText('Local storage only');
        if (firebaseDot) firebaseDot.classList.add('offline');
      }
    }

    // ==================== ROBOFLOW CONFIGURATION ====================
    const K = 'uRVv39iPfwzK4NJJ0Gsw';
    
    // Google Cloud services removed - using Firebase Firestore only
    
    // Storage simplified - images stored as base64 in Firestore documents
    
    // Class name mapping for models that return numeric IDs
    const CLASS_NAME_MAPPING = {
      'tomato-disease-k8es2/2': {
        '0': 'Tomato Early Blight',
        '1': 'Tomato Late Blight',
        '2': 'Tomato Bacterial Spot',
        '3': 'Tomato Septoria Leaf Spot',
        '4': 'Tomato Target Spot',
        '5': 'Tomato Leaf Mold',
        '6': 'Tomato Yellow Leaf Curl Virus',
        '7': 'Tomato Mosaic Virus',
        '8': 'Tomato Spider Mites',
        '9': 'Tomato Healthy'
      },
      'potato-disease-balnv/2': {
        '0': 'Potato Early Blight',
        '1': 'Potato Late Blight',
        '2': 'Potato Healthy'
      }
    };
    
    // Multiple models for comparison
    const MODELS = [
      { id: 'plant-disease-detection-z9xot/2', name: 'Object Detection (YOLOv8)', type: 'detection', forPlants: 'all' },
      { id: 'rice-disease-detection-zwaa8/4', name: 'Rice Disease Detection (YOLOv8s)', type: 'detection', forPlants: ['rice'] },
      { id: 'wheat-disease-detection-zsn0p/1', name: 'Wheat Disease (100% Accuracy)', type: 'classification', forPlants: ['wheat'] },
      { id: 'chili-plant/2', name: 'Chili Plant Disease (81% mAP)', type: 'detection', forPlants: ['chili', 'pepper'] },
      { id: 'potato-disease-balnv/2', name: 'Potato Disease (98.8% mAP)', type: 'detection', forPlants: ['potato'] },
      { id: 'tomato-disease-k8es2/2', name: 'Tomato Disease (92.3% mAP)', type: 'detection', forPlants: ['tomato'] },
      { id: 'eggplant-fruit-disease-detection/21', name: 'Eggplant Disease (47.8% mAP)', type: 'detection', forPlants: ['eggplant', 'brinjal'] }
    ];
    
    // Plant types available for selection
    const PLANT_TYPES = [
      { id: 'all', name: 'All Plants (General)', icon: 'ЁЯМ┐', models: 7, description: 'Use all 7 models for comprehensive analysis' },
      { id: 'rice', name: 'Rice', icon: 'ЁЯМ╛', models: 2, description: 'General model + Rice specialist' },
      { id: 'wheat', name: 'Wheat', icon: 'ЁЯМ╛', models: 2, description: 'General model + Wheat specialist' },
      { id: 'chili', name: 'Chili/Pepper', icon: 'ЁЯМ╢я╕П', models: 2, description: 'General model + Chili specialist' },
      { id: 'potato', name: 'Potato', icon: 'ЁЯеФ', models: 2, description: 'General model + Potato specialist' },
      { id: 'tomato', name: 'Tomato', icon: 'ЁЯНЕ', models: 2, description: 'General model + Tomato specialist' },
      { id: 'eggplant', name: 'Eggplant/Brinjal', icon: 'ЁЯНЖ', models: 2, description: 'General model + Eggplant specialist' }
    ];
    
    let selectedPlantType = 'all'; // Default to all plants
    
    // Disease remedies database
    const REMEDIES = {
      // Enhanced with specific medicine names, brands, and dosages
      'bacterial spot': 'ЁЯФ╣ Organic: Copper hydroxide (Kocide 3000) 2-3g/L, Streptomycin sulfate 200ppm. ЁЯФ╣ Chemical: Copper oxychloride 50% WP 3g/L water, Kasugamycin 3% SL 2ml/L. Spray every 5-7 days.',
      'early blight': 'ЁЯФ╣ Organic: Neem oil spray 5ml/L, Bacillus subtilis. ЁЯФ╣ Chemical: Chlorothalonil 500g/L (Bravo) 2g/L, Mancozeb 75% WP (Dithane M-45) 2g/L, Azoxystrobin (Quadris) 1ml/L. Spray every 7-10 days.',
      'late blight': 'ЁЯФ╣ Organic: Copper sulfate, Bordeaux mixture 1%. ЁЯФ╣ Chemical: Metalaxyl + Mancozeb (Ridomil Gold MZ) 2.5g/L, Cymoxanil + Mancozeb (Curzate M) 2g/L, Dimethomorph (Forum) 1ml/L. Apply immediately.',
      'leaf mold': 'ЁЯФ╣ Organic: Baking soda 5g/L, potassium bicarbonate. ЁЯФ╣ Chemical: Chlorothalonil (Bravo 500SC) 1-2ml/L, Difenoconazole (Score 25EC) 0.5ml/L. Spray weekly.',
      'septoria leaf spot': 'ЁЯФ╣ Organic: Copper fungicide, garlic extract. ЁЯФ╣ Chemical: Chlorothalonil 2g/L, Mancozeb 75% WP 2g/L, Azoxystrobin + Difenoconazole (Amistar Top) 1ml/L. Apply at first sign.',
      'spider mites': 'ЁЯФ╣ Organic: Neem oil (Azadirachtin 1%) 5ml/L, insecticidal soap. ЁЯФ╣ Chemical: Abamectin (Vertimec 1.8% EC) 0.5-1ml/L, Spiromesifen (Oberon 240SC) 0.5ml/L. Repeat every 5 days.',
      'target spot': 'ЁЯФ╣ Organic: Neem oil, Trichoderma viride. ЁЯФ╣ Chemical: Chlorothalonil 500g/L 2g/L, Mancozeb + Carbendazim (Saaf) 2g/L, Azoxystrobin 1ml/L. Spray every 10 days.',
      'mosaic virus': 'ЁЯФ╣ No cure available. ЁЯФ╣ Control vectors: Imidacloprid 17.8% SL (Confidor) 0.5ml/L, Acetamiprid (Mospilan 20SP) 0.3g/L for aphids. Remove infected plants immediately.',
      'yellow leaf curl': 'ЁЯФ╣ Control whiteflies: Imidacloprid (Confidor 200SL) 0.5ml/L, Thiamethoxam (Actara 25WG) 0.3g/L, Buprofezin (Applaud 25WP) 1g/L. Spray every 5-7 days.',
      'powdery mildew': 'ЁЯФ╣ Organic: Sulfur 80% WP (Sulphex) 2g/L, potassium bicarbonate, milk spray 1:9. ЁЯФ╣ Chemical: Hexaconazole (Contaf 5EC) 1ml/L, Tebuconazole (Folicur 250EC) 0.5ml/L. Spray weekly.',
      'leaf curl': 'ЁЯФ╣ Organic: Neem oil 5ml/L. ЁЯФ╣ Chemical: Carbendazim 50% WP (Bavistin) 1g/L, Mancozeb 2g/L. ЁЯФ╣ Nutrient spray: NPK 19:19:19 foliar 5g/L.',
      'rust': 'ЁЯФ╣ Organic: Sulfur 80% WP 2g/L, copper oxychloride. ЁЯФ╣ Chemical: Propiconazole (Tilt 25EC) 1ml/L, Triadimefon (Bayleton 25WP) 0.5g/L, Mancozeb 2g/L. Spray every 7-10 days.',
      'anthracnose': 'ЁЯФ╣ Organic: Copper fungicide, Trichoderma viride. ЁЯФ╣ Chemical: Carbendazim 50% WP 1g/L, Thiophanate-methyl (Topsin-M 70WP) 1g/L, Azoxystrobin + Difenoconazole 1ml/L.',
      'blight': 'ЁЯФ╣ Organic: Bordeaux mixture 1%, copper sulfate. ЁЯФ╣ Chemical: Metalaxyl + Mancozeb (Ridomil Gold MZ) 2.5g/L, Fosetyl-Al (Aliette 80WP) 3g/L. Spray every 10 days.',
      'scab': 'ЁЯФ╣ Organic: Sulfur 80% WP 2g/L. ЁЯФ╣ Chemical: Captan 50% WP 2g/L, Dodine (Syllit 400SC) 1.5ml/L, Myclobutanil (Rally 40WP) 0.5ml/L. Start at bud break.',
      'wilt': 'ЁЯФ╣ Soil drench: Carbendazim 50% WP 2g/L, Metalaxyl 35% WS 1g/L. ЁЯФ╣ Biocontrol: Trichoderma harzianum 5g/L, Pseudomonas fluorescens. Apply via drip irrigation.',
      'downy mildew': 'ЁЯФ╣ Organic: Copper fungicide, Bacillus subtilis. ЁЯФ╣ Chemical: Metalaxyl (Ridomil 35SD) 2g/L, Cymoxanil + Mancozeb 2.5g/L, Fosetyl-Al 3g/L. Apply weekly.',
      'alternaria': 'ЁЯФ╣ Organic: Neem extract, Trichoderma. ЁЯФ╣ Chemical: Mancozeb 75% WP 2g/L, Iprodione (Rovral 50WP) 2ml/L, Difenoconazole 1ml/L. Rotate fungicides.',
      'fusarium': 'ЁЯФ╣ Soil treatment: Carbendazim 2g/L drench, Metalaxyl 1g/L. ЁЯФ╣ Seed treatment: Thiram 75% WS 3g/kg seed. ЁЯФ╣ Biocontrol: Trichoderma viride 5g/L.',
      
      // Additional vegetable crop diseases
      'damping off': 'ЁЯФ╣ Seed treatment: Thiram 75% WS 2g/kg seed, Captan 50% WP 2g/kg. ЁЯФ╣ Soil drench: Metalaxyl 1g/L, Copper oxychloride 2g/L. Pre-planting treatment recommended.',
      'fruit rot': 'ЁЯФ╣ Organic: Copper fungicide, Trichoderma. ЁЯФ╣ Chemical: Carbendazim 1g/L, Thiophanate-methyl 1g/L. Spray at fruit set and repeat every 10 days.',
      'gray mold': 'ЁЯФ╣ Organic: Potassium bicarbonate 5g/L. ЁЯФ╣ Chemical: Iprodione (Rovral) 2g/L, Pyrimethanil (Scala 400SC) 1ml/L. Spray at flowering and fruit set.',
      'stem rot': 'ЁЯФ╣ Soil drench: Carbendazim 2g/L, Metalaxyl 1g/L. ЁЯФ╣ Foliar: Copper oxychloride 3g/L. Remove infected stems and burn. Apply fungicide to wounds.',
      'root rot': 'ЁЯФ╣ Soil treatment: Metalaxyl + Mancozeb 2.5g/L drench, Fosetyl-Al 3g/L. ЁЯФ╣ Biocontrol: Trichoderma harzianum + Pseudomonas 10g/L soil application.',
      'collar rot': 'ЁЯФ╣ Soil drench: Carbendazim 2g/L + Copper oxychloride 2g/L. ЁЯФ╣ Stem paint: Bordeaux paste at collar region. Apply preventively before monsoon.',
      'black spot': 'ЁЯФ╣ Organic: Neem oil 5ml/L, Copper fungicide. ЁЯФ╣ Chemical: Mancozeb 2g/L, Difenoconazole 0.5ml/L, Chlorothalonil 2g/L. Spray every 7-10 days.',
      'brown spot': 'ЁЯФ╣ Organic: Copper sulfate, Neem extract. ЁЯФ╣ Chemical: Mancozeb 75% WP 2g/L, Carbendazim 1g/L, Tricyclazole (Beam 75WP) 0.6g/L. For rice, spray at tillering.',
      'bacterial wilt': 'ЁЯФ╣ Soil drench: Streptomycin 500ppm, Copper oxychloride 3g/L. ЁЯФ╣ Prevention: Bleaching powder 50g/sq.m. Remove and burn infected plants immediately.',
      'cercospora leaf spot': 'ЁЯФ╣ Organic: Copper fungicide. ЁЯФ╣ Chemical: Mancozeb 2g/L, Carbendazim 1g/L, Tebuconazole 0.5ml/L. Spray at 15-day intervals starting 45 days after planting.',
      'sooty mold': 'ЁЯФ╣ Control sap-sucking insects: Imidacloprid 0.5ml/L, Dimethoate 40% EC 2ml/L. ЁЯФ╣ Wash leaves with soap solution. Improve air circulation.',
      'leaf blight': 'ЁЯФ╣ Organic: Bordeaux mixture 1%, Neem oil. ЁЯФ╣ Chemical: Mancozeb 2g/L, Chlorothalonil 2g/L, Propiconazole 1ml/L. Spray at first appearance of symptoms.',
      'southern blight': 'ЁЯФ╣ Soil treatment: Carbendazim 2g/L drench, Pentachloronitrobenzene (PCNB 75% WP) 3g/L. Deep plowing and solarization recommended.',
      'verticillium wilt': 'ЁЯФ╣ Soil fumigation: Metam sodium. ЁЯФ╣ Resistant varieties recommended. ЁЯФ╣ Soil amendment: Trichoderma + organic matter. No effective chemical cure.',
      'club root': 'ЁЯФ╣ Soil pH adjustment: Apply lime 200g/sq.m. ЁЯФ╣ Seed treatment: Thiram 2g/kg. ЁЯФ╣ Soil drench: Carbendazim 2g/L. Crop rotation for 4-5 years.',
      'black rot': 'ЁЯФ╣ Organic: Copper hydroxide 3g/L. ЁЯФ╣ Chemical: Streptomycin 200ppm, Copper oxychloride 3g/L. Seed treatment with hot water (50┬░C, 30 min).',
      'white rust': 'ЁЯФ╣ Organic: Sulfur 80% WP 2g/L. ЁЯФ╣ Chemical: Metalaxyl 2g/L, Mancozeb 2g/L, Ridomil Gold 2.5g/L. Spray at early vegetative stage.',
      'purple blotch': 'ЁЯФ╣ Organic: Neem oil, Copper fungicide. ЁЯФ╣ Chemical: Mancozeb 2g/L, Chlorothalonil 2g/L, Hexaconazole 1ml/L. For onion/garlic, spray every 7 days.',
      'soft rot': 'ЁЯФ╣ Prevention: Streptocycline 0.1g/L spray. ЁЯФ╣ Post-harvest: Dip in Copper oxychloride 2g/L. Ensure proper drainage and avoid injuries.',
      'cucumber mosaic': 'ЁЯФ╣ Control aphids: Imidacloprid 0.5ml/L, Acetamiprid 0.3g/L. ЁЯФ╣ Remove infected plants. Use reflective mulch. Plant virus-resistant varieties.',
      'gummy stem blight': 'ЁЯФ╣ Seed treatment: Thiram 2g/kg. ЁЯФ╣ Foliar: Carbendazim 1g/L, Thiophanate-methyl 1g/L, Azoxystrobin 1ml/L. Rotate with non-cucurbit crops.',
      'angular leaf spot': 'ЁЯФ╣ Organic: Copper fungicide. ЁЯФ╣ Chemical: Copper oxychloride 3g/L, Streptomycin 200ppm. Spray weekly. Use disease-free seeds.',
      'bacterial canker': 'ЁЯФ╣ Seed treatment: Hot water (56┬░C, 30 min). ЁЯФ╣ Spray: Streptomycin 200ppm, Copper oxychloride 3g/L. Remove infected plants.',
      'aphids': 'ЁЯФ╣ Organic: Neem oil 5ml/L, insecticidal soap. ЁЯФ╣ Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Dimethoate 2ml/L. Spray early morning.',
      'whitefly': 'ЁЯФ╣ Organic: Neem oil, yellow sticky traps. ЁЯФ╣ Chemical: Imidacloprid 0.5ml/L, Buprofezin 1g/L, Spiromesifen 0.5ml/L. Spray undersides of leaves.',
      'thrips': 'ЁЯФ╣ Organic: Neem oil 5ml/L, Spinosad (Tracer 45SC) 0.3ml/L. ЁЯФ╣ Chemical: Fipronil (Regent 5SC) 2ml/L, Dimethoate 2ml/L. Spray at evening.',
      'fruit borer': 'ЁЯФ╣ Organic: Neem oil, Bacillus thuringiensis (Bt) 1g/L. ЁЯФ╣ Chemical: Chlorantraniliprole (Coragen 20SC) 0.3ml/L, Flubendiamide (Fame 480SC) 0.5ml/L.',
      'leaf miner': 'ЁЯФ╣ Organic: Neem oil, yellow sticky traps. ЁЯФ╣ Chemical: Abamectin 0.5ml/L, Cyromazine (Trigard 75WP) 0.4g/L. Remove and destroy affected leaves.',
      'stem borer': 'ЁЯФ╣ Organic: Neem cake soil application 100g/plant. ЁЯФ╣ Chemical: Chlorpyrifos 20% EC 2ml/L, Cartap hydrochloride (Padan 50SP) 1g/L. Spray at whorl stage.',
      'cutworm': 'ЁЯФ╣ Organic: Neem cake, wood ash around stem. ЁЯФ╣ Chemical: Chlorpyrifos 20% EC 2ml/L soil drench, Quinalphos 25% EC 2ml/L. Apply at evening.',
      'nematodes': 'ЁЯФ╣ Organic: Neem cake 100g/sq.m, Paecilomyces lilacinus. ЁЯФ╣ Chemical: Carbofuran 3% CG 15kg/hectare, Phorate 10% CG 10kg/hectare. Apply before planting.',
      
      // General crop maintenance
      'walnut': 'No disease detected. ЁЯФ╣ Preventive: Bordeaux mixture 1%, Copper fungicide 3g/L. ЁЯФ╣ Fertilizer: NPK 10:10:10 at 50g/plant monthly.',
      'tomato': 'No disease detected. ЁЯФ╣ Preventive spray: Mancozeb 2g/L or Copper oxychloride 3g/L every 15 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L weekly.',
      'pepper': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L every 10 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L + Calcium nitrate 2g/L weekly.',
      'cucumber': 'No disease detected. ЁЯФ╣ Preventive: Carbendazim 1g/L weekly. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L + Boron 0.5g/L biweekly.',
      'cabbage': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L + Chlorpyrifos 2ml/L every 10 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L.',
      'potato': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L every 10 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L + Zinc sulfate 2g/L.',
      'onion': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L + Carbendazim 1g/L every 15 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L.',
      'beans': 'No disease detected. ЁЯФ╣ Preventive: Carbendazim 1g/L at flowering. ЁЯФ╣ Fertilizer: NPK 19:19:19 3g/L + Rhizobium inoculation.',
      'eggplant': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L + Imidacloprid 0.5ml/L every 10 days. ЁЯФ╣ Fertilizer: NPK 19:19:19 5g/L.',
      'banana': 'No disease detected. ЁЯФ╣ Preventive: Mancozeb 2g/L monthly. ЁЯФ╣ Pseudostem injection: Carbendazim 1g/L. ЁЯФ╣ Fertilizer: NPK 19:19:19 10g/L.',
      'rot': 'ЁЯФ╣ Soil drench: Metalaxyl 35% WS 1g/L, Fosetyl-Al 3g/L. ЁЯФ╣ Foliar: Copper oxychloride 3g/L. ЁЯФ╣ Biocontrol: Trichoderma viride soil application.',
      'canker': 'ЁЯФ╣ Spray: Copper oxychloride 50% WP 3g/L, Bordeaux mixture 1%. ЁЯФ╣ Wound paste: Carbendazim + Copper paste. Prune 15cm below infection.',
      
      // EGGPLANT/BRINJAL DISEASES
      'eggplant fruit rot': 'ЁЯФ╣ Organic: Neem oil 5ml/L. ЁЯФ╣ Chemical: Carbendazim 1g/L + Mancozeb 2g/L. Spray at fruit set and every 10 days.',
      'eggplant phomopsis blight': 'ЁЯФ╣ Seed treatment: Thiram 2g/kg. ЁЯФ╣ Spray: Mancozeb 2g/L + Carbendazim 1g/L. Rotate with Copper oxychloride 3g/L.',
      'eggplant little leaf': 'ЁЯФ╣ Control leafhoppers: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L. Remove infected plants. Use virus-free seedlings.',
      'eggplant bacterial wilt': 'ЁЯФ╣ Soil drench: Streptomycin 500ppm + Copper oxychloride 2g/L. Remove and burn infected plants immediately.',
      'eggplant damping off': 'ЁЯФ╣ Seed treatment: Thiram 2g/kg. ЁЯФ╣ Soil drench: Metalaxyl 1g/L + Copper oxychloride 2g/L before planting.',
      'eggplant cercospora leaf spot': 'ЁЯФ╣ Mancozeb 75% WP 2g/L, Carbendazim 1g/L, Chlorothalonil 2g/L. Spray every 10-12 days.',
      'eggplant anthracnose': 'ЁЯФ╣ Copper fungicide, Carbendazim 1g/L + Mancozeb 2g/L. Apply at first flower and fruit set.',
      'brinjal fruit borer': 'ЁЯФ╣ Organic: Neem oil 5ml/L, Bt (Bacillus thuringiensis) 1g/L. ЁЯФ╣ Chemical: Chlorantraniliprole 0.3ml/L, Spinosad 0.3ml/L. Spray at evening.',
      'brinjal shoot borer': 'ЁЯФ╣ Remove and destroy infested shoots. ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L every 10 days.',
      'brinjal aphids': 'ЁЯФ╣ Organic: Neem oil 5ml/L, soap spray. ЁЯФ╣ Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L. Spray undersides.',
      'brinjal whitefly': 'ЁЯФ╣ Yellow sticky traps. ЁЯФ╣ Imidacloprid 0.5ml/L, Buprofezin 1g/L, Spiromesifen 0.5ml/L. Spray every 7 days.',
      'brinjal jassids': 'ЁЯФ╣ Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Acetamiprid 0.3g/L. Spray at tender leaf stage.',
      
      // WHEAT DISEASES
      'wheat rust': 'ЁЯФ╣ Organic: Sulfur 80% WP 2g/L. ЁЯФ╣ Chemical: Propiconazole (Tilt 25EC) 1ml/L, Tebuconazole (Folicur 250EC) 0.5ml/L, Mancozeb 2g/L. Spray at first sign.',
      'wheat brown rust': 'ЁЯФ╣ Propiconazole 1ml/L, Tebuconazole 0.5ml/L, Triadimefon (Bayleton 25WP) 0.5g/L. Spray at tillering and boot stage.',
      'wheat yellow rust': 'ЁЯФ╣ Propiconazole 1ml/L, Mancozeb 2g/L, Zineb 2g/L. Spray preventively before disease appearance. Repeat every 15 days.',
      'wheat black rust': 'ЁЯФ╣ Mancozeb 75% WP 2g/L, Propiconazole 1ml/L. Spray at boot stage and milk stage. Use resistant varieties.',
      'wheat powdery mildew': 'ЁЯФ╣ Organic: Sulfur 80% WP 2g/L. ЁЯФ╣ Chemical: Hexaconazole (Contaf 5EC) 1ml/L, Tebuconazole 0.5ml/L, Propiconazole 1ml/L. Spray at early jointing.',
      'wheat leaf blight': 'ЁЯФ╣ Mancozeb 2g/L, Carbendazim 1g/L, Chlorothalonil 2g/L. Spray at tillering, boot, and heading stages.',
      'wheat septoria leaf spot': 'ЁЯФ╣ Chlorothalonil 2g/L, Mancozeb 2g/L, Propiconazole 1ml/L. Spray at flag leaf emergence and heading.',
      'fusarium head blight': 'ЁЯФ╣ Tebuconazole 0.5ml/L, Propiconazole 1ml/L, Carbendazim 1g/L. Spray at early flowering. Repeat after 7 days.',
      'wheat tan spot': 'ЁЯФ╣ Propiconazole 1ml/L, Tebuconazole 0.5ml/L, Azoxystrobin 1ml/L. Spray at tillering and flag leaf stage.',
      'wheat loose smut': 'ЁЯФ╣ Seed treatment: Vitavax (Carboxin 75% WP) 2g/kg seed, Tebuconazole 2ml/kg seed. Hot water treatment 49┬░C for 3 hours.',
      'wheat karnal bunt': 'ЁЯФ╣ Seed treatment: Tebuconazole 2ml/kg seed. ЁЯФ╣ Foliar: Propiconazole 1ml/L at boot stage and 50% flowering. Burn infected grains.',
      'wheat flag smut': 'ЁЯФ╣ Seed treatment: Carboxin 2g/kg, Tebuconazole 2ml/kg. Remove and burn infected plants before heading.',
      'wheat stem rust': 'ЁЯФ╣ Propiconazole 1ml/L + Mancozeb 2g/L. Spray at boot and heading stage. Use resistant varieties like HD2967, WH1105.',
      'wheat leaf rust': 'ЁЯФ╣ Mancozeb 2g/L, Propiconazole 1ml/L. Spray at tillering and flag leaf stage. Spray every 15 days if disease persists.',
      'wheat root rot': 'ЁЯФ╣ Seed treatment: Carbendazim 2g/kg, Metalaxyl 2ml/kg. ЁЯФ╣ Soil drench: Carbendazim 2g/L at sowing.',
      'wheat blast': 'ЁЯФ╣ Tricyclazole (Beam 75WP) 0.6g/L, Tebuconazole 0.5ml/L. Spray at heading and repeat after 7 days. Emergency disease.',
      'wheat aphids': 'ЁЯФ╣ Organic: Neem oil 5ml/L. ЁЯФ╣ Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Dimethoate 40% EC 2ml/L. Spray at tillering.',
      'wheat stem borer': 'ЁЯФ╣ Chlorpyrifos 20% EC 2ml/L, Quinalphos 25% EC 2ml/L. Spray at early vegetative stage. Remove and destroy stubbles.',
      'wheat termites': 'ЁЯФ╣ Chlorpyrifos 20% EC 4ml/L soil application before sowing. Treat seed with Imidacloprid 2ml/kg seed.',
      'wheat army worm': 'ЁЯФ╣ Chlorpyrifos 2ml/L, Quinalphos 2ml/L, Malathion 50% EC 2ml/L. Spray in evening. Mechanical collection in early morning.',
      
      // FRUIT CROPS (100+ diseases)
      'citrus canker': 'ЁЯФ╣ Copper oxychloride 3g/L + Streptocycline 0.1g/L. Spray every 15 days. Prune infected branches 30cm below.',
      'citrus greening': 'ЁЯФ╣ Control psyllids: Imidacloprid 0.5ml/L. ЁЯФ╣ Zinc + Manganese spray 5g/L foliar. No cure - remove infected trees.',
      'fire blight': 'ЁЯФ╣ Streptomycin 200ppm at 5% bloom. Copper 3g/L. Prune 30cm below infection. Disinfect tools with 70% alcohol.',
      'apple scab': 'ЁЯФ╣ Myclobutanil 0.5ml/L, Captan 2g/L. Start at green tip. Spray every 7-10 days until petal fall.',
      'mango anthracnose': 'ЁЯФ╣ Carbendazim 1g/L, Azoxystrobin 1ml/L at flowering. Post-harvest: Hot water 52┬░C, 5min.',
      'mango malformation': 'ЁЯФ╣ NAA 200ppm at panicle emergence. Prune affected panicles. Carbendazim 1g/L before flowering.',
      'grape downy mildew': 'ЁЯФ╣ Metalaxyl 2g/L, Cymoxanil + Mancozeb 2.5g/L. Spray every 10 days from flowering.',
      'banana bunchy top': 'ЁЯФ╣ Control aphids: Imidacloprid 0.5ml/L. Remove and destroy infected plants. Use virus-free suckers.',
      'papaya ring spot': 'ЁЯФ╣ Control aphids: Imidacloprid 0.5ml/L. Remove infected plants. Reflective mulch. No cure available.',
      'pomegranate bacterial blight': 'ЁЯФ╣ Copper oxychloride 3g/L + Streptocycline 0.1g/L every 10 days during monsoon.',
      
      // CEREAL CROPS (80+ diseases)
      'rice blast': 'ЁЯФ╣ Tricyclazole (Beam 75WP) 0.6g/L, Isoprothiolane 1.5ml/L. Spray at tillering and panicle initiation.',
      'rice sheath blight': 'ЁЯФ╣ Hexaconazole 2ml/L, Validamycin 2ml/L at maximum tillering. Spray lower portion of plant.',
      'rice bacterial blight': 'ЁЯФ╣ Copper oxychloride 3g/L + Streptocycline 0.1g/L. Seed treatment with Streptocycline.',
      'rice bacterial leaf blight': 'ЁЯФ╣ Copper oxychloride 3g/L + Streptocycline 0.1g/L. Seed treatment with Streptocycline.',
      'rice tungro': 'ЁЯФ╣ Control leafhoppers: Imidacloprid 0.5ml/L, Fipronil 2ml/L. Remove infected plants. Resistant varieties.',
      'rice stem borer': 'ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Cartap hydrochloride 1g/L at dead heart stage.',
      'rice hispa': 'ЁЯФ╣ Chlorpyrifos 2ml/L, Cartap hydrochloride 1g/L. Spray on leaf surface. Drain water before spraying.',
      'rice sheath rot': 'ЁЯФ╣ Carbendazim 1g/L, Propiconazole 1ml/L at boot stage. Balanced NPK application.',
      'rice leaf folder': 'ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Fipronil 2ml/L. Spray at early infestation stage.',
      'rice false smut': 'ЁЯФ╣ Copper oxychloride 3g/L or Propiconazole 1ml/L at boot stage and heading.',
      'rice neck blast': 'ЁЯФ╣ Tricyclazole 0.6g/L, Azoxystrobin 1ml/L at panicle initiation and heading.',
      'rice sheath blotch': 'ЁЯФ╣ Mancozeb 2g/L, Propiconazole 1ml/L. Spray at tillering and boot stage.',
      'bacterial leaf streak': 'ЁЯФ╣ Copper oxychloride 3g/L. Avoid excess nitrogen. Use resistant varieties.',
      'wheat rust': 'ЁЯФ╣ Propiconazole 1ml/L, Tebuconazole 0.5ml/L at first rust appearance. Repeat after 15 days.',
      'wheat powdery mildew': 'ЁЯФ╣ Hexaconazole 1ml/L, Sulfur 2g/L at tillering and boot stage.',
      'maize downy mildew': 'ЁЯФ╣ Seed treatment: Metalaxyl 6g/kg. ЁЯФ╣ Foliar: Metalaxyl 2g/L at 15, 25 days.',
      'maize fall armyworm': 'ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Emamectin benzoate 0.4g/L at whorl stage.',
      
      // PULSE CROPS (60+ diseases)
      'chickpea wilt': 'ЁЯФ╣ Seed: Carbendazim 2g/kg + Trichoderma 4g/kg. Soil drench: Carbendazim 2g/L. Resistant varieties.',
      'pigeon pea wilt': 'ЁЯФ╣ Seed: Carbendazim 2g/kg + Trichoderma. Soil drench 2g/L at 30 days. Deep summer plowing.',
      'soybean rust': 'ЁЯФ╣ Tebuconazole 0.5ml/L, Trifloxystrobin + Tebuconazole 0.5ml/L. Repeat after 15 days.',
      'groundnut tikka': 'ЁЯФ╣ Mancozeb 2g/L, Chlorothalonil 2g/L at 30, 45, 60 days after sowing.',
      
      // VEGETABLES EXPANDED (120+ diseases)
      'tomato leaf curl': 'ЁЯФ╣ Control whiteflies: Imidacloprid 0.5ml/L, Buprofezin 1g/L. Reflective mulch. Remove infected plants.',
      'tomato blossom end rot': 'ЁЯФ╣ Calcium nitrate 5g/L foliar at fruit set. Regular irrigation. Avoid excess nitrogen.',
      'potato late blight': 'ЁЯФ╣ Metalaxyl + Mancozeb 2.5g/L every 7-10 days. Destroy infected plants immediately.',
      'brinjal fruit borer': 'ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L. Bt 1g/L organic.',
      'chili anthracnose': 'ЁЯФ╣ Seed: Carbendazim 2g/kg. Foliar: Carbendazim 1g/L, Azoxystrobin 1ml/L at flowering.',
      'chili leaf curl': 'ЁЯФ╣ Control whiteflies: Imidacloprid 0.5ml/L, Buprofezin 1g/L. Reflective mulch. Remove infected plants immediately.',
      'chili bacterial wilt': 'ЁЯФ╣ Soil drench: Streptomycin 500ppm, Copper oxychloride 3g/L. Remove and burn infected plants. Crop rotation 3-4 years.',
      'chili powdery mildew': 'ЁЯФ╣ Sulfur 80% WP 2g/L, Hexaconazole 1ml/L. Spray at first sign. Repeat every 7-10 days.',
      'chili mosaic virus': 'ЁЯФ╣ Control aphids: Imidacloprid 0.5ml/L. Remove infected plants. Use virus-free seeds. Reflective mulch.',
      'chili thrips': 'ЁЯФ╣ Fipronil 2ml/L, Dimethoate 2ml/L. Spray undersides of leaves. Blue sticky traps.',
      'chili fruit borer': 'ЁЯФ╣ Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L. Bt spray 1g/L organic option.',
      'potato early blight': 'ЁЯФ╣ Mancozeb 2g/L, Chlorothalonil 2g/L. Start at first symptoms. Spray every 7-10 days.',
      'potato black scurf': 'ЁЯФ╣ Seed treatment: Thiram 2.5g/kg. Foliar: Copper oxychloride 3g/L. Improve drainage.',
      'potato common scab': 'ЁЯФ╣ Soil pH 5.0-5.2. Sulfur 50g/sq.m before planting. Maintain uniform moisture. Avoid excess lime.',
      'okra yellow vein mosaic': 'ЁЯФ╣ Control whiteflies: Imidacloprid 0.5ml/L. Remove infected plants. Resistant varieties.',
      'cabbage diamondback moth': 'ЁЯФ╣ Bt 1g/L, Chlorantraniliprole 0.3ml/L, Emamectin benzoate 0.4g/L.',
      'onion purple blotch': 'ЁЯФ╣ Mancozeb 2g/L, Hexaconazole 1ml/L every 10 days. Crop rotation.',
      
      // NUTRIENT DEFICIENCIES (40+ conditions)
      'nitrogen deficiency': 'ЁЯФ╣ Urea 10g/L foliar or Ammonium sulfate 15g/L. Soil: Urea 100-150kg/hectare. Yellowing of older leaves.',
      'phosphorus deficiency': 'ЁЯФ╣ DAP 10g/L foliar, SSP 200kg/hectare soil. Purple/dark green leaves, stunted growth.',
      'potassium deficiency': 'ЁЯФ╣ MOP/SOP 10g/L foliar. Soil: 100kg/hectare. Leaf margin burn, scorching.',
      'calcium deficiency': 'ЁЯФ╣ Calcium nitrate/chloride 5g/L foliar. Gypsum 500kg/hectare. Blossom end rot, tip burn.',
      'magnesium deficiency': 'ЁЯФ╣ Magnesium sulfate (Epsom salt) 5g/L foliar. Dolomite 300kg/hectare. Interveinal chlorosis.',
      'iron deficiency': 'ЁЯФ╣ Ferrous sulfate 3g/L + Citric acid 1g/L or Fe-EDTA 2g/L foliar. Young leaf chlorosis.',
      'zinc deficiency': 'ЁЯФ╣ Zinc sulfate 5g/L + Lime 2.5g/L foliar. Soil: 25kg/hectare. Little leaf, rosetting.',
      'boron deficiency': 'ЁЯФ╣ Borax 1g/L foliar. Soil: 10-15kg/hectare. Hollow stem, flower abortion.',
      
      // ENVIRONMENTAL STRESS (30+ conditions)
      'heat stress': 'ЁЯФ╣ Kaolin clay 30g/L for sun protection. Cool water spray. Shade net. Mulching.',
      'cold stress': 'ЁЯФ╣ Brassinosteroids 0.1ppm. Cover with plastic. Light irrigation before frost. Potassium 5g/L.',
      'drought stress': 'ЁЯФ╣ Salicylic acid 100ppm foliar. Mulching. Anti-transpirant Kaolin 30g/L. Drip irrigation.',
      'salinity stress': 'ЁЯФ╣ Gypsum 500kg/hectare. Calcium chloride 5g/L foliar. Leaching. Salicylic acid 100ppm.',
      
      'healthy': 'тЬЕ No treatment needed. ЁЯФ╣ Preventive: NPK 19:19:19 at 5g/L every 15 days. ЁЯФ╣ Micronutrients: ZnSO4 + FeSO4 + MnSO4 mix 3g/L monthly. ЁЯФ╣ Bio-stimulant: Seaweed extract 2ml/L monthly.',
      'no detection': 'Unable to detect disease. Ensure proper image quality. If disease visible, consult agricultural expert with leaf sample for proper diagnosis.',
      'default': 'тЪая╕П Consult local agricultural extension. ЁЯФ╣ General spray: Mancozeb 75% WP 2g/L + Copper oxychloride 50% WP 3g/L. ЁЯФ╣ Insect control: Imidacloprid 0.5ml/L. Take leaf sample for lab analysis.'
    };
    
    // ==================== CONTEXT-AWARE ANALYSIS ALGORITHMS ====================
    
    // Sensors/context removed - return neutral context
    function analyzeEnvironmentalContext(sensorData) {
      return {
        riskFactors: [],
        severity: 'low',
        severityScore: 0,
        recommendations: [],
        metrics: {
          moistureRisk: 'normal',
          humidityRisk: 'normal',
          temperatureRisk: 'normal',
          nutrientRisk: 'normal',
          lightRisk: 'normal'
        }
      };
    }
    
    // Simplified severity assessment (visual-only)
    function assessDiseaseSeverity(diseaseName, confidence, envContext) {
      let severity = 'mild';
      let treatmentUrgency = 'routine';
      let spreadRisk = 'low';

      if (confidence >= 90) { severity = 'severe'; treatmentUrgency = 'immediate'; spreadRisk = 'high'; }
      else if (confidence >= 70) { severity = 'moderate'; treatmentUrgency = 'within 24-48 hours'; spreadRisk = 'medium'; }
      else if (confidence >= 50) { severity = 'mild'; treatmentUrgency = 'within 1 week'; spreadRisk = 'low'; }

      return { severity, treatmentUrgency, spreadRisk, criticalityScore: confidence };
    }
    
    // ==================== ANALYTICS & LOGGING SYSTEM ====================
    
    let analyticsData = {
      logs: [],
      charts: {
        disease: null,
        confidence: null,
        environment: null,
        severity: null,
        timeline: null,
        modelPrecision: null
      },
      modelFeedback: {} // Stores feedback for each model: { modelName: { correct: 0, wrong: 0 } }
    };
    
    // Initialize model feedback tracking
    function initializeModelFeedback() {
      MODELS.forEach(model => {
        if (!analyticsData.modelFeedback[model.name]) {
          analyticsData.modelFeedback[model.name] = { correct: 0, wrong: 0, total: 0 };
        }
      });
    }
    
    // Record feedback for a specific model and analysis
    function recordModelFeedback(analysisId, modelName, isCorrect) {
      if (!analyticsData.modelFeedback[modelName]) {
        analyticsData.modelFeedback[modelName] = { correct: 0, wrong: 0, total: 0 };
      }
      
      if (isCorrect) {
        analyticsData.modelFeedback[modelName].correct++;
      } else {
        analyticsData.modelFeedback[modelName].wrong++;
      }
      analyticsData.modelFeedback[modelName].total++;
      
      // Update the specific log entry with feedback
      const logEntry = analyticsData.logs.find(log => log.id === analysisId);
      if (logEntry) {
        if (!logEntry.modelFeedbacks) {
          logEntry.modelFeedbacks = {};
        }
        logEntry.modelFeedbacks[modelName] = isCorrect;
      }
      
      saveAnalytics();
      
      // Update chart immediately after recording feedback
      console.log('ЁЯФД Updating chart with new feedback data:', analyticsData.modelFeedback);
      console.log('ЁЯУК Total models with feedback:', Object.keys(analyticsData.modelFeedback).length);
      updateModelPrecisionChart();
      
      console.log('Feedback recorded for', modelName, ':', isCorrect ? 'Correct' : 'Wrong');
      console.log('Updated stats:', analyticsData.modelFeedback[modelName]);
    }
    
    // Reset all model feedback data
    function resetModelFeedback() {
      if (!confirm('тЪая╕П Are you sure you want to reset all model feedback data?\n\nThis will:\nтАв Clear all precision statistics\nтАв Remove the chart data\nтАв Delete feedback from Firebase\n\nThis action cannot be undone.')) {
        return;
      }
      
      console.log('ЁЯЧСя╕П Resetting all model feedback data...');
      
      // Clear local data
      analyticsData.modelFeedback = {};
      
      // Clear from Firebase
      if (firebaseReady && firebaseEnabled && db) {
        db.collection('modelFeedback').doc('current').delete().then(() => {
          console.log('тЬЕ Model feedback deleted from Firebase');
          alert('тЬЕ All model feedback has been reset successfully!');
        }).catch(err => {
          console.error('тЭМ Failed to delete feedback from Firebase:', err);
          alert('тЪая╕П Feedback cleared locally but Firebase deletion failed: ' + err.message);
        });
      }
      
      // Clear from localStorage
      const stored = localStorage.getItem('diseaseAnalytics');
      if (stored) {
        try {
          const data = JSON.parse(stored);
          data.modelFeedback = {};
          localStorage.setItem('diseaseAnalytics', JSON.stringify(data));
          console.log('тЬЕ Model feedback cleared from localStorage');
        } catch (e) {
          console.error('Failed to clear feedback from localStorage:', e);
        }
      }
      
      // Update chart to show empty state
      updateModelPrecisionChart();
      
      console.log('тЬЕ Model feedback reset complete');
    }
    
    // Enhanced log entry with complete data
    function createCompleteLogEntry(results, sensorData, envContext, capturedImageBase64) {
      const timestamp = new Date().toISOString();
      const diseases = [];
      const allModelResults = [];
      
      results.forEach(r => {
        // Store complete model result
        const modelResult = {
          modelName: r.name,
          modelType: r.type,
          error: r.error || null,
          rawData: r.data
        };
        
        if (r.error) {
          allModelResults.push(modelResult);
          return;
        }
        
        let disease = 'Healthy';
        let confidence = 0;
        
        if (r.type === 'detection' && r.data.predictions && r.data.predictions.length > 0) {
          const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
          disease = top.class;
          confidence = top.confidence * 100;
          modelResult.detectedClass = disease;
          modelResult.confidence = confidence;
          modelResult.allPredictions = r.data.predictions;
        } else if (r.type === 'classification' && (r.data.top || r.data.predicted_classes)) {
          disease = r.data.top || r.data.predicted_classes[0];
          confidence = (r.data.confidence || 0) * 100;
          modelResult.detectedClass = disease;
          modelResult.confidence = confidence;
        }
        
        allModelResults.push(modelResult);
        
        if (disease !== 'Healthy' && confidence > 0) {
          const severityAssessment = assessDiseaseSeverity(disease, confidence, envContext);
          diseases.push({
            name: disease,
            confidence: confidence,
            model: r.name,
            severity: severityAssessment.severity,
            spreadRisk: severityAssessment.spreadRisk,
            urgency: severityAssessment.treatmentUrgency,
            treatment: getRemedy(disease),
            criticalityScore: severityAssessment.criticalityScore
          });
        }
      });
      
      return {
        id: 'log_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
        timestamp,
        timestampReadable: new Date(timestamp).toLocaleString(),
        diseases,
        allModelResults,
        sensorData: sensorData || null,
        environmentalContext: envContext || null,
        primaryDisease: diseases.length > 0 ? diseases[0].name : 'Healthy',
        avgConfidence: diseases.length > 0 ? diseases.reduce((sum, d) => sum + d.confidence, 0) / diseases.length : 0,
        overallSeverity: envContext ? envContext.severity : 'unknown',
        imageBase64: capturedImageBase64 || null,
        deviceInfo: {
          userAgent: navigator.userAgent,
          platform: navigator.platform,
          screenResolution: window.screen.width + 'x' + window.screen.height
        }
      };
    }
    
    // Load analytics from Firebase (primary) with localStorage as fallback cache
    async function loadAnalytics() {
      // Wait for Firebase to be ready
      if (firebaseReadyPromise) {
        try {
          await firebaseReadyPromise;
        } catch (e) {
          console.warn('Firebase authentication failed, using localStorage');
        }
      }
      
      // Try to load from Firebase first
      if (firebaseReady && firebaseEnabled && db) {
        try {
          console.log('ЁЯУе Loading all data from Firebase...');
          
          // Load all logs from Firebase
          const logsSnapshot = await db.collection('diseaseAnalytics')
            .orderBy('timestamp', 'desc')
            .get();
          
          const firebaseLogs = [];
          logsSnapshot.forEach(doc => {
            const logData = doc.data();
            logData.firebaseId = doc.id;
            logData.savedToFirebase = true;
            firebaseLogs.push(logData);
          });
          
          analyticsData.logs = firebaseLogs;
          console.log('тЬЕ Loaded', firebaseLogs.length, 'logs from Firebase');
          
          // Load model feedback from Firebase
          console.log('ЁЯУе Loading model feedback from Firebase...');
          try {
            const feedbackDoc = await db.collection('modelFeedback').doc('current').get();
            console.log('ЁЯУД Feedback document exists:', feedbackDoc.exists);
            
            if (feedbackDoc.exists) {
              const docData = feedbackDoc.data();
              console.log('ЁЯУж Document data:', docData);
              analyticsData.modelFeedback = docData.feedback || {};
              console.log('тЬЕ Loaded model feedback from Firebase');
              console.log('ЁЯУК Model feedback data:', analyticsData.modelFeedback);
              console.log('ЁЯУК Number of models with feedback:', Object.keys(analyticsData.modelFeedback).length);
            } else {
              console.warn('тЪая╕П Model feedback document does not exist in Firebase');
              analyticsData.modelFeedback = {};
            }
          } catch (fbError) {
            console.error('тЭМ Failed to load model feedback (continuing with logs):', fbError);
          }
          
          // Initialize feedback structure to ensure all models exist
          initializeModelFeedback();
          
          // Update dashboard and charts after loading
          updateAnalyticsDashboard();
          updateHistoryPanel();
          updateModelPrecisionChart(); // Explicitly update chart after Firebase load
          
        } catch (e) {
          console.error('Failed to load from Firebase, using localStorage cache:', e);
          loadFromLocalStorageCache();
        }
      } else {
        console.warn('тЪая╕П Firebase not enabled, loading from localStorage cache');
        loadFromLocalStorageCache();
      }
    }
    
    // Fallback: Load from localStorage cache
    function loadFromLocalStorageCache() {
      const stored = localStorage.getItem('diseaseAnalytics');
      if (stored) {
        try {
          const data = JSON.parse(stored);
          // Support old format (array) and new format (object with logs and feedback)
          if (Array.isArray(data)) {
            analyticsData.logs = data;
            analyticsData.modelFeedback = {};
          } else {
            analyticsData.logs = data.logs || [];
            analyticsData.modelFeedback = data.modelFeedback || {};
          }
          console.log('ЁЯУж Loaded', analyticsData.logs.length, 'records from localStorage cache');
          
          // Initialize feedback structure
          initializeModelFeedback();
          
          // Update dashboard and charts after loading from cache
          updateAnalyticsDashboard();
          updateHistoryPanel();
          updateModelPrecisionChart();
        } catch (e) {
          console.error('Failed to load from localStorage:', e);
          analyticsData.logs = [];
          analyticsData.modelFeedback = {};
        }
      }
    }
    
    // Save analytics to Firebase (primary) and localStorage (backup cache only)
    function saveAnalytics() {
      // Save to Firebase as primary storage
      if (firebaseReady && firebaseEnabled && db) {
        // Save all logs to Firebase
        analyticsData.logs.forEach(log => {
          if (!log.savedToFirebase) {
            saveToFirebase(log).then(() => {
              log.savedToFirebase = true;
            }).catch(err => {
              console.error('Failed to save log to Firebase:', err);
            });
          }
        });
        
        // Save model feedback separately (only if there's data)
        const feedbackKeys = Object.keys(analyticsData.modelFeedback);
        if (feedbackKeys.length > 0) {
          console.log('ЁЯТ╛ Saving', feedbackKeys.length, 'model feedback entries to Firebase...');
          console.log('ЁЯУЭ Feedback data to save:', JSON.stringify(analyticsData.modelFeedback));
          
          db.collection('modelFeedback').doc('current').set({
            feedback: analyticsData.modelFeedback,
            lastUpdated: new Date().toISOString(),
            userId: auth.currentUser ? auth.currentUser.uid : 'anonymous'
          }, { merge: true }).then(() => {
            console.log('тЬЕ Model feedback saved to Firebase successfully');
            
            // Verify save by reading back
            db.collection('modelFeedback').doc('current').get().then(doc => {
              if (doc.exists) {
                console.log('тЬЕ Verified - Feedback in Firebase:', Object.keys(doc.data().feedback || {}).length, 'models');
              } else {
                console.error('тЭМ Verification failed - Document does not exist after save!');
              }
            });
          }).catch(err => {
            console.error('тЭМ Failed to save model feedback to Firebase:', err);
          });
        } else {
          console.log('тД╣я╕П No model feedback to save yet');
        }
        
        console.log('тЬЕ All logs saved to Firebase');
      } else {
        console.warn('тЪая╕П Firebase not enabled, using localStorage as fallback');
      }
      
      // Keep minimal cache in localStorage (last 20 records only for offline access)
      try {
        const recentLogs = analyticsData.logs.slice(-20);
        const dataToSave = {
          logs: recentLogs,
          modelFeedback: analyticsData.modelFeedback,
          cache,
          cacheOnly: true
        };
        localStorage.setItem('diseaseAnalytics', JSON.stringify(dataToSave));
        console.log('Cached', recentLogs.length, 'recent records to localStorage');
      } catch (e) {
        console.error('Failed to cache to localStorage:', e);
      }
    }
    
    // Save to Firebase Firestore
    async function saveToFirebase(logEntry) {
      if (!firebaseReady || !firebaseEnabled || !db) {
        log.warn('тЪая╕П Firebase not available, using localStorage only');
        return;
      }
      
      try {
        // Store complete entry without image in Firestore
        const { imageBase64, ...firestoreEntry } = logEntry;
        
        // Add to Firestore without image data
        const docRef = await db.collection('diseaseAnalytics').add({
          ...firestoreEntry,
          uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
          userId: auth.currentUser ? auth.currentUser.uid : 'anonymous'
        });
        
        console.log('тЬЕ Saved to Firebase with ID:', docRef.id);
        console.log('тД╣я╕П Image not stored in Firestore. Logs only.');
        
        return docRef.id;
      } catch (e) {
        console.error('тЭМ Failed to save to Firebase:', e);
        throw e;
      }
    }
    
    // Convert base64 to blob
    function base64ToBlob(base64, contentType) {
      const byteCharacters = atob(base64);
      const byteArrays = [];
      
      for (let offset = 0; offset < byteCharacters.length; offset += 512) {
        const slice = byteCharacters.slice(offset, offset + 512);
        const byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
          byteNumbers[i] = slice.charCodeAt(i);
        }
        const byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
      }
      
      return new Blob(byteArrays, { type: contentType });
    }
    
    // Log analysis result (enhanced with complete data)
    async function logAnalysis(results, sensorData, envContext, imageBase64, analysisId) {
      const logEntry = createCompleteLogEntry(results, sensorData, envContext, imageBase64);
      logEntry.id = analysisId; // Store the analysis ID
      logEntry.modelFeedbacks = {}; // Initialize empty feedback object
      
      analyticsData.logs.push(logEntry);
      saveAnalytics();
      
      // Save to Firebase asynchronously
      if (firebaseReady && firebaseEnabled) {
        saveToFirebase(logEntry).catch(err => {
          console.error('Firebase save failed, data is in localStorage:', err);
        });
      }
      
      updateAnalyticsDashboard();
      updateHistoryPanel();
    }
    
    // Load from Firebase
    async function loadFromFirebase(showAlert = true) {
      // Wait for Firebase to be ready
      if (firebaseReadyPromise) {
        try {
          await firebaseReadyPromise;
        } catch (e) {
          if (showAlert) alert('Firebase not connected. Using local data only.');
          return;
        }
      }
      
      if (!firebaseReady || !firebaseEnabled || !db) {
        if (showAlert) alert('Firebase not connected. Using local data only.');
        return;
      }
      
      try {
        // Get button element if called from UI (event exists)
        const btn = event?.target;
        if (btn) {
          btn.disabled = true;
          btn.textContent = translateText('тП│ Loading...');
        }
        
        const snapshot = await db.collection('diseaseAnalytics')
          .orderBy('timestamp', 'desc')
          .limit(100)
          .get();
        
        const firebaseLogs = [];
        snapshot.forEach(doc => {
          const data = doc.data();
          firebaseLogs.push({ ...data, firebaseId: doc.id });
        });
        
        console.log('тЬЕ Loaded', firebaseLogs.length, 'records from Firebase');
        const withImages = firebaseLogs.filter(log => log.imageBase64).length;
        console.log('ЁЯУ╖ Records with images:', withImages, '/', firebaseLogs.length);
        
        // Merge with local data (remove duplicates by timestamp)
        const merged = [...analyticsData.logs, ...firebaseLogs];
        const unique = merged.filter((log, index, self) =>
          index === self.findIndex(l => l.timestamp === log.timestamp)
        );
        
        analyticsData.logs = unique.sort((a, b) => 
          new Date(a.timestamp) - new Date(b.timestamp)
        );
        
        saveAnalytics();
        updateAnalyticsDashboard();
        updateHistoryPanel();
        
        if (showAlert) alert('Loaded ' + firebaseLogs.length + ' records from Firebase');
        
        if (btn) {
          btn.disabled = false;
          btn.textContent = translateText('ЁЯУе Load');
        }
      } catch (e) {
        console.error('тЭМ Failed to load from Firebase:', e);
        if (showAlert) alert('Failed to load from Firebase: ' + e.message);
        if (event?.target) {
          event.target.disabled = false;
          event.target.textContent = translateText('ЁЯУе Load');
        }
      }
    }
    
    // Load image from Firebase for a specific log entry
    async function loadImageFromFirebase(firebaseId, logId) {
      if (!firebaseReady || !firebaseEnabled || !db) return;
      
      try {
        const doc = await db.collection('diseaseAnalytics').doc(firebaseId).get();
        if (doc.exists) {
          const data = doc.data();
          if (data.imageBase64) {
            // Update the placeholder with the actual image
            const imgElement = document.getElementById('img_' + logId);
            if (imgElement) {
              const img = document.createElement('img');
              img.src = 'data:image/jpeg;base64,' + data.imageBase64;
              img.className = 'history-image';
              img.alt = 'Analysis image';
              imgElement.replaceWith(img);
            }
            
            // Update local data cache
            const logIndex = analyticsData.logs.findIndex(l => l.id === logId);
            if (logIndex !== -1) {
              analyticsData.logs[logIndex].imageBase64 = data.imageBase64;
              saveAnalytics();
            }
          } else {
            // No image available
            const imgElement = document.getElementById('img_' + logId);
            if (imgElement) {
              imgElement.textContent = 'ЁЯУ╖ ' + translateText('No image available');
            }
          }
        }
      } catch (e) {
        console.error('Failed to load image from Firebase:', e);
        const imgElement = document.getElementById('img_' + logId);
        if (imgElement) {
          imgElement.textContent = translateText('тЭМ Failed to load image');
        }
      }
    }
    
    // Sync with Firebase
    async function syncWithFirebase() {
      if (!firebaseEnabled || !db) {
        alert('Firebase not configured. Please update firebaseConfig in the code.');
        return;
      }
      
      try {
        const btn = event.target;
        btn.disabled = true;
        btn.textContent = translateText('тП│ Syncing...');
        
        let uploaded = 0;
        for (const log of analyticsData.logs) {
          if (!log.firebaseId) {
            await saveToFirebase(log);
            uploaded++;
          }
        }
        
        alert('Synced ' + uploaded + ' new records to Firebase');
        
        btn.disabled = false;
        btn.textContent = translateText('ЁЯФД Sync');
      } catch (e) {
        console.error('тЭМ Sync failed:', e);
        alert('Sync failed: ' + e.message);
        event.target.disabled = false;
        event.target.textContent = translateText('ЁЯФД Sync');
      }
    }
    
    // Update analytics dashboard
    function updateAnalyticsDashboard() {
      if (analyticsData.logs.length === 0) {
        document.getElementById('totalScans').textContent = '0';
        document.getElementById('diseasesFound').textContent = '0';
        document.getElementById('avgConfidence').textContent = '0%';
        document.getElementById('riskLevel').textContent = 'N/A';
        return;
      }
      
      // Calculate statistics
      const totalScans = analyticsData.logs.length;
      const diseaseLogs = analyticsData.logs.filter(log => log.primaryDisease !== 'Healthy');
      const diseasesFound = diseaseLogs.length;
      
      const totalConfidence = analyticsData.logs.reduce((sum, log) => sum + log.avgConfidence, 0);
      const avgConfidence = totalScans > 0 ? (totalConfidence / totalScans).toFixed(1) : 0;
      
      // Risk level assessment
      const recentLogs = analyticsData.logs.slice(-10);
      const recentDiseases = recentLogs.filter(log => log.primaryDisease !== 'Healthy').length;
      const riskLevel = recentDiseases >= 7 ? 'High' : recentDiseases >= 4 ? 'Medium' : 'Low';
      
      // Update stats
      document.getElementById('totalScans').textContent = totalScans;
      document.getElementById('diseasesFound').textContent = diseasesFound;
      document.getElementById('avgConfidence').textContent = avgConfidence + '%';
      document.getElementById('riskLevel').textContent = riskLevel;
      
      // Disease change trend
      if (analyticsData.logs.length >= 2) {
        const previousDiseaseRate = analyticsData.logs.slice(0, -1).filter(log => log.primaryDisease !== 'Healthy').length;
        const change = diseasesFound - previousDiseaseRate;
        const changeEl = document.getElementById('diseaseChange');
        if (change > 0) {
          changeEl.textContent = '+' + change + ' from previous';
          changeEl.className = 'change up';
        } else if (change < 0) {
          changeEl.textContent = change + ' from previous';
          changeEl.className = 'change down';
        } else {
          changeEl.textContent = 'No change';
          changeEl.className = 'change';
        }
      }
      
      updateCharts();
    }
    
    // Update all charts
    function updateCharts() {
      updateDiseaseChart();
      updateConfidenceChart();
      // Sensor-related charts removed
      updateTimelineChart();
      updateModelPrecisionChart();
    }
    
    // Model Precision Chart based on user feedback
    function updateModelPrecisionChart() {
      const container = document.getElementById('modelPrecisionChartContainer');
      if (!container) {
        console.warn('тЪая╕П Chart container not found');
        return;
      }
      
      console.log('ЁЯУК Updating model precision chart with feedback data:', analyticsData.modelFeedback);
      
      const modelNames = [];
      const precisionData = [];
      const correctData = [];
      const wrongData = [];
      
      // Calculate precision for each model
      for (const modelName in analyticsData.modelFeedback) {
        const feedback = analyticsData.modelFeedback[modelName];
        if (feedback.total > 0) {
          modelNames.push(modelName);
          const precision = ((feedback.correct / feedback.total) * 100).toFixed(1);
          precisionData.push(parseFloat(precision));
          correctData.push(feedback.correct);
          wrongData.push(feedback.wrong);
        }
      }
      
      // If no data, show message
      if (modelNames.length === 0) {
        if (analyticsData.charts.modelPrecision) {
          analyticsData.charts.modelPrecision.destroy();
          analyticsData.charts.modelPrecision = null;
        }
        container.innerHTML = '<p style="text-align: center; padding: 60px 20px; color: var(--on-surface-variant); font-size: 14px;">ЁЯУК No feedback data yet.<br><br>Rate model predictions using тЬУ Correct or тЬЧ Wrong buttons to see precision statistics.</p><canvas id="modelPrecisionChart" style="width: 100%; height: 100%;"></canvas>';
        console.log('тД╣я╕П No feedback data available for chart');
        return;
      }
      
      console.log('ЁЯУК Chart data - Models:', modelNames.length, '| Precision:', precisionData);
      
      // Ensure canvas exists (it might have been replaced with message)
      let canvas = document.getElementById('modelPrecisionChart');
      
      if (!canvas) {
        console.log('ЁЯФД Recreating chart canvas...');
        container.innerHTML = '<canvas id="modelPrecisionChart" style="width: 100%; height: 100%;"></canvas>';
        canvas = document.getElementById('modelPrecisionChart');
      }
      
      // Destroy existing chart
      if (analyticsData.charts.modelPrecision) {
        analyticsData.charts.modelPrecision.destroy();
        analyticsData.charts.modelPrecision = null;
      }
      
      console.log('тЬЕ Creating chart with', modelNames.length, 'models');
      
      // Create new chart with larger bars
      analyticsData.charts.modelPrecision = new Chart(canvas, {
        type: 'bar',
        data: {
          labels: modelNames,
          datasets: [
            {
              label: 'Precision (%)',
              data: precisionData,
              backgroundColor: precisionData.map(p => p >= 80 ? '#34A85380' : p >= 60 ? '#FBBC0480' : '#EA433580'),
              borderColor: precisionData.map(p => p >= 80 ? '#34A853' : p >= 60 ? '#FBBC04' : '#EA4335'),
              borderWidth: 3,
              borderRadius: 8,
              yAxisID: 'y'
            },
            {
              label: 'Correct',
              data: correctData,
              backgroundColor: '#34A85340',
              borderColor: '#34A853',
              borderWidth: 2,
              borderRadius: 6,
              yAxisID: 'y1',
              hidden: true
            },
            {
              label: 'Wrong',
              data: wrongData,
              backgroundColor: '#EA433540',
              borderColor: '#EA4335',
              borderWidth: 2,
              borderRadius: 6,
              yAxisID: 'y1',
              hidden: true
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                callback: function(value) { return value + '%'; },
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                font: { size: 13 }
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.1)'
              }
            },
            y1: {
              beginAtZero: true,
              position: 'right',
              title: {
                display: true,
                text: 'Count',
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                font: { size: 14, weight: 'bold' }
              },
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                font: { size: 13 }
              },
              grid: {
                drawOnChartArea: false
              }
            },
            x: {
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                maxRotation: 45,
                minRotation: 25,
                font: { size: 12, weight: '500' }
              },
              grid: {
                display: false
              }
            }
          },
          plugins: {
            legend: {
              display: true,
              position: 'top',
              labels: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface'),
                font: { size: 13, weight: '600' },
                padding: 15,
                usePointStyle: true
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const label = context.dataset.label || '';
                  const value = context.parsed.y;
                  if (context.datasetIndex === 0) {
                    const modelName = context.label;
                    const feedback = analyticsData.modelFeedback[modelName];
                    return [
                      label + ': ' + value.toFixed(1) + '%',
                      'Correct: ' + feedback.correct,
                      'Wrong: ' + feedback.wrong,
                      'Total: ' + feedback.total
                    ];
                  }
                  return label + ': ' + value;
                }
              }
            }
          }
        }
      });
    }
    
    // Disease Distribution Pie Chart
    function updateDiseaseChart() {
      const ctx = document.getElementById('diseaseChart');
      if (!ctx) return;
      
      // Count disease occurrences
      const diseaseCounts = {};
      analyticsData.logs.forEach(log => {
        if (log.primaryDisease !== 'Healthy') {
          diseaseCounts[log.primaryDisease] = (diseaseCounts[log.primaryDisease] || 0) + 1;
        }
      });
      
      const labels = Object.keys(diseaseCounts);
      const data = Object.values(diseaseCounts);
      
      if (analyticsData.charts.disease) {
        analyticsData.charts.disease.destroy();
      }
      
      analyticsData.charts.disease = new Chart(ctx, {
        type: 'doughnut',
        data: {
          labels: labels.length > 0 ? labels : ['No diseases detected'],
          datasets: [{
            data: data.length > 0 ? data : [1],
            backgroundColor: [
              '#EA4335', '#FBBC04', '#34A853', '#4285F4', '#9C27B0',
              '#FF9800', '#00BCD4', '#E91E63', '#8BC34A', '#FF5722'
            ],
            borderWidth: 2,
            borderColor: getComputedStyle(document.documentElement).getPropertyValue('--surface')
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              position: 'bottom',
              labels: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface'),
                font: { size: 11 },
                padding: 10
              }
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return context.label + ': ' + context.parsed + ' occurrences';
                }
              }
            }
          }
        }
      });
    }
    
    // Confidence Trend Line Chart
    function updateConfidenceChart() {
      const ctx = document.getElementById('confidenceChart');
      if (!ctx) return;
      
      const recentLogs = analyticsData.logs.slice(-20);
      const labels = recentLogs.map((log, i) => 'Scan ' + (analyticsData.logs.length - 20 + i + 1));
      const confidenceData = recentLogs.map(log => log.avgConfidence);
      
      if (analyticsData.charts.confidence) {
        analyticsData.charts.confidence.destroy();
      }
      
      analyticsData.charts.confidence = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [{
            label: 'Confidence %',
            data: confidenceData,
            borderColor: '#4285F4',
            backgroundColor: 'rgba(66, 133, 244, 0.1)',
            tension: 0.4,
            fill: true,
            pointRadius: 4,
            pointHoverRadius: 6
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              max: 100,
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            x: {
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                maxRotation: 45,
                minRotation: 45,
                font: { size: 9 }
              },
              grid: {
                display: false
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
              }
            }
          }
        }
      });
    }
    
    // Sensor-related chart functions removed
    
    
    // Timeline Chart - Shows all analyses over time
    function updateTimelineChart() {
      const ctx = document.getElementById('timelineChart');
      if (!ctx) return;
      
      if (analyticsData.logs.length === 0) {
        if (analyticsData.charts.timeline) {
          analyticsData.charts.timeline.destroy();
          analyticsData.charts.timeline = null;
        }
        return;
      }
      
      // Prepare data for timeline
      const sortedLogs = [...analyticsData.logs].sort((a, b) => 
        new Date(a.timestamp) - new Date(b.timestamp)
      );
      
      const labels = sortedLogs.map(log => {
        const date = new Date(log.timestamp);
        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      });
      
      const confidenceData = sortedLogs.map(log => log.avgConfidence);
      const severityScores = sortedLogs.map(log => {
        if (!log.environmentalContext) return 0;
        const severityMap = { low: 2, moderate: 4, high: 7, critical: 10 };
        return severityMap[log.environmentalContext.severity] || 0;
      });
      
      const diseaseCount = sortedLogs.map(log => log.diseases ? log.diseases.length : 0);
      
      if (analyticsData.charts.timeline) {
        analyticsData.charts.timeline.destroy();
      }
      
      analyticsData.charts.timeline = new Chart(ctx, {
        type: 'line',
        data: {
          labels,
          datasets: [
            {
              label: 'Confidence %',
              data: confidenceData,
              borderColor: '#4285F4',
              backgroundColor: 'rgba(66, 133, 244, 0.1)',
              tension: 0.3,
              fill: false,
              pointRadius: 5,
              pointHoverRadius: 7,
              yAxisID: 'y'
            },
            {
              label: 'Environmental Risk (0-10)',
              data: severityScores,
              borderColor: '#EA4335',
              backgroundColor: 'rgba(234, 67, 53, 0.1)',
              tension: 0.3,
              fill: false,
              pointRadius: 4,
              pointHoverRadius: 6,
              yAxisID: 'y1'
            },
            {
              label: 'Diseases Detected',
              data: diseaseCount,
              borderColor: '#FBBC04',
              backgroundColor: 'rgba(251, 188, 4, 0.1)',
              tension: 0.3,
              fill: true,
              pointRadius: 4,
              pointHoverRadius: 6,
              yAxisID: 'y2'
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          scales: {
            y: {
              type: 'linear',
              display: true,
              position: 'left',
              title: {
                display: true,
                text: 'Confidence %',
                color: '#4285F4'
              },
              min: 0,
              max: 100,
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
              },
              grid: {
                color: 'rgba(255, 255, 255, 0.05)'
              }
            },
            y1: {
              type: 'linear',
              display: true,
              position: 'right',
              title: {
                display: true,
                text: 'Risk Score',
                color: '#EA4335'
              },
              min: 0,
              max: 10,
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
              },
              grid: {
                drawOnChartArea: false
              }
            },
            y2: {
              type: 'linear',
              display: false,
              min: 0,
              max: 10
            },
            x: {
              ticks: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                maxRotation: 45,
                minRotation: 45,
                font: { size: 9 }
              },
              grid: {
                display: false
              }
            }
          },
          plugins: {
            legend: {
              labels: {
                color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface'),
                font: { size: 11 }
              }
            },
            tooltip: {
              callbacks: {
                afterLabel: function(context) {
                  const log = sortedLogs[context.dataIndex];
                  if (log.primaryDisease && log.primaryDisease !== 'Healthy') {
                    return 'Disease: ' + log.primaryDisease;
                  }
                  return '';
                }
              }
            }
          }
        }
      });
    }
    
    // History Panel Functions
    function updateHistoryPanel(filter = 'all') {
      const panel = document.getElementById('historyPanel');
      if (!panel) return;
      
      if (analyticsData.logs.length === 0) {
        panel.innerHTML = '<p style="text-align: center; color: var(--on-surface-variant); padding: 32px;">No analysis history yet. Run your first scan to get started.</p>';
        return;
      }
      
      // Filter logs
      let filteredLogs = [...analyticsData.logs];
      if (filter === 'diseases') {
        filteredLogs = filteredLogs.filter(log => log.primaryDisease !== 'Healthy');
      } else if (filter === 'healthy') {
        filteredLogs = filteredLogs.filter(log => log.primaryDisease === 'Healthy');
      }
      
      // Sort by timestamp (newest first)
      filteredLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      
      let html = '';
      filteredLogs.forEach((log, index) => {
        const severityClass = log.environmentalContext ? log.environmentalContext.severity : 'low';
        const date = new Date(log.timestamp);
        const timeAgo = getTimeAgo(date);
        
        html += `<div class="history-item ${severityClass}">`;
        html += '<div class="history-header">';
        html += '<div class="history-date" onclick="toggleHistoryDetails(' + index + ', \'' + log.id + '\')"; style="cursor: pointer;">' + date.toLocaleString() + ' (' + timeAgo + ')</div>';
        html += '<button class="delete-btn" onclick="event.stopPropagation(); deleteAnalysis(\'' + log.id + '\')" title="Delete this record">ЁЯЧСя╕П Delete</button>';
        
        if (log.overallSeverity && log.overallSeverity !== 'unknown') {
          const severityColors = { low: '#34A853', moderate: '#FBBC04', high: '#FF9800', critical: '#EA4335' };
          html += '<span style="background:' + (severityColors[log.overallSeverity] || '#5f6368') + '20; color:' + (severityColors[log.overallSeverity] || '#5f6368') + '; padding:4px 8px; border-radius:4px; font-size:11px; font-weight:600; text-transform:uppercase;">' + log.overallSeverity + '</span>';
        }
        
        html += '</div>';
        
        html += '<div class="history-disease" onclick="toggleHistoryDetails(' + index + ', \'' + log.id + '\')"; style="cursor: pointer;">';
        if (log.primaryDisease === 'Healthy') {
          html += 'тЬЕ Healthy Plant';
        } else {
          html += 'тЪая╕П ' + log.primaryDisease;
        }
        html += '</div>';
        
        if (log.avgConfidence > 0) {
          html += '<div class="history-confidence" onclick="toggleHistoryDetails(' + index + ', \'' + log.id + '\')"; style="cursor: pointer;">Confidence: ' + log.avgConfidence.toFixed(1) + '%</div>';
        }
        
        // Details section (hidden by default)
        html += '<div class="history-details" id="details_' + log.id + '">';
        
        // Image - Load from Firebase if not in local data
        if (log.imageBase64) {
          html += '<img src="data:image/jpeg;base64,' + log.imageBase64 + '" class="history-image" alt="Analysis image">';
        } else if (log.firebaseId) {
          // Placeholder for images being loaded from Firebase
          html += '<div class="history-image" style="display:flex;align-items:center;justify-content:center;background:#f0f0f0;min-height:150px;" id="img_' + log.id + '">ЁЯУ╖ Loading image...</div>';
          // Load image asynchronously
          loadImageFromFirebase(log.firebaseId, log.id);
        }
        
        // Diseases detected
        if (log.diseases && log.diseases.length > 0) {
          html += '<div style="margin-top: 12px;"><strong>Diseases Detected:</strong><ul style="margin: 4px 0; padding-left: 20px;">';
          log.diseases.forEach(d => {
            html += '<li>' + d.name + ' (' + d.confidence.toFixed(1) + '%) - ' + d.severity + ' severity, ' + d.urgency + '</li>';
          });
          html += '</ul></div>';
        }
        
        // Environmental context
        if (log.environmentalContext && log.environmentalContext.riskFactors.length > 0) {
          html += '<div style="margin-top: 12px;"><strong>Environmental Risks:</strong><ul style="margin: 4px 0; padding-left: 20px; font-size: 13px; color: var(--on-surface-variant);">';
          log.environmentalContext.riskFactors.forEach(r => {
            html += '<li>' + r + '</li>';
          });
          html += '</ul></div>';
        }
        
        // Sensor data
        if (log.sensorData) {
          html += '<div style="margin-top: 12px;"><strong>Sensor Data:</strong>';
          html += '<div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 8px;">';
          html += '<div><small>Soil Moisture:</small><br><strong>' + log.sensorData.soilMoisture.toFixed(1) + '%</strong></div>';
          html += '<div><small>Air Temp:</small><br><strong>' + log.sensorData.airTemp.toFixed(1) + '┬░C</strong></div>';
          html += '<div><small>Humidity:</small><br><strong>' + log.sensorData.airHumidity.toFixed(1) + '%</strong></div>';
          html += '<div><small>TDS:</small><br><strong>' + log.sensorData.tdsValue.toFixed(0) + ' ppm</strong></div>';
          html += '<div><small>Light:</small><br><strong>' + log.sensorData.lightLevel.toFixed(0) + ' lux</strong></div>';
          html += '<div><small>Soil Temp:</small><br><strong>' + log.sensorData.soilTemp.toFixed(1) + '┬░C</strong></div>';
          html += '</div></div>';
        }
        
        // Model results
        if (log.allModelResults && log.allModelResults.length > 0) {
          html += '<div style="margin-top: 12px;"><strong>Model Results:</strong><ul style="margin: 4px 0; padding-left: 20px; font-size: 12px;">';
          log.allModelResults.forEach(m => {
            if (m.error) {
              html += '<li>' + m.modelName + ': <span style="color: var(--error);">Error - ' + m.error + '</span></li>';
            } else if (m.detectedClass) {
              html += '<li>' + m.modelName + ': ' + m.detectedClass + ' (' + m.confidence.toFixed(1) + '%)</li>';
            } else {
              html += '<li>' + m.modelName + ': No detection</li>';
            }
          });
          html += '</ul></div>';
        }
        
        html += '</div>'; // close details
        html += '</div>'; // close history-item
      });
      
      panel.innerHTML = html;
    }
    
    function toggleHistoryDetails(index, logId) {
      const item = event.currentTarget;
      const details = document.getElementById('details_' + logId);
      
      if (item.classList.contains('expanded')) {
        item.classList.remove('expanded');
      } else {
        // Close all other expanded items
        document.querySelectorAll('.history-item.expanded').forEach(el => {
          el.classList.remove('expanded');
        });
        item.classList.add('expanded');
      }
    }
    
    function filterHistory(filter) {
      updateHistoryPanel(filter);
    }

    async function deleteAnalysis(logId) {
      if (!confirm('Are you sure you want to delete this analysis record? This action cannot be undone.')) {
        return;
      }

      try {
        // Remove from localStorage
        const logs = JSON.parse(localStorage.getItem('analysisLogs') || '[]');
        const updatedLogs = logs.filter(log => log.id !== logId);
        localStorage.setItem('analysisLogs', JSON.stringify(updatedLogs));
        
        console.log('тЬЕ Deleted from local storage:', logId);

        // Remove from Firebase if connected
        if (firebaseEnabled && db) {
          try {
            // Find the document with matching id field
            const snapshot = await db.collection('diseaseAnalytics')
              .where('id', '==', logId)
              .limit(1)
              .get();
            
            if (!snapshot.empty) {
              await snapshot.docs[0].ref.delete();
              console.log('тЬЕ Deleted from Firebase:', logId);
            }
          } catch (fbError) {
            console.error('тЪая╕П Failed to delete from Firebase:', fbError);
          }
        }

        // Update UI
        updateHistoryPanel();
        
        // Show success message
        alert('тЬЕ Record deleted successfully!');
      } catch (error) {
        console.error('тЭМ Delete failed:', error);
        alert('тЭМ Failed to delete record: ' + error.message);
      }
    }
    
    function getTimeAgo(date) {
      const now = new Date();
      const diffMs = now - date;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);
      
      if (diffMins < 1) return 'just now';
      if (diffMins < 60) return diffMins + ' min ago';
      if (diffHours < 24) return diffHours + ' hour' + (diffHours > 1 ? 's' : '') + ' ago';
      if (diffDays < 7) return diffDays + ' day' + (diffDays > 1 ? 's' : '') + ' ago';
      return date.toLocaleDateString();
    }
    
    // Export analytics data
    function exportAnalyticsData() {
      if (analyticsData.logs.length === 0) {
        alert('No analytics data to export');
        return;
      }
      
      const dataStr = JSON.stringify(analyticsData.logs, null, 2);
      const blob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'disease_analytics_' + new Date().toISOString().split('T')[0] + '.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    // Clear analytics data
async function clearAnalyticsData() {
      if (!confirm('Are you sure you want to clear the Diagnostic Log? This will permanently delete all analysis history from this device and from Firebase. This action cannot be undone.')) {
        return;
      }
      
      // Clear local data
      analyticsData.logs = [];
      saveAnalytics(); // This will clear localStorage
      updateAnalyticsDashboard();
      updateHistoryPanel();

      // Clear from Firebase
      if (firebaseReady && firebaseEnabled && db) {
        console.log('ЁЯЧСя╕П Deleting all logs from Firebase...');
        try {
          const snapshot = await db.collection('diseaseAnalytics').limit(500).get(); // Limit to 500 per batch
          if (snapshot.empty) {
            console.log('тЬЕ No logs to delete in Firebase.');
            alert('Diagnostic Log cleared.');
            return;
          }

          const batch = db.batch();
          snapshot.docs.forEach(doc => {
            batch.delete(doc.ref);
          });
          
          await batch.commit();
          
          console.log('тЬЕ Batch of', snapshot.size, 'logs deleted from Firebase.');

          // If there might be more logs, recursively call until empty
          if (snapshot.size === 500) {
            console.log('There might be more logs to delete, running again...');
            await clearAnalyticsData();
          } else {
            alert('Diagnostic Log cleared from this device and from Firebase.');
          }
        } catch (e) {
          console.error('тЭМ Failed to delete logs from Firebase:', e);
          alert('Error clearing logs from Firebase: ' + e.message);
        }
      } else {
        alert('Diagnostic Log cleared from this device.');
      }
    }
    
    // Disease name aliases and variations for improved matching accuracy
    const DISEASE_ALIASES = {
      'tomato_septoria_leaf_spot': ['septoria', 'septoria leaf spot', 'tomato septoria'],
      'tomato_early_blight': ['early blight', 'alternaria solani', 'target spot tomato'],
      'tomato_late_blight': ['late blight', 'phytophthora', 'tomato blight'],
      'tomato_bacterial_spot': ['bacterial spot', 'xanthomonas', 'bacterial speck'],
      'tomato_target_spot': ['target spot', 'corynespora'],
      'tomato_yellow_leaf_curl': ['yellow leaf curl', 'tylcv', 'leaf curl virus', 'tomato virus'],
      'tomato_mosaic': ['mosaic virus', 'tmv', 'tobacco mosaic', 'viral disease'],
      'tomato_leaf_mold': ['leaf mold', 'cladosporium', 'mold'],
      'tomato_spider_mites': ['spider mites', 'two spotted mites', 'mites', 'red spider'],
      'potato_early_blight': ['potato early blight', 'alternaria', 'early blight potato'],
      'potato_late_blight': ['potato late blight', 'late blight potato', 'phytophthora potato'],
      'corn_common_rust': ['corn rust', 'maize rust', 'rust', 'puccinia'],
      'corn_gray_leaf_spot': ['gray leaf spot', 'grey leaf spot', 'cercospora maize'],
      'corn_northern_leaf_blight': ['northern leaf blight', 'turcicum', 'leaf blight corn'],
      'grape_black_rot': ['black rot grape', 'guignardia', 'grape rot'],
      'grape_esca': ['esca', 'black measles', 'grapevine decline'],
      'grape_leaf_blight': ['leaf blight grape', 'isariopsis', 'grape leaf spot'],
      'strawberry_leaf_scorch': ['leaf scorch', 'diplocarpon', 'strawberry scorch'],
      'apple_black_rot': ['black rot apple', 'frog eye', 'apple rot'],
      'apple_cedar_rust': ['cedar rust', 'gymnosporangium', 'apple rust'],
      'cherry_powdery_mildew': ['cherry mildew', 'powdery mildew cherry'],
      'peach_bacterial_spot': ['peach spot', 'bacterial spot peach', 'xanthomonas peach'],
      'pepper_bacterial_spot': ['pepper spot', 'bacterial spot pepper'],
      'bell_pepper_bacterial_spot': ['bell pepper spot', 'bacterial spot bell pepper'],
      'squash_powdery_mildew': ['squash mildew', 'cucurbit mildew', 'powdery mildew squash'],
      'banana_pestalotiopsis': ['pestalotiopsis', 'banana leaf spot', 'sigatoka'],
      'banana_black_sigatoka': ['black sigatoka', 'black leaf streak', 'mycosphaerella'],
      'banana_panama_disease': ['panama disease', 'fusarium wilt banana', 'banana wilt'],
      'rice_bacterial_leaf_blight': ['bacterial blight rice', 'kresek', 'xanthomonas rice', 'bacterial leaf blight', 'blb'],
      'rice_brown_spot': ['brown spot rice', 'helminthosporium', 'narrow brown spot', 'brown spot'],
      'rice_blast': ['blast', 'leaf blast', 'neck blast', 'panicle blast', 'pyricularia', 'magnaporthe'],
      'rice_sheath_blight': ['sheath blight', 'rhizoctonia rice', 'sheath rot rice'],
      'rice_tungro': ['tungro', 'tungro disease', 'rice tungro virus', 'rtv'],
      'rice_hispa': ['hispa', 'rice hispa beetle', 'leaf miner rice'],
      'rice_leaf_folder': ['leaf folder', 'leaf roller', 'cnaphalocrocis'],
      'rice_false_smut': ['false smut', 'green smut', 'ustilaginoidea'],
      'rice_sheath_rot': ['sheath rot', 'sarocladium'],
      'bacterial_leaf_streak': ['leaf streak', 'bacterial streak', 'xanthomonas oryzae'],
      'wheat_leaf_rust': ['wheat rust', 'brown rust', 'puccinia wheat'],
      'wheat_yellow_rust': ['yellow rust', 'stripe rust', 'puccinia striiformis'],
      'soybean_sudden_death': ['sudden death', 'sds', 'fusarium soybean'],
      'cotton_bacterial_blight': ['angular leaf spot cotton', 'bacterial blight cotton'],
      'chili_leaf_curl': ['chili leaf curl', 'pepper leaf curl', 'leaf curl disease chili', 'chili virus'],
      'chili_anthracnose': ['anthracnose chili', 'fruit rot chili', 'colletotrichum chili'],
      'chili_bacterial_wilt': ['bacterial wilt chili', 'ralstonia chili', 'wilt disease chili'],
      'chili_powdery_mildew': ['powdery mildew chili', 'white mildew chili', 'leveillula chili'],
      'chili_mosaic_virus': ['chili mosaic', 'pepper mosaic', 'cmv', 'viral disease chili'],
      'chili_thrips': ['thrips chili', 'pepper thrips', 'scirtothrips', 'yellow thrips'],
      'chili_fruit_borer': ['fruit borer chili', 'helicoverpa chili', 'pod borer'],
      'potato_early_blight': ['potato early blight', 'early blight potato', 'alternaria potato'],
      'potato_black_scurf': ['black scurf', 'rhizoctonia potato', 'stem canker potato'],
      'potato_common_scab': ['common scab potato', 'scab potato', 'streptomyces scab']
    };
    
    // Enhanced matching function with scoring algorithm
    function getRemedy(diseaseName) {
      if (!diseaseName || diseaseName === '-') return 'N/A';
      
      const name = diseaseName.toLowerCase().trim();
      
      // Remove underscores and extra spaces
      const cleanName = name.replace(/_/g, ' ').replace(/\s+/g, ' ');
      
      // First, check for exact matches (highest priority)
      for (const [key, remedy] of Object.entries(REMEDIES)) {
        if (cleanName === key || name === key) {
          return getTranslatedRemedy(remedy);
        }
      }
      
      // Second, check disease aliases
      for (const [aliasKey, aliasList] of Object.entries(DISEASE_ALIASES)) {
        const cleanAliasKey = aliasKey.replace(/_/g, ' ');
        if (cleanName === cleanAliasKey || name === aliasKey) {
          // Find remedy by checking alias list against remedy keys
          for (const alias of aliasList) {
            for (const [key, remedy] of Object.entries(REMEDIES)) {
              if (key === alias || alias.includes(key) || key.includes(alias)) {
                return getTranslatedRemedy(remedy);
              }
            }
          }
        }
      }
      
      // Third, check if any alias matches the input
      for (const [aliasKey, aliasList] of Object.entries(DISEASE_ALIASES)) {
        for (const alias of aliasList) {
          if (cleanName.includes(alias) || alias.includes(cleanName)) {
            // Found a match, now find the remedy
            for (const [key, remedy] of Object.entries(REMEDIES)) {
              if (aliasList.some(a => a === key || a.includes(key) || key.includes(a))) {
                return remedy;
              }
            }
          }
        }
      }
      
      // Fourth, fuzzy matching with scoring
      let bestMatch = null;
      let bestScore = 0;
      
      for (const [key, remedy] of Object.entries(REMEDIES)) {
        let score = 0;
        
        // Calculate match score
        if (cleanName.includes(key)) score += 10;
        if (key.includes(cleanName)) score += 8;
        
        // Word-by-word matching
        const nameWords = cleanName.split(' ');
        const keyWords = key.split(' ');
        
        for (const nWord of nameWords) {
          for (const kWord of keyWords) {
            if (nWord === kWord) score += 5;
            else if (nWord.includes(kWord) || kWord.includes(nWord)) score += 3;
            // Check for common disease terms
            if (['blight', 'spot', 'rot', 'wilt', 'rust', 'mildew', 'mosaic', 'curl'].includes(nWord) && 
                ['blight', 'spot', 'rot', 'wilt', 'rust', 'mildew', 'mosaic', 'curl'].includes(kWord)) {
              score += 2;
            }
          }
        }
        
        // Bonus for plant name matches
        const plants = ['tomato', 'potato', 'corn', 'maize', 'wheat', 'rice', 'grape', 'apple', 'banana', 
                        'pepper', 'chili', 'cucumber', 'cabbage', 'onion', 'soybean', 'cotton'];
        for (const plant of plants) {
          if (cleanName.includes(plant) && key.includes(plant)) score += 4;
        }
        
        if (score > bestScore && score >= 5) {
          bestScore = score;
          bestMatch = remedy;
        }
      }
      
      if (bestMatch) return getTranslatedRemedy(bestMatch);

      const keywords = {
        'blight': 'blight',
        'spot': 'bacterial spot',
        'rot': 'rot',
        'wilt': 'wilt',
        'rust': 'rust',
        'mildew': 'powdery mildew',
        'mosaic': 'mosaic virus',
        'curl': 'leaf curl',
        'borer': 'fruit borer',
        'mite': 'spider mites',
        'aphid': 'aphids',
        'whitefly': 'whitefly',
        'thrips': 'thrips'
      };

      for (const [keyword, remedyKey] of Object.entries(keywords)) {
        if (cleanName.includes(keyword) && REMEDIES[remedyKey]) {
          return getTranslatedRemedy(REMEDIES[remedyKey]);
        }
      }

      return getTranslatedRemedy(REMEDIES.default);
    }
    
    let BASE_URL = 'http://10.180.248.33';  // Default ESP32 IP
    const api = (path) => BASE_URL + path;
    let streamActive = false;

    

    

    
    // Translate remedy text to Bengali (simple token replacements)
    function translateRemedyText(remedy) {
      const lang = getLang();
      if (lang !== 'bn' || !remedy) return remedy;
      let text = remedy;

      const tokenMap = {
        'Organic:': 'ржЕрж░рзНржЧрж╛ржирж┐ржХ:',
        'ЁЯФ╣ Organic:': 'ЁЯФ╣ ржЕрж░рзНржЧрж╛ржирж┐ржХ:',
        'Chemical:': 'рж░рж╛рж╕рж╛ржпрж╝ржирж┐ржХ:',
        'ЁЯФ╣ Chemical:': 'ЁЯФ╣ рж░рж╛рж╕рж╛ржпрж╝ржирж┐ржХ:',
        'Spray': 'ржЫрж┐ржЯрж╛ржи',
        'Apply': 'ржкрзНрж░ржпрж╝рзЛржЧ ржХрж░рзБржи',
        'Soil': 'ржорж╛ржЯрж┐',
        'Soil drench': 'ржорж╛ржЯрж┐ ржбрзНрж░рзЗржЮрзНржЪ',
        'Seed treatment': 'ржмрзАржЬ ржЪрж┐ржХрж┐рзОрж╕рж╛',
        'Foliar': 'ржкрж╛рждрж╛ржпрж╝ рж╕рзНржкрзНрж░рзЗ',
        'Remove infected plants immediately': 'ржЕржмрж┐рж▓ржорзНржмрзЗ ржЖржХрзНрж░рж╛ржирзНржд ржЧрж╛ржЫ ржЕржкрж╕рж╛рж░ржи ржХрж░рзБржи',
        'No cure available': 'ржХрзЛржиржУ ржЪрж┐ржХрж┐рзОрж╕рж╛ ржирзЗржЗ',
        'No disease detected': 'ржХрзЛржирзЛ рж░рзЛржЧ рж╕ржирж╛ржХрзНржд рж╣ржпрж╝ржирж┐',
        'Unable to detect disease. Ensure proper image quality. If disease visible, consult agricultural expert with leaf sample for proper diagnosis.': 'рж░рзЛржЧ рж╕ржирж╛ржХрзНржд ржХрж░рж╛ ржпрж╛ржпрж╝ржирж┐ред рж╕ржарж┐ржХ ржирж┐рж░рзНржгрзЯрзЗрж░ ржЬржирзНржп ржЫржмрж┐ ржорж╛ржи ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рзБржи; ржЧрзБрж░рзБрждрж░ рж╣рж▓рзЗ рж▓рж┐ржл ржиржорзБржирж╛ ржирж┐рзЯрзЗ ржХрзГрж╖рж┐ ржмрж┐рж╢рзЗрж╖ржЬрзНржЮрзЗрж░ рж╕рж╛ржерзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржи.'
      };

      Object.entries(tokenMap).forEach(([k, v]) => {
        const re = new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
        text = text.replace(re, v);
      });

      return text;
    }

    function getTranslatedRemedy(remedy) {
      if (getLang() === 'bn') return translateRemedyText(remedy);
      return remedy;
    }

    // Fetch with timeout helper
    function fetchWithTimeout(url, options = {}, timeout = 5000) {
      return Promise.race([
        fetch(url, options),
        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), timeout))
      ]);
    }

    function setIP() {
      const ip = document.getElementById('ipInput').value.trim();
      if (!ip) {
        alert('Please enter ESP32 IP address');
        return;
      }
      
      const cleanIP = ip.replace('http://', '').replace('https://', '');
      BASE_URL = `http://${cleanIP}`;
      localStorage.setItem('esp32_ip', BASE_URL);
      
      console.log('Connecting to:', BASE_URL);
      document.getElementById('connStatus').textContent = translateText('Connecting...');
      document.getElementById('connStatus').style.color = 'var(--on-surface-variant)';

      const espDot = document.getElementById('espDot');
      const espStatus = document.getElementById('espStatus');
      espDot.classList.remove('offline');
      // espStatus.textContent = 'Connecting...';

      const testPaths = ['/capture', '/capture.jpg', '/stream', '/'];

      function testWithImage(path, timeout = 5000) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          let timer = setTimeout(() => {
            img.src = '';
            reject(new Error('Timeout'));
          }, timeout);
          img.onload = () => { clearTimeout(timer); resolve(path); };
          img.onerror = () => { clearTimeout(timer); reject(new Error('Image load error')); };
          img.src = `${BASE_URL}${path}?_t=${Date.now()}`;
        });
      }

      (async () => {
        let ok = false;
        for (const p of testPaths) {
          try {
            await testWithImage(p, 4000);
            ok = true;
            console.log('тЬУ ESP32 reachable via', p);
            break;
          } catch (err) {
            console.log('Attempt failed for', p, err.message);
          }
        }

        if (ok) {
          document.getElementById('connStatus').textContent = 'тЬЕ ' + translateText('ESP32 reachable');
          document.getElementById('connStatus').style.color = 'var(--success)';
          document.getElementById('visualBtn').disabled = false;
          document.getElementById('toggleBtn').disabled = false;
          document.getElementById('streamPlaceholder').textContent = translateText('Ready. Click "Start stream" to preview.');
          // document.getElementById('cs').textContent = 'Ready';
          document.getElementById('camDot').classList.remove('offline');
          espDot.classList.remove('offline');
          // espStatus.textContent = 'Online';
        } else {
          console.error('Connection failed: ESP32 not reachable at', cleanIP);
          document.getElementById('connStatus').textContent = 'тЭМ ' + translateText('Cannot reach ESP32 at') + ' ' + cleanIP;
          document.getElementById('connStatus').style.color = 'var(--error)';
          document.getElementById('streamPlaceholder').textContent = translateText('Connection failed. Check:\n1. ESP32 is powered on\n2. WiFi connected\n3. IP is correct: ') + cleanIP;
          // document.getElementById('cs').textContent = 'Offline';
          document.getElementById('camDot').classList.add('offline');
          espDot.classList.add('offline');
          // espStatus.textContent = 'Offline';
        }
      })();
    }
    
    function startStream() {
      const streamBtn = document.getElementById('toggleBtn');
      streamBtn.disabled = true; // Disable button during connection attempt
      streamBtn.textContent = translateText('Starting...');
      
      document.getElementById('connStatus').textContent = translateText('Connecting to stream...');
      document.getElementById('connStatus').style.color = 'var(--on-surface-variant)';
      // Show loading state
      const placeholder = document.getElementById('streamPlaceholder');
      placeholder.style.display = 'block';
      placeholder.textContent = translateText('Initializing stream...');
      document.getElementById('str').style.display = 'none';
      
      const streamImg = document.getElementById('str');
      // Remove crossOrigin to avoid strict CORS image handling in some browsers
      // (ESP responses already include Access-Control-Allow-Origin).

      // Consolidated handlers and cache-busting to ensure fresh connection
      let startTimeout = setTimeout(() => {
        console.warn('Stream load timeout');
        // Try fallback to capture polling if MJPEG fails
        startPollingCapture();
      }, 6000);

      streamImg.onload = function () {
        clearTimeout(startTimeout);
        placeholder.style.display = 'none';
        streamImg.style.display = 'block';

        console.log('тЬЕ Stream started successfully');
        document.getElementById('connStatus').textContent = 'тЬЕ ' + translateText('Stream connected');
        document.getElementById('connStatus').style.color = 'var(--success)';
        streamBtn.textContent = translateText('Stop Live View');
        streamBtn.disabled = false;
        streamActive = true;

        // document.getElementById('cs').textContent = 'Camera: Active';
        document.getElementById('camDot').classList.remove('offline');
        renderCtx(['Visual-only analysis. Sensors removed.']);
      };

      streamImg.onerror = function () {
        clearTimeout(startTimeout);
        console.error('Stream image failed to load; switching to capture polling fallback');
        startPollingCapture();
      };

      // Warm up the camera by requesting a single capture first, then start MJPEG stream.
      // This helps when the ESP's camera needs an initial request to begin producing frames.
      streamImg.style.display = 'none';
      const warmImg = new Image();
      let warmTimer = setTimeout(() => {
        // If warmup times out, still attempt the MJPEG stream
        warmImg.src = '';
        streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
      }, 1500);
      warmImg.onload = function () {
        clearTimeout(warmTimer);
        // After a successful single capture, attach the MJPEG stream
        streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
      };
      warmImg.onerror = function () {
        clearTimeout(warmTimer);
        // If warmup fails, still try the MJPEG stream (fallback handles failures)
        streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
      };
      // Trigger short warm-up request (capture.jpg)
      warmImg.src = `${BASE_URL}/capture.jpg?_t=${Date.now()}`;
    }

    // Polling fallback using /capture.jpg when MJPEG /stream isn't available
    let pollIntervalId = null;
    function startPollingCapture(interval = 800) {
      // clear existing handlers and any previous polling
      const streamImg = document.getElementById('str');
      const streamBtn = document.getElementById('toggleBtn');
      const placeholder = document.getElementById('streamPlaceholder');

      if (pollIntervalId) clearInterval(pollIntervalId);

      document.getElementById('connStatus').textContent = 'тЪая╕П ' + translateText('Using capture polling');
      document.getElementById('connStatus').style.color = 'var(--warn)';
      placeholder.textContent = translateText('Using fallback polling (capture.jpg)');
      placeholder.style.display = 'none';
      streamImg.style.display = 'block';
      streamBtn.textContent = translateText('Stop stream');
      streamBtn.disabled = false;
      streamActive = true;
      // document.getElementById('cs').textContent = 'Camera: Active (polling)';
      document.getElementById('camDot').classList.remove('offline');

      pollIntervalId = setInterval(() => {
        // append timestamp to avoid caching
        streamImg.src = `${BASE_URL}/capture.jpg?_t=${Date.now()}`;
      }, interval);
    }



    function toggleStream() {
      const streamImg = document.getElementById('str');
      const streamBtn = document.getElementById('toggleBtn');
      const placeholder = document.getElementById('streamPlaceholder');
      
      if (streamActive) {
        // Stop stream
        // Stop the MJPEG connection by setting to blank and removing handlers
        streamImg.onload = null;
        streamImg.onerror = null;
        streamImg.src = 'about:blank';
        streamImg.style.display = 'none';
        placeholder.style.display = 'block';
        placeholder.textContent = translateText('Stream paused');
        streamBtn.textContent = translateText('Start Live View');
        streamActive = false;

        // stop polling fallback if active
        if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }
        
        // Update status
        // document.getElementById('cs').textContent = 'Camera: Paused';
        document.getElementById('camDot').classList.add('offline');
      } else {
        // Start stream
        startStream();
      }
    }

    function renderCtx(n) {
      document.getElementById('ctx').innerHTML = '<h4>Context notes</h4><ul>' + n.map(x => '<li>' + x + '</li>').join('') + '</ul>';
    }

    // Handle feedback button clicks
    function handleModelFeedback(analysisId, modelName, isCorrect, feedbackId) {
      // Record the feedback
      recordModelFeedback(analysisId, modelName, isCorrect);
      
      // Update button states
      const correctBtn = document.getElementById('correct_' + feedbackId);
      const wrongBtn = document.getElementById('wrong_' + feedbackId);
      const statusDiv = document.getElementById('feedback_status_' + feedbackId);
      
      if (correctBtn && wrongBtn && statusDiv) {
        if (isCorrect) {
          correctBtn.style.background = '#34A853';
          correctBtn.style.color = 'white';
          correctBtn.disabled = true;
          wrongBtn.disabled = true;
          wrongBtn.style.opacity = '0.5';
          statusDiv.textContent = translateText('тЬУ Marked as correct');
          statusDiv.style.color = '#34A853';
        } else {
          wrongBtn.style.background = '#EA4335';
          wrongBtn.style.color = 'white';
          wrongBtn.disabled = true;
          correctBtn.disabled = true;
          correctBtn.style.opacity = '0.5';
          statusDiv.textContent = translateText('тЬЧ Marked as wrong');
          statusDiv.style.color = '#EA4335';
        }
      }
      
      // Show toast notification
      const toast = document.createElement('div');
      toast.style.cssText = 'position: fixed; top: 80px; right: 20px; background: ' + (isCorrect ? '#34A853' : '#EA4335') + 
                            '; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 10000; font-size: 14px; font-weight: 500;';
      toast.textContent = translateText('Feedback recorded for') + ' ' + modelName;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function ctxNotes(s) {
      return ['Visual-only analysis. Sensors removed.'];
    }

    async function loadSensors() {
      // Sensors removed - visual-only mode
      renderCtx(['Visual-only analysis. Sensors removed.']);
      return null;
    }

    // Display active models in the result box
    function displayActiveModels() {
      const modelsList = document.getElementById('modelsList');
      if (!modelsList) return;
      
      let html = '';
      MODELS.forEach((model, index) => {
        const typeIcon = model.type === 'detection' ? 'ЁЯОп' : 'ЁЯУК';
        const typeBadge = model.type === 'detection' ? translateText('Detection') : translateText('Classification');
        
        html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: var(--surface); border-radius: 6px; border: 1px solid rgba(26, 115, 232, 0.2);">';
        html += '<div style="display: flex; align-items: center; gap: 10px;">';
        html += '<span style="font-size: 20px;">' + typeIcon + '</span>';
        html += '<div>';
        html += '<div style="font-weight: 500; font-size: 13px; color: var(--on-surface);">' + translateText(model.name) + '</div>';
        html += '<div style="font-size: 11px; color: var(--on-surface-variant); margin-top: 2px;">' + translateText('Model:') + ' ' + model.id + '</div>';
        html += '</div>';
        html += '</div>';
        html += '<span style="padding: 4px 8px; background: rgba(26, 115, 232, 0.1); color: var(--primary); border-radius: 4px; font-size: 11px; font-weight: 600;">' + typeBadge + '</span>';
        html += '</div>';
      });
      
      modelsList.innerHTML = html;
    }
    
    // Initialize plant selector
    function initPlantSelector() {
      const selector = document.getElementById('plantSelector');
      if (!selector) return;
      
      let html = '';
      PLANT_TYPES.forEach(plant => {
        const isSelected = selectedPlantType === plant.id;
        html += '<button onclick="selectPlant(\'' + plant.id + '\')" style="';
        html += 'padding: 16px; border: 1px solid ' + (isSelected ? 'var(--primary)' : 'var(--outline-variant)') + ' !important; ';
        html += 'background: ' + (isSelected ? 'var(--primary-container)' : 'var(--surface)') + ' !important; ';
        html += 'border-radius: 16px !important; cursor: pointer; transition: all 0.2s; text-align: center;';
        html += '" id="plant_' + plant.id + '">';
        html += '<div style="font-size: 24px; margin-bottom: 4px;">' + plant.icon + '</div>';
        html += '<div style="font-size: 12px; font-weight: 600; color: var(--on-surface);">' + translateText(plant.name) + '</div>';
        html += '<div style="font-size: 10px; color: var(--on-surface-variant); margin-top: 2px;">' + plant.models + ' ' + translateText('models') + '</div>';
        html += '</button>';
      });
      
      selector.innerHTML = html;
    }
    
    // Select plant type
    function selectPlant(plantId) {
      selectedPlantType = plantId;
      
      // Update button styles
      PLANT_TYPES.forEach(plant => {
        const btn = document.getElementById('plant_' + plant.id);
        if (btn) {
          const isSelected = plant.id === plantId;
          btn.style.border = '1px solid ' + (isSelected ? 'var(--primary)' : 'var(--outline-variant)') + ' !important';
          btn.style.background = (isSelected ? 'var(--primary-container)' : 'var(--surface)') + ' !important';
        }
      });
      
      // Update info display
      const selectedPlant = PLANT_TYPES.find(p => p.id === plantId);
      if (selectedPlant) {
        document.getElementById('selectedPlantName').textContent = selectedPlant.icon + ' ' + translateText(selectedPlant.name);
        document.getElementById('selectedPlantDesc').textContent = translateText(selectedPlant.description);
      }
      
      console.log('\ud83c\udf31 Plant type selected:', plantId);
    }
    
    // Get filtered models based on selected plant
    function getActiveModels() {
      if (selectedPlantType === 'all') {
        return MODELS; // Return all models
      }
      
      // Filter models: include 'all' models + models specific to selected plant
      return MODELS.filter(model => {
        if (model.forPlants === 'all') return true; // General models always included
        if (Array.isArray(model.forPlants)) {
          return model.forPlants.includes(selectedPlantType);
        }
        return false;
      });
    }

    function showAnal() {
      const activeModels = getActiveModels();
      const plantInfo = PLANT_TYPES.find(p => p.id === selectedPlantType);
      const plantName = plantInfo ? plantInfo.icon + ' ' + translateText(plantInfo.name) : translateText('Plant');
      document.getElementById('res').innerHTML = '<div class="rc"><div class="t">' + translateText('Analyzing') + ' ' + plantName + ' ' + translateText('with') + ' ' + activeModels.length + ' ' + translateText('AI models') + '...</div><p style="color: var(--on-surface-variant); font-size: 14px;">' + translateText('Capturing and processing image') + '</p></div>';
    }

    function showMultiModelResults(results, s, imageBase64, consensusData) {
      const res = document.getElementById('res');
      
      // Generate unique analysis ID FIRST
      const analysisId = 'analysis_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
      
      // Context/sensors removed - record visual-only analysis
      const envContext = null;
      logAnalysis(results, null, null, imageBase64, analysisId);
      
      // Build comparison table
      let html = '<div class="rc">';
      html += '<div class="t">' + translateText('Multi-Model Analysis') + '</div>';
      
      // CAPTURED IMAGE DISPLAY
      if (imageBase64) {
        html += '<div style="background:var(--surface); border:2px solid var(--outline); padding:16px; margin:12px 0; border-radius:8px; text-align:center;">';
        html += '<div style="font-weight:600; margin-bottom:12px; color:var(--primary); font-size:16px;">ЁЯУ╕ ' + translateText('Captured Image') + '</div>';
        html += '<img src="data:image/jpeg;base64,' + imageBase64 + '" style="max-width:100%; max-height:400px; border-radius:8px; box-shadow:var(--elevation-2);" alt="Captured plant image">';
        html += '<div style="font-size:12px; color:var(--on-surface-variant); margin-top:8px;">' + translateText('Image saved to Firebase Firestore') + '</div>';
        html += '</div>';
      }
      
      // CONSENSUS DECISION BOX
      if (consensusData && consensusData.note) {
        const isDisease = consensusData.disease && consensusData.disease.toLowerCase() !== 'healthy';
        const boxColor = isDisease ? '#EA4335' : '#34A853';
        const icon = isDisease ? 'ЁЯФ┤' : 'ЁЯЯв';
        
        html += '<div style="background:' + boxColor + '15; border:2px solid ' + boxColor + '; padding:16px; margin:12px 0; border-radius:8px;">';
        html += '<div style="font-weight:600; margin-bottom:8px; color:' + boxColor + '; font-size:16px;">';
        html += icon + ' ' + translateText('Smart Consensus Decision') + '</div>';
        html += '<div style="font-size:14px; color:var(--on-surface); margin-bottom:8px;">';
        html += '<strong>' + translateText('Final Verdict:') + '</strong> ' + translateText(consensusData.disease) + ' (' + consensusData.confidence.toFixed(1) + '% ' + translateText('Confidence') + ')';
        html += '</div>';
        html += '<div style="font-size:13px; color:var(--on-surface-variant); line-height:1.5;">' + consensusData.note + '</div>';
        html += '</div>';
      }
      
      // Environmental Context Alert
      if (envContext && envContext.severity !== 'low') {
        const severityColors = { moderate: '#FBBC04', high: '#FF9800', critical: '#EA4335' };
        const severityColor = severityColors[envContext.severity] || '#5f6368';
        
        html += '<div style="background:' + severityColor + '20; border-left:4px solid ' + severityColor + '; padding:16px; margin:12px 0; border-radius:8px;">';
        html += '<div style="font-weight:600; margin-bottom:8px; color:' + severityColor + '; font-size:15px;">';
        html += 'тЪая╕П Environmental Risk: ' + envContext.severity.toUpperCase() + ' (Score: ' + envContext.severityScore + '/10)</div>';
        
        if (envContext.riskFactors.length > 0) {
          html += '<div style="margin-bottom:10px;"><strong style="color:var(--on-surface);">Risk Factors:</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px; color:var(--on-surface);">';
          envContext.riskFactors.forEach(r => html += '<li>' + r + '</li>');
          html += '</ul></div>';
        }
        
        if (envContext.recommendations.length > 0) {
          html += '<div><strong style="color:var(--on-surface);">Immediate Actions:</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px; color:var(--on-surface);">';
          envContext.recommendations.forEach(r => html += '<li>' + r + '</li>');
          html += '</ul></div>';
        }
        
        html += '</div>';
      }
      
      // Gemini Recommendation (if available)
      if (geminiRecommendation) {
        html += '<div style="background:rgba(26,115,232,0.1); border-left:3px solid var(--primary); padding:16px; margin:12px 0; border-radius:8px;">';
        html += '<div style="font-weight:600; margin-bottom:12px; color:var(--primary); font-size:15px;">ЁЯдЦ AI Expert Recommendation</div>';
        
        // Check if it's an error object
        if (geminiRecommendation.error) {
          html += '<div style="background:#fef7e0; border:1px solid #f9ab00; padding:12px; border-radius:6px; color:#ea8600; font-size:14px;">';
          html += 'тЪая╕П ' + geminiRecommendation.error;
          html += '<br><span style="font-size:12px; color:#5f6368;">Showing results from 4 AI models below.</span>';
          html += '</div>';
        } else if (typeof geminiRecommendation === 'object') {
          // Structured JSON response
          if (geminiRecommendation.disease_explanation) {
            html += '<div style="margin-bottom:10px;"><strong>ЁЯУЛ ' + gl('diseaseExplanation') + '</strong><br>';
            html += '<span style="font-size:13px; line-height:1.6;">' + geminiRecommendation.disease_explanation + '</span></div>';
          }
          
          if (geminiRecommendation.severity) {
            const severityColors = { mild: '#34a853', moderate: '#fbbc04', severe: '#ea4335' };
            const severityColor = severityColors[geminiRecommendation.severity.toLowerCase()] || '#5f6368';
            html += '<div style="margin-bottom:10px;"><strong>тЪая╕П ' + gl('severity') + '</strong> ';
            html += '<span style="padding:4px 8px; background:' + severityColor + '20; color:' + severityColor + '; border-radius:4px; font-weight:600; text-transform:uppercase; font-size:12px;">' + geminiRecommendation.severity + '</span></div>';
          }
          
          if (geminiRecommendation.preventive_measures && geminiRecommendation.preventive_measures.length > 0) {
            html += '<div style="margin-bottom:10px;"><strong>ЁЯЫбя╕П ' + gl('preventiveMeasures') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
            geminiRecommendation.preventive_measures.forEach(m => html += '<li>' + m + '</li>');
            html += '</ul></div>';
          }
          
          if (geminiRecommendation.organic_treatment && geminiRecommendation.organic_treatment.length > 0) {
            html += '<div style="margin-bottom:10px;"><strong>ЁЯМ┐ ' + gl('organicTreatment') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
            geminiRecommendation.organic_treatment.forEach(t => html += '<li>' + t + '</li>');
            html += '</ul></div>';
          }
          
          if (geminiRecommendation.chemical_treatment && geminiRecommendation.chemical_treatment.length > 0) {
            html += '<div style="margin-bottom:10px;"><strong>тЪЧя╕П ' + gl('chemicalTreatment') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
            geminiRecommendation.chemical_treatment.forEach(t => html += '<li>' + t + '</li>');
            html += '</ul></div>';
          }
          
          if (geminiRecommendation.risk_of_crop_loss) {
            html += '<div style="margin-bottom:6px;"><strong>ЁЯУК ' + gl('riskOfCropLoss') + '</strong><br>';
            html += '<span style="font-size:13px; line-height:1.6; color:#ea4335;">' + geminiRecommendation.risk_of_crop_loss + '</span></div>';
          }
        } else {
          // Fallback for plain text response
          html += '<div style="white-space:pre-wrap; font-size:13px; line-height:1.6;">' + geminiRecommendation + '</div>';
        }
        
        html += '</div>';
      }
      
      // Add model vote summary before the table
      if (consensusData && (consensusData.diseaseCount > 0 || consensusData.healthyCount > 0)) {
        html += '<div style="display: flex; gap: 12px; margin: 16px 0; flex-wrap: wrap;">';
        
        if (consensusData.diseaseCount > 0) {
          html += '<div style="flex: 1; min-width: 150px; background: rgba(234, 67, 53, 0.1); border-left: 3px solid #EA4335; padding: 12px; border-radius: 6px;">';
          html += '<div style="font-size: 24px; font-weight: 700; color: #EA4335;">' + consensusData.diseaseCount + '</div>';
          html += '<div style="font-size: 12px; color: var(--on-surface-variant);">' + translateText('Model(s) Detected Disease') + '</div>';
          html += '</div>';
        }
        
        if (consensusData.healthyCount > 0) {
          html += '<div style="flex: 1; min-width: 150px; background: rgba(52, 168, 83, 0.1); border-left: 3px solid #34A853; padding: 12px; border-radius: 6px;">';
          html += '<div style="font-size: 24px; font-weight: 700; color: #34A853;">' + consensusData.healthyCount + '</div>';
          html += '<div style="font-size: 12px; color: var(--on-surface-variant);">' + translateText('Model(s) Said Healthy') + '</div>';
          html += '</div>';
        }
        
        html += '</div>';
      }
      
      html += '<div style="overflow-x:auto; margin-top:16px;">';
      html += '<table class="results-table" style="width:100%; border-collapse:collapse; font-size:14px;">';
      html += '<thead><tr style="border-bottom:2px solid var(--on-surface-variant);">';
      html += '<th style="text-align:left; padding:12px; color:var(--on-surface-variant); min-width:180px;">' + translateText('Model') + '</th>';
      html += '<th style="text-align:left; padding:12px; color:var(--on-surface-variant); min-width:200px;">' + translateText('Disease Detected') + '</th>';
      html += '<th style="text-align:right; padding:12px; color:var(--on-surface-variant); min-width:120px;">' + translateText('Confidence') + '</th>';
      html += '<th style="text-align:left; padding:12px; color:var(--on-surface-variant); min-width:350px;">' + translateText('Recommended Treatment') + '</th>';
      html += '<th style="text-align:center; padding:12px; color:var(--on-surface-variant); min-width:140px;">' + translateText('Your Feedback') + '</th>';
      html += '</tr></thead><tbody>';
      
      results.forEach((r, index) => {
        let rowClass = '';
        let badge = '';
        let conf = 0;
        let disease = 'No detection';
        let rawDisease = null;
        let isHealthy = false;
        let isDisease = false;
        
        if (r.error) {
          badge = '<span class="badge err">' + translateText('Error') + '</span>';
          disease = r.error;
        } else if (r.type === 'detection') {
          if (r.data.predictions && r.data.predictions.length > 0) {
            const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
            disease = top.class;
            rawDisease = disease;
            conf = (top.confidence * 100).toFixed(1);
            
            // Handle numeric class IDs or invalid names
            if (!disease || disease === '' || /^\d+$/.test(disease)) {
              console.warn(r.name + ' returned invalid class:', disease, 'Full prediction:', top);
              disease = translateText('Unknown Disease') + ' (ID: ' + disease + ')';
              badge = '<span class="badge warn">тЪая╕П ' + translateText('Invalid') + '</span>';
              isDisease = true;
            }
            // Check if this is a healthy classification
            else if (disease.toLowerCase().trim() === 'healthy') {
              isHealthy = true;
              badge = '<span class="badge ok">' + translateText('Healthy') + '</span>';
              disease = translateText('Healthy');
            } else {
              isDisease = true;
              badge = conf >= 80 ? '<span class="badge err">' + translateText('High') + '</span>' : conf >= 50 ? '<span class="badge warn">' + translateText('Medium') + '</span>' : '<span class="badge ok">' + translateText('Low') + '</span>';
              disease = translateText(disease);
            }
          } else {
            disease = translateText('Healthy');
            isHealthy = true;
            badge = '<span class="badge ok">' + translateText('Healthy') + '</span>';
          }
        } else if (r.type === 'classification') {
          if (r.data.top || r.data.predicted_classes) {
            disease = r.data.top || (r.data.predicted_classes && r.data.predicted_classes[0]) || 'Unknown';
            rawDisease = disease;
            conf = ((r.data.confidence || 0) * 100).toFixed(1);
            
            // Check if this is a healthy classification
            if (disease.toLowerCase().trim() === 'healthy' || disease.toLowerCase().trim() === 'no detection') {
              isHealthy = true;
              badge = '<span class="badge ok">' + translateText('Healthy') + '</span>';
              disease = translateText('Healthy');
            } else {
              isDisease = true;
              badge = conf >= 80 ? '<span class="badge err">' + translateText('High') + '</span>' : conf >= 50 ? '<span class="badge warn">' + translateText('Medium') + '</span>' : '<span class="badge ok">' + translateText('Low') + '</span>';
              disease = translateText(disease);
            }
          } else {
            disease = translateText('Healthy');
            isHealthy = true;
            badge = '<span class="badge ok">' + translateText('Healthy') + '</span>';
          }
        }
        
        const remedy = getRemedy(rawDisease || disease);
        
        // Calculate context-aware severity
        const severityAssessment = assessDiseaseSeverity(disease, conf, envContext);
        const urgencyColors = {
          'immediate': '#EA4335',
          'immediate - remove infected plants': '#B71C1C',
          'within 24-48 hours': '#FF9800',
          'within 24 hours': '#FF9800',
          'within 1 week': '#FBBC04',
          'routine': '#34A853'
        };
        const urgencyColor = urgencyColors[severityAssessment.treatmentUrgency] || '#5f6368';
        
        // Highlight row based on detection type
        let rowStyle = 'border-bottom:1px solid rgba(255,255,255,0.05);';
        if (isDisease) {
          rowStyle += ' background: rgba(234, 67, 53, 0.08);'; // Highlight disease detections
        } else if (isHealthy) {
          rowStyle += ' background: rgba(52, 168, 83, 0.05); opacity: 0.7;'; // Dim healthy detections
        }
        
        html += '<tr style="' + rowStyle + '">';
        html += '<td style="padding:16px 12px; font-weight:500; vertical-align:top;">';
        
        // Add icon to indicate disease vs healthy
        if (isDisease) {
          html += 'ЁЯФ┤ ';
        } else if (isHealthy) {
          html += 'ЁЯЯв ';
        }
        
        html += r.name + '</td>';
        html += '<td style="padding:16px 12px; vertical-align:top;">' + disease + ' ' + badge;
        
        // Add severity and urgency indicators
        if (disease !== 'Healthy' && !r.error) {
          html += '<br><span style="font-size:11px; margin-top:4px; display:inline-block;">';
          html += '<span style="background:' + urgencyColor + '20; color:' + urgencyColor + '; padding:2px 6px; border-radius:3px; margin-right:4px;">ЁЯЪи ' + translateText(severityAssessment.treatmentUrgency) + '</span>';
          html += '<span style="background:rgba(255,255,255,0.1); color:var(--on-surface-variant); padding:2px 6px; border-radius:3px;">ЁЯУК ' + translateText(severityAssessment.severity) + ' ' + translateText('severity') + '</span>';
          html += '</span>';
        }
        
        html += '</td>';
        html += '<td style="padding:16px 12px; text-align:right; font-weight:600; vertical-align:top;">' + (conf || '-') + (conf ? '%' : '') + '</td>';
        html += '<td style="padding:16px 12px; font-size:13px; line-height:1.6; color:var(--on-surface-variant); vertical-align:top;">' + remedy + '</td>';
        
        // Add feedback buttons
        const feedbackId = analysisId + '_' + index;
        html += '<td style="padding:16px 12px; text-align:center; vertical-align:top;">';
        html += '<div style="display: flex; gap: 8px; justify-content: center; align-items: center;">';
        html += '<button onclick="handleModelFeedback(\'' + analysisId + '\', \'' + r.name + '\', true, \'' + feedbackId + '\')" ';
        html += 'id="correct_' + feedbackId + '" ';
        html += 'style="padding: 6px 12px; border: 2px solid #34A853; background: transparent; color: #34A853; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s;" ';
        html += 'onmouseover="this.style.background=\'#34A853\'; this.style.color=\'white\';" ';
        html += 'onmouseout="this.style.background=\'transparent\'; this.style.color=\'#34A853\';">';
        html += 'тЬУ ' + translateText('Correct') + '</button>';
        html += '<button onclick="handleModelFeedback(\'' + analysisId + '\', \'' + r.name + '\', false, \'' + feedbackId + '\')" ';
        html += 'id="wrong_' + feedbackId + '" ';
        html += 'style="padding: 6px 12px; border: 2px solid #EA4335; background: transparent; color: #EA4335; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s;" ';
        html += 'onmouseover="this.style.background=\'#EA4335\'; this.style.color=\'white\';" ';
        html += 'onmouseout="this.style.background=\'transparent\'; this.style.color=\'#EA4335\';">';
        html += 'тЬЧ ' + translateText('Wrong') + '</button>';
        html += '</div>';
        html += '<div id="feedback_status_' + feedbackId + '" style="font-size: 11px; margin-top: 4px; color: var(--on-surface-variant);"></div>';
        html += '</td>';
        html += '</tr>';
      });
      
      html += '</tbody></table>';
      html += '</div>';
      html += '<p style="color: var(--on-surface-variant); font-size: 12px; margin-top: 12px;">тЪая╕П Remedies are general guidelines. Consult agricultural expert for specific cases.</p>';
      html += '</div>';
      
      res.innerHTML = html;

      // Add data-labels to table cells for responsive view
      const table = res.querySelector('.results-table');
      if (table) {
        const headers = Array.from(table.querySelectorAll('thead th')).map(th => th.textContent);
        table.querySelectorAll('tbody tr').forEach(row => {
          row.querySelectorAll('td').forEach((td, i) => {
            td.setAttribute('data-label', headers[i]);
          });
        });
      }
      
      renderCtx(['Visual-only analysis. Sensors removed.']);
    }

    async function runAnalysis(withSensors) {
      const btn = withSensors ? document.getElementById('fullBtn') : document.getElementById('visualBtn');
      if (!btn) {
        console.error('Button not found:', withSensors ? 'fullBtn' : 'visualBtn');
        return;
      }
      btn.disabled = true;
      const origText = btn.textContent;
      btn.textContent = translateText('Analyzing...');
      showAnal();
      
      // Pause stream to free ESP32 resources
      const wasStreaming = streamActive;
      if (wasStreaming) {
        console.log('Stopping stream before capture...');
        toggleStream();
        console.log('Waiting 2 seconds for ESP32 camera to be released...');
        await new Promise(resolve => setTimeout(resolve, 2000)); // Wait longer for stream to fully stop
        console.log('Stream stopped, ready to capture');
      }
      
      try {
        console.log('Step 1: Triggering capture...');
        console.log('Capture URL:', api('/capture'));
        const captureResp = await fetchWithTimeout(api('/capture'), {}, 30000);
        console.log('Capture response:', captureResp.status, captureResp.statusText);
        const captureText = await captureResp.text();
        console.log('Capture body:', captureText);
        if (!captureResp.ok) throw Error('Capture failed: ' + captureResp.status + ' ' + captureResp.statusText + ' - ' + captureText);
        
        // Sensors removed; proceed with visual-only capture
        const s = null;
        
        console.log('Step 3: Fetching captured image...');
        console.log('Image URL:', api('/capture.jpg'));
        const imgR = await fetchWithTimeout(api('/capture.jpg'), {}, 20000);
        console.log('Image response:', imgR.status, imgR.statusText);
        if (!imgR.ok) throw Error('Image HTTP ' + imgR.status);
        
        console.log('Step 4: Converting to blob...');
        const blob = await imgR.blob();
        console.log('Blob size:', blob.size, 'bytes');
        
        const reader = new FileReader();
        reader.onloadend = async function() {
          console.log('Step 5: Converting to base64...');
          const b64 = reader.result.split(',')[1];
          console.log('Base64 length:', b64.length);
          
          // Get filtered models based on selected plant
          const activeModels = getActiveModels();
          console.log('Step 6: Running ' + activeModels.length + ' models for ' + selectedPlantType + '...');
          console.log('Active models:', activeModels.map(m => m.name));
          
          // Run active models simultaneously
          const modelPromises = activeModels.map(model => infer(b64, model));
          
          try {
            const results = await Promise.all(modelPromises);
            console.log('All models completed:', results);
            
            const consensusData = calculateConsensus(results);
            
            // Skip legacy Gemini API call
            geminiRecommendation = null;
            
            // Show results with captured image
            showMultiModelResults(results, s, b64, consensusData);
            
            // Trigger Firebase AI verification if enabled (pass all model results)
            if (aiAnalysisEnabled && aiEnabled) {
              triggerAIAnalysis(results, b64, s);
            }
          } catch (e) {
            console.error('Multi-model error:', e);
            document.getElementById('res').innerHTML = '<div class="rc"><div class="t">API error<span class="badge warn">Retry</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">' + e.message + '</p></div>';
            renderCtx(ctxNotes(s));
          } finally {
            btn.disabled = false;
            btn.textContent = origText;
            // Resume stream if it was active
            if (wasStreaming && !streamActive) {
              setTimeout(() => toggleStream(), 500);
            } else if (streamActive) {
              // Refresh stream to recover from capture interruption
              const streamImg = document.getElementById('str');
              streamImg.src = api('/stream') + '?t=' + Date.now();
            }
          }
        };
        reader.readAsDataURL(blob);
      } catch (e) {
        console.error('Capture error:', e);
        document.getElementById('res').innerHTML = '<div class="rc"><div class="t">Failed<span class="badge err">Error</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">' + e.message + '</p></div>';
        renderCtx(['Capture failed']);
        btn.disabled = false;
        btn.textContent = origText;
        // Resume stream if it was active
        if (wasStreaming && !streamActive) {
          setTimeout(() => toggleStream(), 500);
        } else if (streamActive) {
          // Refresh stream to recover from capture interruption
          const streamImg = document.getElementById('str');
          streamImg.src = api('/stream') + '?t=' + Date.now();
        }
      }
    }

    function analyze() {
      // Full/sensor-based analysis removed тАФ run visual-only analysis
      runAnalysis(false);
    }

    function visualOnly() {
      runAnalysis(false);
    }

    // Sensors removed тАФ no automatic polling (visual-only mode)
    
    // Load analytics on page load (async from Firebase)
    (async function initializeAnalytics() {
      await loadAnalytics();
      // updateAnalyticsDashboard is now called inside loadAnalytics after data loads
    })();
    
    // Display active models on page load
    displayActiveModels();
    
    // Initialize plant selector on page load
    initPlantSelector();
    
    // Auto-load saved IP or use default, then auto-connect
    window.addEventListener('DOMContentLoaded', function() {
      const savedIP = localStorage.getItem('esp32_ip');
      
      // Auto-migrate old 192.168.1.33 IP to new 10.180.248.33
      // This migration is disabled by default to preserve direct-access AP IPs (e.g. ESP32 default)
      if (ALLOW_AUTO_IP_MIGRATION && savedIP && savedIP.includes('192.168.1.33')) {
        localStorage.setItem('esp32_ip', 'http://10.180.248.33');
        log.info('ЁЯФД Migrated IP from 192.168.1.33 to 10.180.248.33');
      }
      
      const currentIP = localStorage.getItem('esp32_ip') || 'http://10.180.248.33';
      const ipOnly = currentIP.replace('http://', '').replace('https://', '');
      document.getElementById('ipInput').value = ipOnly;
      
      // Ensure BASE_URL is set
      BASE_URL = currentIP;
      
      // Auto-connect after 500ms delay
      setTimeout(() => {
        const ipValue = document.getElementById('ipInput').value;
        if (ipValue) {
          log.info('Auto-connecting to:', ipValue);
          setIP();
        }
      }, 500);
      
      // Load from Firebase after local data (if Firebase is configured)
      // Wait for Firebase to be ready before trying to load
      if (firebaseReadyPromise) {
        firebaseReadyPromise.then(() => {
          if (firebaseReady && firebaseEnabled) {
            setTimeout(() => {
              console.log('Auto-loading from Firebase...');
              loadFromFirebase(false).catch(err => {
                console.log('Auto-load from Firebase skipped:', err.message);
              });
            }, 500);
          }
        }).catch(err => {
          console.log('Firebase not available for auto-load');
        });
      }
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.js" type="text/javascript"></script>
  <!-- language.js removed (not provided). If you need localization, add language.js back into the web root. -->
  <script>
    // ========== MQTT Configuration ==========
    const mqtt_broker = 'test.mosquitto.org';
    // Use secure websocket (WSS) when page is served over HTTPS to avoid Mixed Content
    const pageIsSecure = location.protocol === 'https:';
    const mqtt_port = pageIsSecure ? 8081 : 8080; // 8081 => wss, 8080 => ws
    const mqtt_path = '/mqtt';
    const mqtt_use_ssl = pageIsSecure;
    const mqtt_client_id = 'WebAppClient_' + Math.random().toString(16).substr(2, 8);
    const sensor_topic = 'esp32/cam/sensors';
    const command_topic = 'esp32/cam/command';

    let pumpOn = false;

    // Client variable will be created by the connect routine below
    let client = null;

    // Attempt to connect to an MQTT broker with optional fallback
    function tryConnect(brokerHost, port, path, useSSL, attemptFallback = true) {
      console.log('MQTT connecting to', (useSSL ? 'wss' : 'ws') + '://' + brokerHost + ':' + port + path);

      // (re)create client for this connection attempt
      client = new Paho.MQTT.Client(brokerHost, Number(port), path, mqtt_client_id);
      client.onConnectionLost = onConnectionLost;
      client.onMessageArrived = onMessageArrived;

      client.connect({
        onSuccess: onConnect,
        onFailure: function(err) {
          console.error('MQTT connect failed', err);
          // If this was a WSS attempt and fallback is allowed, try a known public WSS broker
          if (useSSL && attemptFallback) {
            console.log('Attempting fallback WSS broker: broker.emqx.io:8084');
            tryConnect('broker.emqx.io', 8084, '/mqtt', true, false);
          }
        },
        useSSL: useSSL
      });
    }

    // Start initial connect (use WSS on HTTPS pages)
    tryConnect(mqtt_broker, mqtt_port, mqtt_path, mqtt_use_ssl);

    function onConnect() {
      console.log("Connected to MQTT broker");
      client.subscribe(sensor_topic);
      // Also subscribe to status topic to receive acks from ESP
      client.subscribe('esp32/cam/status');
      document.getElementById('mqttDot').classList.remove('offline');
      // document.getElementById('mqttStatus').textContent = 'Online';
    }

    function onConnectionLost(responseObject) {
      if (responseObject.errorCode !== 0) {
        console.log("onConnectionLost:" + responseObject.errorMessage);
        // Maybe try to reconnect here
      }
    }

    function onMessageArrived(message) {
      const payload = message.payloadString;
      // Try JSON sensor update first
      if (payload && payload[0] === '{') {
        try {
          const data = JSON.parse(payload);
          if (data.temperature !== undefined) document.getElementById('temperature').innerText = parseFloat(data.temperature).toFixed(1);
          if (data.humidity !== undefined) document.getElementById('humidity').innerText = parseFloat(data.humidity).toFixed(1);
          if (data.soilMoisture !== undefined) document.getElementById('soilMoisture').innerText = data.soilMoisture;

          const arduinoDot = document.getElementById('arduinoDot');
          const arduinoStatus = document.getElementById('arduinoStatus');
          if (data.arduinoConnected) {
            arduinoDot.classList.remove('offline');
            arduinoStatus.innerText = translateText('Connected');
          } else {
            arduinoDot.classList.add('offline');
            arduinoStatus.innerText = translateText('Not Connected');
          }
        } catch (e) {
          console.error("Error parsing MQTT JSON message:", e, payload);
        }
        return;
      }

      // Handle plain-text control/status messages
      console.log("MQTT message (text) arrived:", payload);
      if (payload.indexOf('PUMP_ON') !== -1) {
        console.log('ESP acknowledged PUMP_ON');
      } else if (payload.indexOf('PUMP_OFF') !== -1) {
        console.log('ESP acknowledged PUMP_OFF');
      }
    }

    function togglePump() {
      const newState = pumpOn ? 'off' : 'on';
      const command = newState === 'on' ? 'PUMP_ON' : 'PUMP_OFF';
      
      const message = new Paho.MQTT.Message(command);
      message.destinationName = command_topic;
      console.log('Publishing pump command:', command, 'to', command_topic);
      client.send(message);

      pumpOn = !pumpOn;
      document.getElementById('pumpBtn').innerText = pumpOn ? 'Deactivate Pump' : 'Activate Pump';
    }
  </script>
</body>

</html>
