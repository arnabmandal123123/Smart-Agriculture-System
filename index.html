<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="theme-color" content="#1a73e8">
  <meta name="description"
    content="Professional ESP32-CAM agricultural disease detection system with AI verification, 10-model consensus analysis, and real-time sensor monitoring.">
  <meta name="keywords"
    content="agriculture, plant disease detection, ESP32-CAM, AI, machine learning, crop health monitoring">
  <meta name="author" content="Smart Agricultural System">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600&display=swap"
    rel="stylesheet">
  <link
    href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200"
    rel="stylesheet" />
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Firebase SDK - Using Firestore for all data storage -->
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-functions-compat.js"></script>
  <style>
    :root {
      /* Transparent Green Glass Theme */
      /* Primary: Vibrant Lime for accents/active states */
      --primary: #84cc16;
      --primary-hover: #65a30d;
      --primary-container: rgba(132, 204, 22, 0.2);
      --on-primary: #ffffff;

      /* Secondary: Darker Forest for depth */
      --secondary: #14532d;
      --secondary-container: rgba(20, 83, 45, 0.3);

      /* Glass Surfaces — increased opacity for readability */
      --surface: rgba(15, 30, 22, 0.78);
      --surface-glass: rgba(15, 30, 22, 0.82);
      --surface-container: rgba(0, 0, 0, 0.35);
      --surface-container-high: rgba(0, 0, 0, 0.45);

      /* Text Colors - All Light for Dark Theme */
      --on-surface: #f0fdf4;
      --on-surface-variant: rgba(255, 255, 255, 0.75);

      /* Borders & Outlines */
      --outline: rgba(255, 255, 255, 0.15);
      --outline-variant: rgba(255, 255, 255, 0.08);

      --error: #ef4444;
      --error-container: rgba(239, 68, 68, 0.2);
      --success: #10b981;
      --warn: #f59e0b;

      /* Shadows — stronger for glass cards */
      --elevation-1: 0 4px 20px rgba(0, 0, 0, 0.25);
      --elevation-2: 0 8px 32px rgba(0, 0, 0, 0.35);

      --radius: 20px;
      --radius-sm: 12px;

      --font-display: 'Outfit', sans-serif;
      --font-body: 'Inter', sans-serif;

      --transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);

      /* Specifics */
      --nav-bg: rgba(10, 20, 10, 0.75);
      --nav-blur: blur(20px);

      --widget-bg: linear-gradient(135deg, rgba(20, 83, 45, 0.8) 0%, rgba(22, 101, 52, 0.6) 100%);
      --on-widget: #ffffff;
      --on-widget-variant: rgba(255, 255, 255, 0.75);
    }

    /* Material Symbols */
    .material-symbols-rounded {
      font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
      font-size: 24px;
      line-height: 1;
      display: inline-block;
      vertical-align: middle;
    }

    [data-theme="light"] {
      /* Force Dark Glass Theme regardless of system setting for now as requested */
      /* To revert, copy variables back. For this task, we want strict adherence to the dark glass look */
      --elevation-1: 0 4px 6px -1px rgba(20, 83, 45, 0.05);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      overflow-x: hidden;
      /* Prevent horizontal scroll */
      font-family: var(--font-body);
      /* Global Background Image */
      background: url('ui_background.png') center/cover fixed no-repeat;
      color: var(--on-surface);
      padding: 16px;
      padding-bottom: 100px;
      /* Space for fixed nav */
      min-height: 100vh;
      -webkit-font-smoothing: antialiased;
      line-height: 1.6;
    }

    /* Landing Page Overlay */
    .landing-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 24px;
      padding-top: 15vh;
      overflow: hidden;
    }

    /* Ken Burns background zoom */
    .landing-overlay::before {
      content: '';
      position: absolute;
      inset: -10%;
      background: url('starting_page.jpg') center/cover no-repeat;
      animation: kenBurns 20s ease-in-out infinite alternate;
      z-index: 0;
    }

    /* Gradient overlay */
    .landing-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(to top, rgba(0, 0, 0, 0.85) 0%, rgba(0, 0, 0, 0.4) 40%, transparent 100%);
      z-index: 1;
    }

    @keyframes kenBurns {
      0% {
        transform: scale(1) translate(0, 0);
      }

      100% {
        transform: scale(1.1) translate(-2%, -1%);
      }
    }

    /* Landing content animations */
    .landing-content {
      position: relative;
      z-index: 2;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding-bottom: 20px;
    }

    .landing-title {
      font-family: var(--font-display);
      font-size: clamp(32px, 10vw, 52px);
      font-weight: 800;
      line-height: 1.05;
      margin-bottom: 12px;
      text-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      color: #fff;
      opacity: 0;
      transform: translateY(40px);
      animation: landingSlideUp 0.9s cubic-bezier(0.16, 1, 0.3, 1) 0.3s forwards;
    }

    .landing-subtitle {
      font-size: clamp(13px, 3.5vw, 16px);
      opacity: 0;
      color: rgba(255, 255, 255, 0.9);
      margin-bottom: 28px;
      max-width: 340px;
      line-height: 1.6;
      font-weight: 400;
      transform: translateY(30px);
      animation: landingSlideUp 0.8s cubic-bezier(0.16, 1, 0.3, 1) 0.6s forwards;
    }

    .landing-btn {
      background: #84cc16;
      color: #1a2e05;
      border: none;
      padding: 14px 28px;
      border-radius: 50px;
      font-size: clamp(14px, 3.5vw, 16px);
      font-weight: 700;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 10px 30px rgba(132, 204, 22, 0.35);
      transition: transform 0.25s, box-shadow 0.25s;
      opacity: 0;
      transform: translateY(25px);
      animation: landingSlideUp 0.7s cubic-bezier(0.16, 1, 0.3, 1) 0.9s forwards;
    }

    .landing-btn:hover {
      transform: translateY(-2px) scale(1.03);
      box-shadow: 0 14px 36px rgba(132, 204, 22, 0.45);
    }

    .landing-btn:active {
      transform: scale(0.97);
    }

    /* Floating brand badge */
    .landing-badge {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      z-index: 2;
      padding: 28px 24px;
      display: flex;
      align-items: center;
      gap: 12px;
      opacity: 0;
      transform: translateY(-20px);
      animation: landingFadeDown 0.8s cubic-bezier(0.16, 1, 0.3, 1) 0.15s forwards;
    }

    .landing-badge-dot {
      width: 9px;
      height: 9px;
      background: #84cc16;
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(132, 204, 22, 0.6);
      animation: pulse 2.5s ease-in-out infinite;
      flex-shrink: 0;
    }

    .landing-badge-text {
      font-family: var(--font-display);
      font-size: clamp(26px, 6.5vw, 38px);
      font-weight: 700;
      color: #ffffff;
      letter-spacing: -0.3px;
      text-shadow: 0 2px 12px rgba(0, 0, 0, 0.4);
    }

    @keyframes landingSlideUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes landingFadeDown {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
        transform: scale(1);
      }

      50% {
        opacity: 0.5;
        transform: scale(1.3);
      }
    }

    /* Mobile adjustments for landing */
    @media (max-width: 480px) {
      .landing-overlay {
        padding: 16px;
      }

      .landing-content {
        padding-bottom: 16px;
      }

      .landing-badge {
        padding: 14px 16px;
      }

      /* Hero Card Compact (Max) */
      .hero {
        min-height: auto !important;
      }

      .hero-content {
        padding: 8px 12px !important;
        gap: 6px;
        min-height: 60px;
      }

      .hero h1 {
        font-size: 20px !important;
        margin-bottom: 0 !important;
        line-height: 1.2;
      }

      .hero-label {
        font-size: 8px !important;
        margin-bottom: 2px !important;
        letter-spacing: 1px;
      }

      .hero-icon-ring {
        width: 40px !important;
        height: 40px !important;
      }

      /* Tighter card spacing on mobile */
      .card {
        padding: 16px;
      }

      .sec-card {
        padding: 12px;
      }

      /* Compact Nav for small screens */
      .nav-item {
        padding: 6px 2px;
        min-width: 0;
        /* Allow shrinking */
      }

      .nav-item .material-symbols-rounded {
        font-size: 20px;
      }

      .nav-item span.label {
        font-size: 9px;
        letter-spacing: 0;
      }

      /* Header wrapping for small screens */
      .head {
        flex-wrap: wrap;
        gap: 8px;
      }

      /* Scrollable filter chips */
      .filter-group {
        overflow-x: auto;
        white-space: nowrap;
        max-width: 100%;
        padding-bottom: 4px;
        -webkit-overflow-scrolling: touch;
        scrollbar-width: none;
        /* Firefox */
      }

      .filter-group::-webkit-scrollbar {
        display: none;
        /* Chrome/Safari */
      }
    }

    @media (max-height: 600px) {
      .landing-title {
        font-size: clamp(26px, 8vw, 36px);
        margin-bottom: 8px;
      }

      .landing-subtitle {
        margin-bottom: 18px;
      }

      .landing-btn {
        padding: 12px 24px;
      }
    }

    .wrap {
      max-width: 1200px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 28px;
      animation: fadeIn 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
      /* perspective removed — it creates a containing block that breaks position:fixed on the nav */
      padding-bottom: 100px;
      /* Account for fixed nav */
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    /* Landing Page Styles */
    #landingPage {
      transition: opacity 0.8s ease-in-out, visibility 0.8s;
    }

    #landingPage.fade-out {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    /* Hero Section */
    .hero {
      border-radius: var(--radius);
      padding: 0;
      color: white;
      box-shadow: var(--elevation-2);
      position: relative;
      overflow: hidden;
      border: 1px solid var(--outline);
      transition: transform 0.3s ease, box-shadow 0.3s ease;
      min-height: 180px;
    }

    /* Hero background image with Ken Burns */
    .hero::before {
      content: '';
      position: absolute;
      inset: -8%;
      background: url('hero_card.jpg') center/cover no-repeat;
      animation: heroKenBurns 25s ease-in-out infinite alternate;
      z-index: 0;
    }

    /* Hero gradient overlay */
    .hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(5, 15, 8, 0.82) 0%, rgba(10, 30, 15, 0.65) 50%, rgba(5, 20, 10, 0.78) 100%);
      z-index: 1;
    }

    @keyframes heroKenBurns {
      0% {
        transform: scale(1) translate(0, 0);
      }

      100% {
        transform: scale(1.12) translate(-3%, -2%);
      }
    }

    .hero-content {
      position: relative;
      z-index: 2;
      padding: 32px 28px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
    }

    .hero-text {
      flex: 1;
    }

    .hero-label {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 2.5px;
      color: var(--primary);
      margin-bottom: 6px;
      opacity: 0;
      transform: translateY(12px);
      animation: heroFadeUp 0.6s ease 0.2s forwards;
    }

    .hero h1 {
      font-family: var(--font-display);
      font-size: clamp(28px, 7vw, 38px);
      font-weight: 800;
      margin-bottom: 6px;
      letter-spacing: -0.5px;
      text-shadow: 0 2px 16px rgba(0, 0, 0, 0.4);
      opacity: 0;
      transform: translateY(16px);
      animation: heroFadeUp 0.7s ease 0.35s forwards;
    }

    .hero-tagline {
      font-size: clamp(12px, 3vw, 14px);
      color: rgba(255, 255, 255, 0.7);
      font-weight: 400;
      opacity: 0;
      transform: translateY(12px);
      animation: heroFadeUp 0.6s ease 0.5s forwards;
    }

    @keyframes heroFadeUp {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Animated pulse ring on right */
    .hero-icon-ring {
      width: 72px;
      height: 72px;
      border-radius: 50%;
      border: 2px solid rgba(132, 204, 22, 0.4);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      flex-shrink: 0;
      animation: heroRingPulse 3s ease-in-out infinite;
      opacity: 0;
      animation: heroFadeUp 0.6s ease 0.6s forwards, heroRingPulse 3s ease-in-out 1.2s infinite;
    }

    .hero-icon-ring::before {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: 50%;
      border: 1px solid rgba(132, 204, 22, 0.15);
      animation: heroRingPulse 3s ease-in-out 0.5s infinite;
    }

    @keyframes heroRingPulse {

      0%,
      100% {
        transform: scale(1);
        opacity: 0.7;
      }

      50% {
        transform: scale(1.08);
        opacity: 1;
      }
    }

    .hero:hover {
      transform: translateY(-3px);
      box-shadow: var(--elevation-2);
      border-color: rgba(132, 204, 22, 0.35);
    }

    /* Cards */
    /* Environment Monitor Hero Card */
    .monitor-hero {
      position: relative;
      overflow: hidden;
      border: 1px solid var(--outline);
      background: transparent !important;
      /* Image handles bg */
    }

    .monitor-hero::before {
      content: '';
      position: absolute;
      inset: 0;
      background: url('monitor_card.jpg') center/cover no-repeat;
      z-index: 0;
    }

    .monitor-hero::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(5, 15, 8, 0.85) 0%, rgba(10, 30, 15, 0.75) 100%);
      z-index: 1;
    }

    .monitor-hero>* {
      position: relative;
      z-index: 2;
    }

    /* Internal Section Card (Nested) */
    .sec-card {
      background: var(--surface-container);
      border: 1px solid var(--outline-variant);
      border-radius: 12px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: none;
    }

    .sec-card:hover {
      background: rgba(12, 25, 18, 0.85);
      border-color: rgba(132, 204, 22, 0.3);
    }

    /* Cards - Glassmorphism */
    .card {
      background: var(--surface);
      backdrop-filter: blur(16px);
      -webkit-backdrop-filter: blur(16px);
      border-radius: var(--radius);
      padding: 24px;
      box-shadow: var(--elevation-1);
      border: 1px solid var(--outline);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
      color: var(--on-surface);
    }

    .card:hover {
      transform: translateY(-3px);
      box-shadow: var(--elevation-2);
      border-color: rgba(132, 204, 22, 0.35);
      background: rgba(12, 25, 18, 0.85);
    }

    .head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      flex-wrap: wrap;
      gap: 12px;
    }

    h2 {
      font-size: 20px;
      font-weight: 600;
      color: var(--on-surface);
      letter-spacing: -0.3px;
    }

    /* Inputs & Controls */
    .ip-config {
      background: var(--input-bg);
      border-radius: 50px;
      /* Pill shape */
      padding: 8px 12px;
      /* Tighter padding for pill */
      display: flex;
      gap: 12px;
      align-items: center;
      border: 1px solid transparent;
      /* No border by default */
      transition: var(--transition);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.02);
    }

    .ip-config:focus-within {
      background: rgba(12, 25, 18, 0.9);
      border-color: var(--primary);
      box-shadow: 0 4px 12px rgba(132, 204, 22, 0.15);
    }

    /* Global Select & Option styling for dark theme */
    select {
      background-color: rgba(10, 20, 14, 0.92) !important;
      color: var(--on-surface) !important;
    }

    select option {
      background: #0f1e16;
      color: #f0fdf4;
      padding: 8px;
    }

    select option:hover,
    select option:checked {
      background: rgba(132, 204, 22, 0.25);
      color: #f0fdf4;
    }

    .ip-config input {
      background: transparent;
      border: none;
      color: var(--on-surface);
      padding: 10px 16px;
      font-family: 'Roboto Mono', monospace;
      font-size: 14px;
      flex: 1;
      outline: none;
      font-weight: 500;
    }

    .local-image-controls .btn {
      padding: 10px 20px;
      font-size: 14px;
    }

    /* Batch progress indicator */
    .batch-progress {
      width: 100%;
      max-width: 420px;
    }

    .batch-progress .bar {
      transition: width 220ms cubic-bezier(.2, 0, .2, 1);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.25);
      height: 8px;
      border-radius: 6px;
    }

    .batch-progress .label {
      margin-top: 6px;
      font-size: 13px;
      color: var(--on-surface-variant);
    }

    .status {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 16px;
    }

    /* Compact resync progress indicator */
    .resync-progress {
      display: inline-flex;
      gap: 8px;
      align-items: center;
    }

    .resync-bar {
      width: 120px;
      height: 8px;
      background: var(--outline-variant);
      border-radius: 6px;
      overflow: hidden;
    }

    .resync-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), #0b4eb3);
      transition: width 250ms cubic-bezier(.2, 0, .2, 1);
    }

    .resync-text {
      font-size: 12px;
      color: var(--on-surface-variant);
      min-width: 40px;
      text-align: right;
    }

    .actions {
      margin-top: 24px;
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    .ip-config span.translatable {
      margin-right: 6px;
    }

    .ip-config input::placeholder {
      color: var(--placeholder);
    }

    .ip-config button {
      padding: 8px 12px;
      border-radius: 8px;
      border: none;
      background: var(--primary);
      color: var(--on-primary);
      cursor: pointer;
      font-weight: 500;
      box-shadow: none;
    }

    .ip-config button:hover {
      background: var(--primary-hover);
    }

    /* Navigation - Fixed Bottom Glass */
    /* Navigation - Floating Bottom Glass (YouTube Style) */
    .nav {
      position: fixed !important;
      bottom: 16px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      width: calc(100% - 32px) !important;
      max-width: 600px !important;
      background: var(--nav-bg);
      backdrop-filter: var(--nav-blur);
      -webkit-backdrop-filter: var(--nav-blur);
      border-radius: 24px !important;
      padding: 12px 8px;
      display: flex;
      justify-content: space-around;
      align-items: center;
      z-index: 99999 !important;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4), 0 0 0 1px rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.15);
      margin: 0 !important;
    }

    .nav-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-decoration: none;
      color: var(--on-surface-variant);
      gap: 4px;
      padding: 8px 12px;
      border-radius: 12px;
      transition: var(--transition);
      background: transparent;
      flex: 1;
    }

    .nav-item span.label {
      font-size: 10px;
      font-weight: 500;
      letter-spacing: 0.3px;
    }

    .nav-item .material-symbols-rounded {
      font-size: 24px;
      transition: transform 0.2s;
    }

    .nav-item.active {
      color: var(--primary);
      background: rgba(132, 204, 22, 0.15);
      /* Subtle glow */
    }

    .nav-item.active .material-symbols-rounded {
      transform: translateY(-2px);
      font-variation-settings: 'FILL' 1;
    }

    .nav-item:hover:not(.active) {
      color: #fff;
      background: rgba(255, 255, 255, 0.05);
    }

    .conn-status.error::before {
      background: var(--error);
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.15);
    }

    .conn-status.warn {
      color: var(--warn);
      background: rgba(245, 158, 11, 0.1);
    }

    .conn-status.warn::before {
      background: var(--warn);
      box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.15);
    }

    /* Buttons - Soft & Modern */
    .btn {
      border: none;
      border-radius: 50px;
      padding: 14px 28px;
      font-weight: 600;
      font-size: 15px;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      letter-spacing: 0.3px;
      position: relative;
      overflow: hidden;
    }

    .btn .material-symbols-rounded {
      font-size: 20px;
      margin-right: 0;
    }

    .btn:active {
      transform: scale(0.96);
    }

    .btn.pri {
      background: var(--primary);
      color: #fff;
      box-shadow: 0 4px 14px rgba(59, 130, 246, 0.4);
    }

    .btn.pri:hover:not(:disabled) {
      background: var(--primary-hover);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.6);
    }

    .btn.sec {
      background: var(--surface);
      color: var(--on-surface);
      border: 1px solid var(--outline);
      box-shadow: var(--elevation-1);
    }

    .btn.sec:hover:not(:disabled) {
      background: var(--surface-container);
      border-color: var(--primary);
      color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--elevation-2);
    }

    .btn.err {
      background: var(--error-container);
      color: var(--error);
      border: 1px solid transparent;
    }

    .btn.err:hover {
      background: var(--error);
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
    }

    .btn:disabled {
      opacity: 0.6;
      cursor: not-allowed;
      transform: none !important;
      box-shadow: none !important;
      background: var(--surface-container) !important;
      color: var(--on-surface-variant) !important;
    }

    .rc {
      background: var(--surface-container);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .rc .t {
      font-weight: 500;
      font-size: 16px;
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .badge {
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
    }

    .badge.ok {
      background: #c4eed0;
      color: var(--success);
    }

    .badge.warn {
      background: #ffebb0;
      color: var(--warn);
    }

    .badge.err {
      background: var(--error-container);
      color: var(--error);
    }

    .ctx {
      background: var(--surface-container);
      border-radius: 12px;
      padding: 20px;
      margin-top: 12px;
    }

    /* Chart containers */
    /* Transparent Chart Containers */
    .chart-container {
      background: rgba(20, 40, 30, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      padding: 16px;
      position: relative;
      width: 100%;
    }

    .mobile-menu-btn {
      display: none !important;
      /* Hide old mobile menu button if present */
    }

    .timeline-container {
      position: relative;
      height: 400px;
      /* Desktop default */
      width: 100%;
    }

    /* Mobile Chart Responsiveness */
    @media (max-width: 600px) {

      .timeline-container,
      #modelPrecisionChartContainer {
        height: 50vh !important;
        /* Use viewport height on mobile */
        min-height: 300px;
        max-height: 500px;
      }

      .card {
        padding: 16px !important;
        /* Reduce padding on mobile for more chart width */
      }
    }

    /* Bottom Nav */
    .bottom-nav {
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 500px;
      background: var(--nav-bg);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.5);
      border-radius: 32px;
      /* Super rounded */
      display: flex;
      justify-content: space-between;
      padding: 12px 24px;
      z-index: 1000;
      box-shadow: 0 20px 40px -10px rgba(0, 0, 0, 0.1);
    }

    .bottom-nav .nav-item {
      padding: 10px;
      border-radius: 16px;
      color: var(--on-surface-variant);
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      transition: var(--transition);
    }

    .bottom-nav .nav-item.active {
      color: var(--primary);
      background: var(--primary-container);
      transform: translateY(-2px);
    }

    .bottom-nav .nav-item.active::before {
      display: none;
    }

    /* Remove old indicator */

    .bottom-nav .nav-icon {
      font-size: 24px;
      margin-bottom: 4px;
      font-variation-settings: 'FILL' 1, 'wght' 400, 'GRAD' 0, 'opsz' 24;
    }

    .bottom-nav .nav-label {
      font-size: 10px;
      font-weight: 600;
    }

    /* Tab Content Sections */
    .tab-content {
      display: none;
      animation: fadeInTab 0.4s ease-out;
      transform-style: preserve-3d;
    }

    .tab-content.active {
      display: flex;
      flex-direction: column;
      gap: 24px;
    }

    @keyframes fadeInTab {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Analysis Logs Page (nested under More tab) */
    .logs-page {
      display: none;
    }

    .logs-page.active {
      display: block;
    }

    .back-button {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      color: var(--on-surface);
      cursor: pointer;
      transition: all 0.2s;
      margin-bottom: 20px;
      font-size: 14px;
      font-weight: 500;
    }

    .back-button:hover {
      background: rgba(255, 255, 255, 0.15);
      transform: translateX(-2px);
    }

    /* Plant Selector */
    #plantSelector button {
      background: rgba(255, 255, 255, 0.03) !important;
      border: 1px solid rgba(255, 255, 255, 0.1) !important;
      transition: var(--transition) !important;
    }

    #plantSelector button:hover {
      background: rgba(255, 255, 255, 0.08) !important;
      border-color: var(--primary) !important;
      transform: translateY(-2px);
    }

    /* Scrollbar */
    ::-webkit-scrollbar {
      width: 8px;
    }

    ::-webkit-scrollbar-track {
      background: var(--bg-color);
    }

    ::-webkit-scrollbar-thumb {
      background: var(--surface-container);
      border-radius: 4px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--outline);
    }

    .card-enter {
      animation: card-enter-animation 0.5s ease-out forwards;
      opacity: 0;
      transform: translateY(20px);
    }

    @keyframes card-enter-animation {
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* Grid & Layout */
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
      gap: 24px;
    }

    section.grid {
      grid-template-columns: 2fr 1fr;
    }

    @media (max-width: 900px) {
      section.grid {
        grid-template-columns: 1fr;
      }
    }

    /* Sensor Cards */
    .sg {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 16px;
    }

    .sc {
      background: var(--surface);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border-radius: 20px;
      padding: 24px;
      text-align: center;
      border: 1px solid var(--outline);
      transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), box-shadow 0.3s ease, background 0.3s ease;
      box-shadow: var(--elevation-1);
    }

    .sc:hover {
      background: rgba(12, 25, 18, 0.88);
      transform: translateY(-3px);
      box-shadow: var(--elevation-2);
      border-color: rgba(132, 204, 22, 0.35);
      z-index: 2;
    }

    .sc .v {
      font-size: 28px;
      font-weight: 700;
      color: var(--primary);
      margin: 8px 0;
      text-shadow: 0 0 20px rgba(132, 204, 22, 0.3);
    }

    .sc .l {
      font-size: 13px;
      color: var(--on-surface-variant);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Status Chips */
    .chip {
      background: var(--surface-container);
      border: 1px solid var(--outline-variant);
      border-radius: 50px;
      padding: 8px 16px;
      font-size: 13px;
      font-weight: 600;
      display: inline-flex;
      align-items: center;
      gap: 10px;
      color: var(--on-surface);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: var(--transition);
    }

    .chip:hover {
      background: rgba(12, 25, 18, 0.85);
      box-shadow: var(--elevation-1);
      border-color: rgba(132, 204, 22, 0.3);
    }

    .dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
    }

    .dot.offline {
      background: var(--error);
      box-shadow: 0 0 8px var(--error);
    }

    /* Results Table */
    /* Results Table */
    .results-table tr {
      border-bottom: 1px solid var(--outline);
    }

    .results-table tr:last-child {
      border-bottom: none;
    }

    .results-table th {
      font-weight: 700;
      letter-spacing: 1px;
      text-transform: uppercase;
      font-size: 11px;
      color: var(--on-surface-variant);
      padding: 12px 8px;
    }

    .results-table td {
      padding: 12px 8px;
    }

    /* Frame/Image Container */
    .frame {
      background: #000;
      border-radius: 16px;
      overflow: hidden;
      overflow: hidden;
      box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.05);
      /* Softer inner shadow */
      border: 1px solid var(--outline);
      min-height: 240px;
      display: grid;
      place-items: center;
      position: relative;
    }

    .frame img {
      width: 100%;
      height: auto;
      display: block;
    }

    /* =========================================
       NEW LOG / HISTORY TIMELINE DESIGN
       ========================================= */
    .timeline-feed {
      display: flex;
      flex-direction: column;
      gap: 16px;
      padding-top: 8px;
    }

    .log-card {
      background: var(--surface);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid var(--outline-variant);
      border-radius: 16px;
      overflow: hidden;
      position: relative;
      transition: var(--transition);
    }

    .log-card:hover {
      border-color: rgba(132, 204, 22, 0.3);
      box-shadow: var(--elevation-1);
      background: rgba(12, 25, 18, 0.85);
    }

    /* Header: Time, Severity, Delete */
    .log-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--surface-container);
      border-bottom: 1px solid rgba(0, 0, 0, 0.03);
    }

    .log-meta {
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 12px;
      color: var(--on-surface-variant);
      font-weight: 500;
    }

    .log-badge {
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .log-badge.low {
      background: rgba(52, 168, 83, 0.1);
      color: var(--success);
    }

    .log-badge.moderate {
      background: rgba(251, 188, 4, 0.1);
      color: var(--warn);
    }

    .log-badge.high,
    .log-badge.critical {
      background: rgba(234, 67, 53, 0.1);
      color: var(--error);
    }

    .log-delete-btn {
      background: transparent;
      border: none;
      color: var(--on-surface-variant);
      cursor: pointer;
      padding: 4px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s, color 0.2s;
    }

    .log-delete-btn:hover {
      background: rgba(234, 67, 53, 0.1);
      color: var(--error);
    }

    /* Main Content */
    .log-body {
      padding: 16px;
      cursor: pointer;
    }

    /* Status Bar Styling */
    .status-bar {
      position: fixed;
      bottom: 80px;
      /* Above bottom nav */
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 16px;
      background: var(--surface-container);
      padding: 8px 16px;
      border-radius: 50px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 2000;
      border: 1px solid var(--outline-variant);
      backdrop-filter: blur(10px);
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 11px;
      font-weight: 600;
      color: var(--on-surface-variant);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .status-item.online .status-indicator {
      background: var(--success);
      box-shadow: 0 0 8px var(--success);
    }

    .status-item.offline .status-indicator {
      background: var(--error);
      box-shadow: none;
    }

    .status-item .status-indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--on-surface-variant);
      transition: all 0.3s;
    }

    .log-title {
      font-size: 16px;
      font-weight: 600;
      color: var(--on-surface);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .log-confidence {
      font-size: 20px;
      font-weight: 300;
      color: var(--primary);
    }

    .log-summary {
      font-size: 13px;
      color: var(--on-surface-variant);
      line-height: 1.5;
    }

    /* Details Section (Collapsible) */
    .log-details {
      display: none;
      padding: 0 16px 16px 16px;
      border-top: 1px solid var(--outline-variant);
      background: var(--bg-color);
      animation: slideDown 0.2s ease-out;
    }

    .log-card.expanded .log-details {
      display: block;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-5px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .log-section-title {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--on-surface-variant);
      font-weight: 700;
      margin: 16px 0 8px 0;
      letter-spacing: 0.5px;
    }

    /* Model Results Table-ish */
    .log-model-row {
      display: flex;
      justify-content: space-between;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255, 255, 255, 0.05);
      font-size: 13px;
    }

    .log-model-row:last-child {
      border-bottom: none;
    }

    .log-model-name {
      color: var(--on-surface);
    }

    .log-model-result {
      font-weight: 500;
    }

    /* Sensor Grid in Logs */
    .log-sensor-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .log-sensor-item {
      background: var(--surface-container);
      padding: 8px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-size: 12px;
      color: var(--on-surface);
    }

    .log-sensor-item .material-symbols-rounded {
      font-size: 18px;
      margin-bottom: 4px;
      color: var(--primary);
    }

    /* Filter Chips */
    .filter-group {
      display: flex;
      gap: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
      margin-right: auto;
      /* Push clear button to right */
    }

    .filter-chip {
      background: var(--surface-container);
      border: 1px solid var(--outline-variant);
      color: var(--on-surface-variant);
      padding: 6px 16px;
      border-radius: 16px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }

    .filter-chip:hover {
      background: var(--outline-variant);
    }

    .filter-chip.active {
      background: var(--primary-container);
      color: var(--primary);
      border-color: var(--primary-container);
    }

    /* =========================================
       NEW DIAGNOSTIC RESULTS CARD DESIGN
       ========================================= */
    .res-list {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .res-card {
      background: var(--surface);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border: 1px solid var(--outline-variant);
      border-radius: var(--radius-sm);
      overflow: hidden;
      transition: var(--transition);
      position: relative;
    }

    .res-card:hover {
      border-color: rgba(132, 204, 22, 0.3);
      box-shadow: var(--elevation-1);
      background: rgba(12, 25, 18, 0.85);
    }

    .res-header {
      padding: 16px 20px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      background: var(--surface-container);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .res-title-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .res-disease-name {
      font-size: 18px;
      font-weight: 700;
      color: var(--on-surface);
      margin: 0;
      letter-spacing: -0.5px;
    }

    .res-model-name {
      font-size: 11px;
      font-family: 'Roboto Mono', monospace;
      color: var(--on-surface-variant);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .res-badge {
      font-size: 11px;
      font-weight: 700;
      text-transform: uppercase;
      padding: 6px 10px;
      border-radius: 50px;
      letter-spacing: 0.5px;
      white-space: nowrap;
      margin-left: 12px;
    }

    .res-badge.high {
      background: rgba(234, 67, 53, 0.1);
      color: #EA4335;
    }

    .res-badge.med {
      background: rgba(251, 188, 4, 0.1);
      color: #FBBC04;
    }

    .res-badge.low {
      background: rgba(52, 168, 83, 0.1);
      color: #34A853;
    }

    .res-badge.healthy {
      background: rgba(52, 168, 83, 0.1);
      color: #34A853;
    }

    .res-body {
      padding: 20px;
    }

    .res-metrics {
      display: flex;
      gap: 32px;
      margin-bottom: 20px;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--outline-variant);
    }

    .res-metric {
      display: flex;
      flex-direction: column;
    }

    .res-metric-label {
      font-size: 11px;
      text-transform: uppercase;
      color: var(--on-surface-variant);
      font-weight: 600;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .res-metric-value {
      font-size: 18px;
      font-weight: 500;
      color: var(--on-surface);
    }

    .res-remedy {
      background: var(--bg-color);
      border: 1px solid var(--outline-variant);
      border-radius: 8px;
      padding: 16px;
    }

    .res-remedy-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      color: var(--primary);
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .res-remedy-content {
      font-size: 14px;
      line-height: 1.6;
      color: var(--on-surface);
    }

    .remedy-block {
      margin-bottom: 8px;
    }

    .remedy-block:last-child {
      margin-bottom: 0;
    }

    .remedy-type {
      font-weight: 600;
      color: var(--on-surface);
      margin-right: 4px;
    }

    .res-feedback {
      padding: 12px 20px;
      background: var(--surface);
      border-top: 1px solid var(--outline-variant);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .res-feedback-text {
      font-size: 12px;
      color: var(--on-surface-variant);
    }

    .res-feedback-actions {
      display: flex;
      gap: 8px;
    }

    .res-btn-feedback {
      background: transparent;
      border: 1px solid var(--outline-variant);
      border-radius: 6px;
      padding: 6px 12px;
      font-size: 12px;
      font-weight: 500;
      color: var(--on-surface-variant);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
      transition: all 0.2s;
    }

    .res-btn-feedback:hover {
      background: var(--surface-container);
      color: var(--on-surface);
      border-color: var(--on-surface-variant);
    }

    .res-btn-feedback.correct:hover {
      border-color: var(--success);
      color: var(--success);
      background: rgba(52, 168, 83, 0.05);
    }

    .res-btn-feedback.wrong:hover {
      border-color: var(--error);
      color: var(--error);
      background: rgba(234, 67, 53, 0.05);
    }

    /* Consensus Box Redesign */
    .consensus-card {
      background: var(--surface);
      border: 1px solid var(--outline-variant);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 24px;
      display: flex;
      flex-direction: column;
      gap: 12px;
      position: relative;
      overflow: hidden;
    }

    .consensus-card::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 4px;
      background: var(--outline);
    }

    .consensus-card.healthy::before {
      background: var(--success);
    }

    .consensus-card.disease::before {
      background: var(--error);
    }

    .consensus-header {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .consensus-icon {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .consensus-card.healthy .consensus-icon {
      background: rgba(16, 185, 129, 0.1);
      color: var(--success);
    }

    .consensus-card.disease .consensus-icon {
      background: rgba(239, 68, 68, 0.1);
      color: var(--error);
    }

    .consensus-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--on-surface);
    }

    .consensus-verdict {
      font-size: 14px;
      color: var(--on-surface-variant);
      margin-left: 44px;
    }

    .consensus-note {
      font-size: 13px;
      color: var(--on-surface-variant);
      background: var(--surface-container);
      padding: 12px;
      border-radius: 8px;
      margin-left: 44px;
      line-height: 1.5;
    }

    /* Mobile Adjustments */
    @media (max-width: 600px) {
      body {
        padding: 16px;
        padding-bottom: 90px;
      }

      .hero {
        padding: 24px;
        text-align: center;
      }

      .hero h1 {
        font-size: 24px;
      }

      .bottom-nav {
        width: 94%;
        bottom: 16px;
      }

      .head {
        flex-direction: column;
        align-items: stretch;
      }

      .head .btn {
        width: 100%;
      }

      .ip-config {
        flex-direction: column;
        align-items: stretch;
      }

      .ip-config button {
        width: 100%;
      }

      .grid,
      .sg,
      .status {
        grid-template-columns: 1fr;
        gap: 16px;
      }

      .actions {
        flex-direction: column;
        align-items: stretch;
      }

      .actions .btn {
        width: 100%;
      }

      /* Responsive Table */
      .results-table,
      .results-table thead,
      .results-table tbody,
      .results-table th,
      .results-table td,
      .results-table tr {
        display: block;
      }

      .results-table thead tr {
        position: absolute;
        top: -9999px;
        left: -9999px;
      }

      .results-table tr {
        border: 1px solid rgba(255, 255, 255, 0.1);
        margin-bottom: 16px;
        border-radius: 12px;
        padding: 12px;
        background: rgba(255, 255, 255, 0.02);
      }

      .results-table td {
        border: none;
        position: relative;
        padding-left: 50%;
        text-align: right;
        padding-top: 8px;
        padding-bottom: 8px;
      }

      .results-table td:before {
        position: absolute;
        top: 8px;
        left: 0;
        width: 45%;
        padding-right: 10px;
        white-space: nowrap;
        text-align: left;
        font-weight: 600;
        color: var(--on-surface-variant);
        content: attr(data-label);
      }
    }

    /* Utility */
    .pill {
      background: var(--primary-container);
      color: var(--primary);
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 700;
      text-transform: uppercase;
    }

    /* Toast */
    .toast {
      background: var(--surface-glass);
      border: 1px solid var(--outline);
      border-radius: 20px;
      box-shadow: var(--elevation-3);
      min-width: 220px;
      max-width: 360px;
      padding: 16px 20px;
      color: var(--on-surface);
      font-size: 14px;
      display: flex;
      gap: 10px;
      align-items: center;
      opacity: 0;
      transform: translateY(6px);
      transition: opacity 240ms ease, transform 240ms ease;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .toast.info {
      border-left: 4px solid var(--primary);
    }

    .toast.success {
      border-left: none;
      background: var(--surface-glass);
      color: var(--success);
      border: 1px solid var(--outline);
    }

    .toast.error {
      border-left: none;
      background: var(--surface-glass);
      color: var(--error);
      border: 1px solid var(--outline);
    }

    .toast .label {
      font-weight: 500;
    }

    /* Theme Switch Visuals */
    html[data-theme="dark"] .theme-switch-on {
      display: inline-block !important;
    }

    html[data-theme="light"] .theme-switch-off {
      display: inline-block !important;
    }

    html[data-theme="light"] .theme-switch-on,
    html[data-theme="dark"] .theme-switch-off {
      display: none !important;
    }

    /* Language Selector in Menu */
    #languageSelector {
      background: var(--surface-container);
      border-radius: 20px;
      padding: 4px;
      display: flex;
      gap: 4px;
    }

    #languageSelector button {
      border: none;
      background: transparent;
      padding: 6px 12px;
      border-radius: 16px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      color: var(--on-surface-variant);
      transition: all 0.2s;
    }

    #languageSelector button.active {
      background: var(--surface);
      color: var(--primary);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    /* Control Card Styles */
    .control-card {
      border-left: 4px solid var(--outline-variant);
      transition: border-color 0.3s ease;
    }

    /* Toggle Switch - Modern iOS style */
    .switch {
      position: relative;
      display: inline-block;
      width: 52px;
      height: 30px;
    }

    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--outline-variant);
      transition: .3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.05);
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 22px;
      width: 22px;
      left: 4px;
      bottom: 4px;
      background-color: white;
      transition: .3s cubic-bezier(0.4, 0, 0.2, 1);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    input:checked+.slider {
      background-color: var(--success);
    }

    input:focus+.slider {
      box-shadow: 0 0 1px var(--success);
    }

    input:checked+.slider:before {
      transform: translateX(22px);
    }

    .slider.round {
      border-radius: 34px;
    }

    .slider.round:before {
      border-radius: 50%;
    }

    .landing-overlay.fade-out {
      opacity: 0;
      visibility: hidden;
    }
  </style>
</head>

<body>
  <!-- Landing Page Overlay -->
  <div id="landingPage" class="landing-overlay">
    <!-- Badge -->
    <div class="landing-badge">
      <span class="landing-badge-dot"></span>
      <span class="landing-badge-text">Agri-Nigrani</span>
    </div>
    <!-- Content -->
    <div class="landing-content">
      <h1 class="landing-title">YOUR FARM,<br>SMARTER.</h1>
      <p class="landing-subtitle">
        Monitor crop health, optimize resources, and increase yield with data‑driven insights.
      </p>
      <button class="landing-btn" onclick="enterDashboard()">
        Get Started
        <span class="material-symbols-rounded" style="font-size:20px;">arrow_forward</span>
      </button>
    </div>
  </div>

  <div class="wrap">
    <!-- ==========================================
         HOME TAB - Dashboard Overview & Pump Control
         ========================================== -->
    <div id="homeTab" class="tab-content active">
      <section class="hero">
        <div class="hero-content">
          <div class="hero-text">
            <div class="hero-label">Smart Agriculture System</div>
            <h1 class="translatable">Agri-Nigrani</h1>
            <div class="hero-tagline">IoT-powered crop monitoring &amp; automation</div>
          </div>
          <div class="hero-icon-ring">
            <span class="material-symbols-rounded" style="font-size: 32px; color: var(--primary);">eco</span>
          </div>
        </div>
      </section>

      <!-- Weather Widget (New) -->
      <article class="card weather-card"
        style="background: var(--surface); color: var(--on-widget); border: 1px solid var(--outline);">
        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 16px;">
          <div style="flex: 1;">
            <div id="greeting" style="font-size: 20px; font-weight: 700; color: var(--on-widget); margin-bottom: 4px;">
              Good Morning, Farmer! 🌾</div>
            <div id="clock"
              style="font-size: 13px; font-weight: 500; color: var(--on-widget-variant); background: rgba(255,255,255,0.1); padding: 6px 12px; border-radius: 20px; backdrop-filter: blur(4px); display: inline-block; margin-bottom: 12px;">
              --:-- • ---</div>

            <div style="display: flex; flex-direction: column;">
              <div
                style="display: flex; align-items: center; gap: 6px; color: var(--on-widget-variant); font-weight: 500; font-size: 14px; margin-bottom: 4px; cursor: pointer;"
                onclick="toggleLocationSearch()" title="Click to change location">
                <span class="material-symbols-rounded" style="font-size: 18px;">location_on</span>
                <span id="weatherLocation" style="border-bottom: 1px dashed rgba(255,255,255,0.4);">Locating...</span>
                <span class="material-symbols-rounded" style="font-size: 16px; opacity: 0.7;">edit</span>
              </div>

              <!-- Search UI (Hidden) -->
              <div id="locationSearch" style="display: none; margin-top: 8px; gap: 8px;">
                <input type="text" id="cityInput" placeholder="City Name"
                  style="background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 6px 12px; border-radius: 8px; font-size: 13px; outline: none; width: 140px;">
                <button onclick="searchLocation()"
                  style="background: var(--primary); color: var(--on-primary); border: none; padding: 6px 12px; border-radius: 8px; font-size: 12px; font-weight: 600; cursor: pointer;">Search</button>
              </div>
            </div>

          </div>
        </div>

        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px;">
          <div>
            <div style="display: flex; align-items: flex-start;">
              <span id="currentTemp"
                style="font-size: 56px; font-weight: 800; line-height: 1; letter-spacing: -2px;">--</span>
              <span style="font-size: 24px; font-weight: 600; margin-top: 4px; opacity: 0.8;">°C</span>
            </div>
            <div id="currentCondition" style="font-size: 16px; font-weight: 500; opacity: 0.9; margin-top: 4px;">--
            </div>
            <div id="feelsLike" style="font-size: 13px; opacity: 0.7; margin-top: 2px;">Feels --°</div>
          </div>
          <span id="currentWeatherIcon" class="material-symbols-rounded"
            style="font-size: 64px; color: var(--primary); text-shadow: 0 4px 12px rgba(0,0,0,0.2);">cloud</span>
        </div>

        <!-- Metrics Grid -->
        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px;">
          <div
            style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 16px; text-align: center; border: 1px solid rgba(255,255,255,0.05);">
            <span class="material-symbols-rounded"
              style="font-size: 20px; margin-bottom: 4px; opacity: 0.8;">water_drop</span>
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 2px;">Humidity</div>
            <div style="font-size: 16px; font-weight: 700;"><span id="currentHumidity">--</span>%</div>
          </div>
          <div
            style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 16px; text-align: center; border: 1px solid rgba(255,255,255,0.05);">
            <span class="material-symbols-rounded" style="font-size: 20px; margin-bottom: 4px; opacity: 0.8;">air</span>
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 2px;">Wind</div>
            <div style="font-size: 16px; font-weight: 700;"><span id="currentWind">--</span> <span
                style="font-size: 12px; font-weight: 400;">km/h</span></div>
          </div>
          <div
            style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 16px; text-align: center; border: 1px solid rgba(255,255,255,0.05);">
            <span class="material-symbols-rounded"
              style="font-size: 20px; margin-bottom: 4px; opacity: 0.8;">rainy</span>
            <div style="font-size: 12px; opacity: 0.7; margin-bottom: 2px;">Rain</div>
            <div style="font-size: 16px; font-weight: 700;"><span id="agriRain">--</span> <span
                style="font-size: 12px; font-weight: 400;">mm</span></div>
          </div>
        </div>

        <!-- Attribution -->
        <div
          style="text-align: center; font-size: 10px; color: rgba(255,255,255,0.3); margin-top: -12px; margin-bottom: 20px; font-weight: 400; letter-spacing: 0.5px;">
          Sources: NOAA, ECMWF, DWD via Open-Meteo
        </div>

        <!-- Farming Insights -->
        <div style="margin-bottom: 24px; padding-top: 16px; border-top: 1px solid rgba(255,255,255,0.1);">
          <h5
            style="margin: 0 0 12px 0; font-size: 14px; font-weight: 600; color: var(--on-widget); display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded" style="font-size: 18px; color: var(--primary);">grass</span>
            Farming Insights
          </h5>
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px;">

            <!-- Soil Moisture -->
            <div
              style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.05); text-align: center; display: flex; flex-direction: column; align-items: center;">
              <span class="material-symbols-rounded"
                style="color: #a18374; font-size: 24px; margin-bottom: 4px;">opacity</span>
              <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-bottom: 4px;">Soil Moisture</div>
              <div id="agriSoil" style="font-size: 16px; font-weight: 700; color: white;">--</div>
              <div style="font-size: 10px; color: rgba(255,255,255,0.5);">(3-9cm)</div>
            </div>

            <!-- ET0 -->
            <div
              style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.05); text-align: center; display: flex; flex-direction: column; align-items: center;">
              <span class="material-symbols-rounded"
                style="color: #fbbf24; font-size: 24px; margin-bottom: 4px;">wb_sunny</span>
              <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-bottom: 4px;">Evapotranspiration
              </div>
              <div id="agriEt0" style="font-size: 16px; font-weight: 700; color: white;">--</div>
              <div style="font-size: 10px; color: rgba(255,255,255,0.5);">mm/day</div>
            </div>

            <!-- Rainfall -->
            <div
              style="background: rgba(255,255,255,0.08); padding: 12px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.05); text-align: center; display: flex; flex-direction: column; align-items: center;">
              <span class="material-symbols-rounded"
                style="color: #60a5fa; font-size: 24px; margin-bottom: 4px;">rainy</span>
              <div style="font-size: 11px; color: rgba(255,255,255,0.7); margin-bottom: 4px;">Rainfall</div>
              <div id="agriRain" style="font-size: 16px; font-weight: 700; color: white;">--</div>
              <div style="font-size: 10px; color: rgba(255,255,255,0.5);">mm</div>
            </div>

          </div>
        </div>

        <!-- 7-Day Forecast Scroll -->
        <div style="display: flex; gap: 12px; overflow-x: auto; padding-bottom: 12px; scrollbar-width: none;"
          id="forecastScroll">
          <!-- Forecast items injected by JS -->
          <div
            style="min-width: 60px; text-align: center; padding: 12px 8px; background: rgba(255,255,255,0.6); border-radius: 16px; border: 1px solid var(--outline-variant);">
            <div style="font-size: 12px; font-weight: 600; color: var(--on-surface-variant); margin-bottom: 8px;">--
            </div>
            <span class="material-symbols-rounded"
              style="color: var(--on-surface-variant); font-size: 24px; margin-bottom: 8px;">more_horiz</span>
            <div style="font-size: 14px; font-weight: 700; color: var(--on-surface);">--°</div>
          </div>
        </div>
      </article>

      <article class="card">
        <div class="head">
          <h2 class="translatable">System Dashboard</h2>
          <button class="btn sec" onclick="location.reload()"><span class="material-symbols-rounded">refresh</span>
            <span class="translatable">Refresh</span></button>
        </div>
        <section class="status">
          <div class="chip"><span class="dot offline" id="espDot"></span><span id="espStatus"
              class="translatable">ESP</span></div>
          <div class="chip"><span class="dot offline" id="camDot"></span><span id="cs"
              class="translatable">Camera</span></div>
          <div class="chip"><span class="dot offline" id="mqttDot"></span><span id="mqttStatus"
              class="translatable">MQTT</span></div>
          <div class="chip"><span class="dot offline" id="firebaseDot"></span><span id="firebaseText"
              class="translatable">Firebase</span></div>
        </section>
      </article>

      <!-- Pump Control on Home Tab -->
      <!-- 
        DEVICE-SIDE IRRIGATION CONTROL ARCHITECTURE:
        - Timer logic runs fully on ESP32-CAM (survives app kill/phone off)
        - MQTT retained messages store schedule/timer state
        - ESP32 uses NTP + local clock for execution
        - Priority: Manual Override > Quick Timer > Schedule
        - Mobile app is just a remote control - ESP32 is the master
      -->
      <article class="card control-card" id="pumpCard">
        <div class="head">
          <h2 class="translatable">Irrigation Control</h2>
          <div class="chip" style="background: var(--surface-container); border: none;">
            <span class="dot" id="pumpStatusDot"
              style="background: var(--on-surface-variant); box-shadow: none;"></span>
            <span id="pumpStatusText" class="translatable" style="font-weight: 700;">OFF</span>
          </div>
        </div>

        <!-- Device-Side Control Info Banner -->
        <div
          style="padding: 12px; background: var(--primary-container); border-radius: 8px; margin-bottom: 16px; border-left: 4px solid var(--primary);">
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
            <span class="material-symbols-rounded" style="font-size: 18px; color: var(--primary);">info</span>
            <span style="font-weight: 600; color: var(--primary); font-size: 13px;">Device-Side Timer Control</span>
          </div>
          <div style="font-size: 12px; color: var(--on-surface-variant); line-height: 1.4;">
            Timers run on ESP32-CAM. Works even if app is closed or phone is off! 🚀
          </div>

          <!-- Device status (NTP / Schedule / Quick Timer) -->
          <div id="espScheduleStatus"
            style="font-size:13px; color:var(--on-surface-variant); padding:8px 12px; border-radius:8px; background: rgba(255,255,255,0.02); margin-top:8px;">
            <span class="translatable">NTP:</span> — | <span class="translatable">Schedule:</span> OFF
          </div>
        </div>

        <div style="display: flex; flex-direction: column; gap: 20px;">
          <div
            style="display: flex; align-items: center; gap: 16px; padding: 16px; background: var(--surface-container); border-radius: 12px; border: 1px solid rgba(0,0,0,0.05);">
            <div
              style="width: 48px; height: 48px; border-radius: 50%; background: var(--surface); display: flex; align-items: center; justify-content: center; box-shadow: var(--elevation-1);">
              <span class="material-symbols-rounded" id="pumpIcon"
                style="font-size: 24px; color: var(--on-surface-variant);">water_drop</span>
            </div>
            <div>
              <div style="font-weight: 600; font-size: 15px; color: var(--on-surface);" class="translatable">Main Pump
              </div>
              <div style="font-size: 13px; color: var(--on-surface-variant);" class="translatable">Manual override
                control</div>
            </div>
          </div>

          <!-- Auto Mode Toggle -->
          <div
            style="display: flex; justify-content: space-between; align-items: center; padding: 12px 16px; background: var(--surface-container); border-radius: 12px; margin-top: 4px;">
            <div>
              <div style="font-weight: 600; font-size: 14px; color: var(--on-surface);" class="translatable">Auto
                Irrigation Mode
              </div>
              <div style="font-size: 12px; color: var(--on-surface-variant);" class="translatable">Pump based on
                moisture</div>
            </div>
            <label class="switch">
              <input type="checkbox" id="autoModeToggle" onchange="toggleAutoMode()">
              <span class="slider round"></span>
            </label>
          </div>

          <!-- Crop Profile Selector -->
          <div id="cropProfileDiv"
            style="display: none; padding: 0 8px; margin-top: -8px; margin-bottom: 8px; animation: fadeIn 0.3s ease;">
            <select id="cropProfile" onchange="updateAutoProfile()"
              style="width: 100%; padding: 12px 14px; background: rgba(10, 20, 14, 0.92); border: 1px solid var(--outline); border-radius: 10px; color: var(--on-surface); font-size: 13px; margin-top: 8px; outline: none; cursor: pointer; -webkit-appearance: none; appearance: none; background-image: url('data:image/svg+xml;utf8,<svg fill=\'white\' xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'><path d=\'M7 10l5 5 5-5z\'/></svg>'); background-repeat: no-repeat; background-position: right 10px center; background-size: 18px;">
              <option value="default" class="translatable">Default Profile (36-44%)</option>
              <option value="veg" class="translatable">Vegetables (Target >60%)</option>
              <option value="fruit_veg" class="translatable">Fruiting Veg (Target >50%)</option>
              <option value="grains" class="translatable">Grains (Target >50%)</option>
              <option value="fruits" class="translatable">Fruits (Target >35%)</option>
              <option value="house" class="translatable">Houseplants (Target >30%)</option>
            </select>
          </div>

          <button id="pumpBtn" class="btn pri" onclick="togglePump()"
            style="width: 100%; padding: 16px; justify-content: center; font-size: 16px; margin-top: 4px;">
            <span class="material-symbols-rounded">power_settings_new</span>
            <span class="translatable">Activate Pump</span>
          </button>

          <!-- Water Flow & Usage Stats (Visible when relevant) -->
          <div id="flowStatsDiv" style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 8px;">
            <!-- Flow & Volume Combined -->
            <div
              style="background: var(--surface-container); padding: 12px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; border: 1px solid rgba(0,0,0,0.05); grid-column: span 2;">
              <div style="font-size: 12px; color: var(--on-surface-variant); margin-bottom: 4px;" class="translatable">
                Water Flow</div>
              <div id="flowVolumeDisplay"
                style="font-size: 16px; font-weight: 700; color: var(--primary); text-align: center;">
                Rate=0.0000 L/min, Vol=0 mL
              </div>
              <div style="display: flex; gap: 8px; align-items: center; margin-top: 4px;">
                <div id="flowStatus" style="font-size: 10px; color: var(--on-surface-variant);" class="translatable">
                  Offline</div>
                <span style="color: var(--on-surface-variant);">•</span>
                <div style="font-size: 10px; color: var(--on-surface-variant);" class="translatable">Resets 00:00</div>
              </div>
            </div>
          </div>

          <!-- Dry Run Alert Banner (Hidden) -->
          <div id="dryRunAlert"
            style="display: none; background: rgba(234, 67, 53, 0.1); border: 1px solid var(--error); border-radius: 8px; padding: 12px; margin-top: 12px; align-items: center; gap: 12px;">
            <span class="material-symbols-rounded" style="color: var(--error);">warning</span>
            <div>
              <div style="color: var(--error); font-weight: 700; font-size: 13px;" class="translatable">DRY RUN DETECTED
              </div>
              <div style="color: var(--error); font-size: 11px;" class="translatable">Pump stopped to prevent damage.
                Check water source.</div>
            </div>
          </div>

          <!-- Schedule Section -->
          <div style="margin-top: 12px; padding-top: 16px; border-top: 1px solid var(--outline-variant);">
            <!-- Quick Delay Timer -->
            <h3 style="font-size: 14px; margin-bottom: 8px; color: var(--on-surface); font-weight: 600;"
              class="translatable">⏱️ Quick Timer</h3>
            <div style="display: flex; gap: 8px; margin-bottom: 16px;">
              <input type="number" id="delayMinutes" min="1" max="120" value="10" placeholder="Min"
                style="width: 60px; padding: 8px; background: var(--surface-container); border: 1px solid var(--outline-variant); border-radius: 8px; color: var(--on-surface); font-family: var(--font-sans);">
              <button class="btn sec" onclick="setDelayTimer('run')"
                style="flex: 1; font-size: 12px; padding: 8px; justify-content: center; background: var(--primary-container); color: var(--primary); border-color: var(--primary-container);">
                <span class="translatable">Run</span>
              </button>
              <button class="btn sec" onclick="setDelayTimer('on')"
                style="flex: 1; font-size: 12px; padding: 8px; justify-content: center;">
                <span class="translatable">On Delay</span>
              </button>
              <button class="btn sec" onclick="setDelayTimer('off')"
                style="flex: 1; font-size: 12px; padding: 8px; justify-content: center;">
                <span class="translatable">Off Delay</span>
              </button>
            </div>
            <div id="timerCountdown"
              style="display: none; margin-bottom: 12px; padding: 10px; background: var(--primary-container); border-radius: 8px; color: var(--primary); font-size: 14px; text-align: center; font-weight: 600; border: 1px solid var(--primary);">
            </div>

            <!-- Multi-Schedule -->
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
              <h3 style="font-size: 14px; margin: 0; color: var(--on-surface); font-weight: 600;" class="translatable">
                📅 Schedules</h3>
              <button class="btn sec" onclick="addScheduleRow()"
                style="padding: 4px 8px; font-size: 12px; min-height: 24px;"><span class="material-symbols-rounded"
                  style="font-size: 16px;">add</span> <span class="translatable">Add</span></button>
            </div>
            <div id="scheduleList" style="display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px;"></div>

            <button id="scheduleBtn" class="btn sec" onclick="savePumpSchedules()"
              style="width: 100%; justify-content: center;">
              <span class="material-symbols-rounded">event_available</span> <span class="translatable">Set
                Schedule</span>
            </button>


          </div>
        </div>
      </article>
    </div>

    <!-- ==========================================
         ANALYSE TAB - Camera, Disease Detection
         ========================================== -->
    <div id="analyseTab" class="tab-content">
      <section class="grid">

        <article class="card">
          <div class="head">
            <h2 class="translatable">Live Camera Stream</h2>
            <span class="pill translatable">Live</span>
          </div>
          <div class="ip-config">
            <span style="font-size: 14px; color: var(--on-surface-variant); font-weight: 500;"
              class="translatable">ESP32 Camera IP:</span>
            <input type="text" id="ipInput" placeholder="10.180.248.XXX" value="10.180.248.33">
            <button onclick="setIP()" class="translatable">Connect</button>
            <span id="connStatus" class="conn-status" aria-live="polite"></span>
          </div>
          <div class="frame">
            <img id="str" alt="Stream" style="display: none;">
            <p id="streamPlaceholder" style="color: var(--on-surface-variant); font-size: 14px;" class="translatable">
              Enter ESP32 IP address above</p>
          </div>

          <!-- Plant Selection -->
          <div style="padding: 20px; background: var(--surface-container); border-radius: 12px; margin-top: 24px;">
            <h4 style="margin: 0 0 12px 0; color: var(--primary); font-size: 14px; font-weight: 600;"
              class="translatable">
              🌱 Select Crop for Analysis
            </h4>
            <div id="plantSelector"
              style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px;">
              <!-- Plant buttons will be inserted here -->
            </div>
            <div id="selectedPlantInfo"
              style="margin-top: 12px; padding: 12px; background: var(--surface); border-radius: 8px; border-left: 4px solid var(--primary); box-shadow: var(--elevation-1);">
              <div style="font-size: 13px; font-weight: 500; color: var(--on-surface); margin-bottom: 4px;">
                <span class="translatable">Selected:</span> <span id="selectedPlantName"
                  style="color: var(--primary);">🌿 All Plants</span>
              </div>
              <div style="font-size: 12px; color: var(--on-surface-variant);" id="selectedPlantDesc">Using all 7 AI
                models for comprehensive analysis</div>
            </div>
          </div>

          <div class="actions">
            <button id="visualBtn" class="btn pri" onclick="visualOnly()" disabled><span
                class="material-symbols-rounded">document_scanner</span> <span class="translatable">Analyze
                Stream</span></button>
            <button id="toggleBtn" class="btn sec" onclick="toggleStream()" disabled><span
                class="material-symbols-rounded">videocam</span> <span class="translatable">Start Stream</span></button>
          </div>
        </article>

        <article class="card">
          <div class="head">
            <h2 class="translatable">Analyze Local Image</h2>
            <span class="pill translatable">Local</span>
          </div>
          <div id="localImagePreview" class="frame" style="display: none;min-height: 240px;"></div>
          <p id="localImagePlaceholder" style="color: var(--on-surface-variant); font-size: 14px; text-align: center;"
            class="translatable">Select an image to analyze</p>
          <div class="actions">
            <input type="file" id="imageInput" accept="image/*" capture="environment" style="display: none;">
            <input type="file" id="imageInputGallery" accept="image/*" style="display: none;">

            <div class="local-image-controls" style="display:flex; gap:8px;">
              <button class="btn sec translatable" onclick="document.getElementById('imageInput').click()">Capture
                Photo</button>
              <button class="btn sec translatable" onclick="document.getElementById('imageInputGallery').click()">Choose
                from Gallery</button>
            </div>

            <div id="batchProgress" class="batch-progress" style="display:none; margin-top:12px;">
              <div class="bar"
                style="width:0%; height:8px; border-radius:6px; background:linear-gradient(90deg,var(--primary),#0b4eb3);">
              </div>
              <div class="label" id="batchProgressLabel"
                style="margin-top:6px; font-size:13px; color:var(--on-surface-variant);"></div>
            </div>
            <button id="localAnalyzeBtn" class="btn pri" onclick="analyzeLocalImage()" disabled><span
                class="material-symbols-rounded">image_search</span> <span class="translatable">Analyze
                Image</span></button>
          </div>
        </article>

        <article class="card">
          <div class="head">
            <h2 class="translatable">Diagnostic Results</h2>
          </div>
          <div id="res" class="results">
            <div class="rc">
              <div class="t translatable">Awaiting Analysis</div>
              <p style="color: var(--on-surface-variant); font-size: 14px; margin-bottom: 16px;" class="translatable">
                Connect to a device and then run diagnostics.</p>

              <!-- Disease Detection Models Display -->
              <div style="background: rgba(26, 115, 232, 0.05); border-radius: 8px; padding: 16px; margin-top: 12px;">
                <h4 style="margin: 0 0 12px 0; color: var(--primary); font-size: 14px; font-weight: 600;"
                  class="translatable">
                  Active Detection Models
                </h4>
                <div id="modelsList" style="display: flex; flex-direction: column; gap: 8px;">
                  <!-- Models will be displayed here -->
                </div>
              </div>
            </div>
          </div>
          <div id="ctx" class="ctx">
            <h4 class="translatable">Context notes</h4>
            <ul>
              <li class="translatable">Awaiting connection...</li>
            </ul>
          </div>
        </article>
      </section>
    </div>

    <!-- ==========================================
         MONITOR TAB - Environmental Sensors
         ========================================== -->
    <div id="monitorTab" class="tab-content">
      <article class="card monitor-hero" id="monitorHero">
        <div class="head">
          <h2 class="translatable">Environment Monitor</h2>
          <div class="chip"><span class="dot" id="arduinoDot"></span><span id="arduinoStatus" class="translatable">Not
              Connected</span></div>
        </div>
        <div class="sg">
          <div class="sc">
            <div class="l translatable">Temperature</div>
            <div class="v" id="temperature">--</div>
            <div class="u">°C</div>
          </div>
          <div class="sc">
            <div class="l translatable">Humidity</div>
            <div class="v" id="humidity">--</div>
            <div class="u">%</div>
          </div>
          <div class="sc">
            <div class="l translatable">Soil Moisture</div>
            <div class="v" id="soilMoisture">--</div>
            <div class="u"></div>
          </div>
        </div>
        <div class="sc">
          <div class="l translatable">Soil Temperature</div>
          <div class="v" id="soilTemperature">--</div>
        </div>

        <!-- Soil Quality & Health Cards -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px;">
          <!-- Soil Quality (TDS) -->
          <div
            style="background: var(--surface-container); padding: 16px; border-radius: 12px; display: flex; flex-direction: column; align-items: center;">
            <div style="font-size: 13px; color: var(--on-surface-variant); margin-bottom: 4px;" class="translatable">
              Soil
              Quality</div>
            <div style="display: flex; align-items: baseline; gap: 4px;">
              <span id="tdsValue" style="font-size: 24px; font-weight: 700; color: var(--on-surface);">--</span>
              <span style="font-size: 14px; color: var(--on-surface-variant);">PPM</span>
            </div>
          </div>

          <!-- Soil Health Status -->
          <div id="soilHealthCard"
            style="background: var(--surface-container); padding: 16px; border-radius: 12px; display: flex; flex-direction: column; align-items: center; border: 1px solid transparent;">
            <div style="font-size: 13px; color: var(--on-surface-variant); margin-bottom: 4px;" class="translatable">
              Status
            </div>
            <div id="soilHealthStatus"
              style="font-size: 16px; font-weight: 700; color: var(--on-surface); text-align: center;"
              class="translatable">
              --</div>
            <div id="soilHealthAction"
              style="font-size: 11px; color: var(--on-surface-variant); margin-top: 4px; text-align: center;"
              class="translatable"></div>
          </div>
        </div>

        <!-- Rain Sensor Status -->
        <div
          style="background: var(--surface-container); padding: 16px; border-radius: 12px; display: flex; align-items: center; justify-content: space-between; margin-top: 12px; border: 1px solid var(--outline-variant);">
          <div style="display: flex; align-items: center; gap: 12px;">
            <span class="material-symbols-rounded"
              style="color: var(--primary); background: rgba(0, 100, 255, 0.1); padding: 8px; border-radius: 50%;">water_drop</span>
            <div>
              <div style="font-size: 13px; color: var(--on-surface-variant);" class="translatable">Runoff Status</div>
              <div id="rainStatus" style="font-size: 16px; font-weight: 600; color: var(--on-surface);"
                class="translatable">Runoff Not Detected</div>
              <div style="font-size: 11px; color: var(--on-surface-variant); margin-top: 2px;"><span
                  class="translatable">Threshold:</span> 50%</div>
            </div>
          </div>
          <div style="font-size: 18px; font-weight: 700; color: var(--on-surface-variant);"><span
              id="rainValue">--</span>
          </div>
        </div>

        <!-- Light Sensor Status (LDR) -->
        <div
          style="background: var(--surface-container); padding: 16px; border-radius: 12px; display: flex; align-items: center; justify-content: space-between; margin-top: 12px; border: 1px solid var(--outline-variant);">
          <div style="display: flex; align-items: center; gap: 12px;">
            <div id="lightIconBg"
              style="background: rgba(253, 216, 53, 0.2); padding: 8px; border-radius: 50%; transition: all 0.5s;">
              <span class="material-symbols-rounded" id="lightIcon"
                style="color: var(--warning); font-size: 24px; transition: all 0.5s;">wb_sunny</span>
            </div>
            <div>
              <div style="font-size: 13px; color: var(--on-surface-variant);" class="translatable">Light Status</div>
              <div id="lightStatus" style="font-size: 16px; font-weight: 600; color: var(--on-surface);"
                class="translatable">Daytime</div>
              <div id="lightDuration" style="font-size: 11px; color: var(--on-surface-variant); margin-top: 2px;">
                <span class="translatable">Duration:</span> --
              </div>
            </div>
          </div>
          <div style="font-size: 13px; font-weight: 500; color: var(--on-surface-variant); text-align: right;">
            <span class="material-symbols-rounded" style="vertical-align: middle; font-size: 16px;">wb_twilight</span>
            A2
          </div>
        </div>

        <!-- TDS Info Dropdown -->
        <div style="margin-top: 12px; background: var(--surface-container); border-radius: 12px; overflow: hidden;">
          <div onclick="toggleTdsInfo()"
            style="padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; cursor: pointer;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span class="material-symbols-rounded" style="color: var(--primary); font-size: 18px;">info</span>
              <span style="font-size: 13px; font-weight: 600; color: var(--on-surface);" class="translatable">Understand
                Soil Values</span>
            </div>
            <span class="material-symbols-rounded" id="tdsInfoArrow"
              style="color: var(--on-surface-variant); transition: transform 0.3s;">expand_more</span>
          </div>
          <div id="tdsInfoContent"
            style="display: none; padding: 0 16px 16px 16px; border-top: 1px solid var(--outline-variant);">
            <table style="width: 100%; border-collapse: collapse; font-size: 12px; color: var(--on-surface);">
              <tr style="border-bottom: 1px solid var(--outline-variant);">
                <th style="text-align: left; padding: 8px 4px; color: var(--on-surface-variant);" class="translatable">
                  PPM</th>
                <th style="text-align: left; padding: 8px 4px; color: var(--on-surface-variant);" class="translatable">
                  Status</th>
                <th style="text-align: left; padding: 8px 4px; color: var(--on-surface-variant);" class="translatable">
                  Action</th>
              </tr>
              <tr>
                <td style="padding: 8px 4px; color: var(--error);">&lt; 200</td>
                <td style="padding: 8px 4px; font-weight: 600;" class="translatable">Hungry</td>
                <td style="padding: 8px 4px;" class="translatable">Add Fertilizer</td>
              </tr>
              <tr>
                <td style="padding: 8px 4px; color: var(--primary);">200 - 800</td>
                <td style="padding: 8px 4px; font-weight: 600;" class="translatable">Optimal</td>
                <td style="padding: 8px 4px;" class="translatable">Do Nothing</td>
              </tr>
              <tr>
                <td style="padding: 8px 4px; color: #F9A825;">800 - 1500</td>
                <td style="padding: 8px 4px; font-weight: 600;" class="translatable">High</td>
                <td style="padding: 8px 4px;" class="translatable">Water Only</td>
              </tr>
              <tr>
                <td style="padding: 8px 4px; color: var(--error);">&gt; 2000</td>
                <td style="padding: 8px 4px; font-weight: 600;" class="translatable">Toxic</td>
                <td style="padding: 8px 4px;" class="translatable">FLUSH SOIL</td>
              </tr>
            </table>
          </div>
        </div>

      </article>
    </div>

    <!-- ==========================================
         ANALYTICS TAB - Charts & Performance
         ========================================== -->
    <div id="analyticsTab" class="tab-content">
      <!-- Environmental Sensor Charts -->
      <article class="card">
        <div class="head">
          <h2 class="translatable">📊 Environmental Data</h2>
          <div class="filter-group" style="margin-left: auto;">
            <button class="filter-chip active" onclick="filterSensorTimeline('1d')" data-filter="1d"
              class="translatable">1 Day</button>
            <button class="filter-chip" onclick="filterSensorTimeline('1w')" data-filter="1w" class="translatable">1
              Week</button>
            <button class="filter-chip" onclick="filterSensorTimeline('1m')" data-filter="1m" class="translatable">1
              Month</button>
            <button class="filter-chip" onclick="filterSensorTimeline('1y')" data-filter="1y" class="translatable">1
              Year</button>
            <button class="filter-chip" onclick="filterSensorTimeline('all')" data-filter="all"
              class="translatable">All</button>
          </div>
        </div>

        <!-- Temperature Chart -->
        <div class="card"
          style="padding: 24px; margin-bottom: 24px; box-shadow: none; border: 1px solid var(--outline-variant); background: var(--surface-container);">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">thermostat</span>
            <span class="translatable">Temperature History</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="temperatureChart"></canvas>
          </div>
        </div>

        <!-- Humidity Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">water_drop</span>
            <span class="translatable">Humidity History</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="humidityChart"></canvas>
          </div>
        </div>

        <!-- Soil Moisture Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">grass</span>
            <span class="translatable">Soil Moisture History</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="moistureChart"></canvas>
          </div>
        </div>

        <!-- Soil Temperature Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">device_thermostat</span>
            <span class="translatable">Soil Temperature History</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="soilTemperatureChart"></canvas>
          </div>
        </div>

        <!-- Soil Quality (TDS) Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">science</span>
            <span class="translatable">Soil Quality (TDS)</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="tdsChart"></canvas>
          </div>
        </div>

        <!-- Light Level Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">wb_sunny</span>
            <span class="translatable">Light Level History</span>
          </h3>
          <div style="position: relative; height: 300px; width: 100%;">
            <canvas id="lightChart"></canvas>
          </div>
        </div>

        <!-- Water Usage Chart -->
        <div class="card" style="padding: 20px; margin-bottom: 16px;">
          <h3
            style="font-size: 16px; margin: 0 0 16px 0; color: var(--primary); font-weight: 600; display: flex; align-items: center; gap: 8px;">
            <span class="material-symbols-rounded">water_drop</span>
            <span class="translatable">Water Usage History</span>
          </h3>

          <!-- Water Statistics Summary -->
          <div id="waterStats"
            style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-bottom: 20px;">
            <div
              style="background: var(--surface-container); padding: 12px; border-radius: 12px; border-left: 3px solid #3B82F6;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Total Usage</div>
              <div style="font-size: 20px; font-weight: 700; color: var(--on-surface);" id="waterTotalStat">0 L</div>
            </div>
            <div
              style="background: var(--surface-container); padding: 12px; border-radius: 12px; border-left: 3px solid #10B981;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Daily Avg</div>
              <div style="font-size: 20px; font-weight: 700; color: var(--on-surface);" id="waterAvgStat">0 L</div>
            </div>
            <div
              style="background: var(--surface-container); padding: 12px; border-radius: 12px; border-left: 3px solid #F59E0B;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Peak Day</div>
              <div style="font-size: 20px; font-weight: 700; color: var(--on-surface);" id="waterPeakStat">0 L</div>
            </div>
            <div
              style="background: var(--surface-container); padding: 12px; border-radius: 12px; border-left: 3px solid #8B5CF6;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Days Active</div>
              <div style="font-size: 20px; font-weight: 700; color: var(--on-surface);" id="waterDaysStat">0</div>
            </div>
          </div>

          <div style="position: relative; height: 320px; width: 100%;">
            <canvas id="waterChart"></canvas>
          </div>
        </div>
      </article>

      <article class="card">
        <div style="margin-top: 16px;">
          <div class="card" style="padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
              <h3 style="font-size: 16px; margin: 0; color: var(--primary); font-weight: 600;" class="translatable">🎯
                Model Performance Feedback</h3>
              <button onclick="resetModelFeedback()"
                style="background: var(--error); color: white; border: none; padding: 8px 16px; border-radius: 8px; cursor: pointer; font-size: 13px; font-weight: 500; display: flex; align-items: center; gap: 6px;">
                <span class="material-symbols-rounded" style="font-size: 16px;">delete</span>
                <span class="translatable">Reset Feedback Data</span>
              </button>
            </div>
            <div id="modelPrecisionChartContainer" style="position: relative; height: 400px; width: 100%;">
              <canvas id="modelPrecisionChart"></canvas>
            </div>
            <p style="margin-top: 12px; font-size: 12px; color: var(--on-surface-variant); text-align: center;"
              class="translatable">Rate model predictions to see real-world accuracy. Higher bars = better performance.
            </p>
          </div>
        </div>
      </article>


    </div>

    <!-- ==========================================
         FARM SECURITY TAB - Security Features
         ========================================== -->
    <div id="securityTab" class="tab-content">
      <article class="card">
        <div class="head">
          <h2 class="translatable">Farm Security</h2>
          <div class="chip"
            style="background: rgba(220, 38, 38, 0.15); border: 1px solid rgba(220, 38, 38, 0.3); color: #ef4444; padding: 6px 12px;">
            <span class="dot" style="background: #ef4444; box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);"></span>
            <span class="translatable">System Armed</span>
          </div>
        </div>

        <!-- ALARM BANNER (Hidden by default) -->
        <div id="alarmBanner"
          style="display: none; background: linear-gradient(135deg, #c62828 0%, #d32f2f 100%); padding: 20px; border-radius: 12px; margin-bottom: 24px; box-shadow: 0 8px 24px rgba(198, 40, 40, 0.4);">
          <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 16px;">
            <div style="display: flex; align-items: center; gap: 16px;">
              <span class="material-symbols-rounded" style="color: white; font-size: 48px;">emergency</span>
              <div>
                <div style="color: white; font-size: 24px; font-weight: 700; margin-bottom: 4px;" class="translatable">
                  🚨 SECURITY ALERT!
                </div>
                <div style="color: rgba(255,255,255,0.9); font-size: 16px;" class="translatable">Motion detected!
                  Intrusion alert active.
                </div>
                <div id="alarmTime" style="color: rgba(255,255,255,0.8); font-size: 13px; margin-top: 4px;"></div>
              </div>
            </div>
            <button onclick="stopAlarm()"
              style="background: white; color: #c62828; border: none; padding: 12px 24px; border-radius: 8px; font-size: 16px; font-weight: 700; cursor: pointer; box-shadow: 0 4px 12px rgba(0,0,0,0.3); display: flex; align-items: center; gap: 8px; transition: transform 0.2s;"
              onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
              <span class="material-symbols-rounded">notifications_off</span>
              <span class="translatable">STOP ALARM</span>
            </button>
          </div>
        </div>

        <!-- Motion Detection Status Card -->
        <div id="motionSensorCard" class="sec-card">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <span class="material-symbols-rounded" id="motionIcon"
                style="color: var(--success); background: rgba(52, 168, 83, 0.2); padding: 12px; border-radius: 50%; font-size: 32px; transition: all 0.3s;">shield</span>
              <div>
                <div style="font-size: 14px; color: var(--on-surface-variant); font-weight: 500;" class="translatable">
                  PIR Motion Sensor</div>
                <div id="motionStatus"
                  style="font-size: 22px; font-weight: 700; color: var(--on-surface); margin-top: 4px;"
                  class="translatable">No Motion Detected</div>
                <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 4px;">
                  <span class="material-symbols-rounded"
                    style="vertical-align: middle; font-size: 14px;">location_on</span>
                  Arduino Pin 5 • Range: ~7m
                </div>
              </div>
            </div>
            <div id="motionIndicator"
              style="width: 16px; height: 16px; border-radius: 50%; background: var(--success); transition: all 0.3s; box-shadow: 0 0 0 4px rgba(52, 168, 83, 0.2);">
            </div>
          </div>

          <!-- Status Details -->
          <div
            style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; padding-top: 16px; border-top: 1px solid var(--outline-variant);">
            <div style="text-align: center; padding: 12px; background: var(--surface-container); border-radius: 12px;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Status</div>
              <div id="motionStatusBadge"
                style="margin-top: 4px; padding: 4px 12px; background: rgba(52, 168, 83, 0.2); color: var(--success); border-radius: 20px; font-size: 12px; font-weight: 600; display: inline-block;"
                class="translatable">
                SECURE</div>
            </div>
            <div style="text-align: center; padding: 12px; background: var(--surface-container); border-radius: 12px;">
              <div
                style="font-size: 11px; color: var(--on-surface-variant); text-transform: uppercase; letter-spacing: 0.5px;"
                class="translatable">
                Last Event</div>
              <div id="lastMotionTime"
                style="margin-top: 4px; font-size: 13px; font-weight: 600; color: var(--on-surface);"
                class="translatable">No events yet
              </div>
            </div>
          </div>
        </div>

        <!-- Ultrasonic Distance Sensor Card -->
        <div id="ultrasonicCard" class="sec-card">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <div style="display: flex; align-items: center; gap: 12px;">
              <span class="material-symbols-rounded" id="distanceIcon"
                style="color: var(--primary); background: rgba(62, 166, 255, 0.2); padding: 12px; border-radius: 50%; font-size: 32px; transition: all 0.3s;">straighten</span>
              <div>
                <div style="font-size: 14px; color: var(--on-surface-variant); font-weight: 500;" class="translatable">
                  Ultrasonic Distance</div>
                <div id="distanceStatus"
                  style="font-size: 22px; font-weight: 700; color: var(--on-surface); margin-top: 4px;">-- cm</div>
                <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 4px;">
                  <span class="material-symbols-rounded"
                    style="vertical-align: middle; font-size: 14px;">settings_ethernet</span>
                  Arduino Pins 6/7 • Range: 2-400cm
                </div>
              </div>
            </div>
            <div id="distanceIndicator"
              style="width: 16px; height: 16px; border-radius: 50%; background: var(--primary); transition: all 0.3s; box-shadow: 0 0 0 4px rgba(62, 166, 255, 0.2);">
            </div>
          </div>
          <!-- Distance Bar -->
          <div
            style="background: var(--surface-container-high); height: 8px; border-radius: 4px; overflow: hidden; margin-top: 12px;">
            <div id="distanceBar"
              style="width: 0%; height: 100%; background: var(--primary); transition: width 0.3s ease;"></div>
          </div>
        </div>

        <!-- Motion Events Timeline -->
        <div class="sec-card">
          <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 16px;">
            <h3 style="margin: 0; font-size: 18px; font-weight: 600; color: var(--on-surface);">
              <span class="material-symbols-rounded"
                style="vertical-align: middle; margin-right: 8px; font-size: 20px;">history</span>
              <span class="translatable">Recent Motion Events</span>
            </h3>
            <div id="motionEventCount"
              style="background: var(--primary-container); color: var(--on-primary-container); padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600;">
              <span id="motionEventCount">0</span> <span class="translatable">Today</span>
            </div>
          </div>

          <!-- Events List -->
          <div id="motionEventsList" style="max-height: 300px; overflow-y: auto;">
            <div style="text-align: center; padding: 32px; color: var(--on-surface-variant);">
              <span class="material-symbols-rounded"
                style="font-size: 48px; opacity: 0.3; display: block; margin-bottom: 8px;">event_note</span>
              <div style="font-size: 14px;" class="translatable">No motion events recorded yet</div>
              <div style="font-size: 12px; margin-top: 4px; opacity: 0.7;" class="translatable">Events will appear here
                when motion is detected</div>
            </div>
          </div>
        </div>

        <!-- Security Statistics -->
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px;">
          <!-- Total Events -->
          <div class="sec-card" style="text-align: center;">
            <span class="material-symbols-rounded" style="color: var(--primary); font-size: 28px;">analytics</span>
            <div id="totalMotionEvents"
              style="font-size: 24px; font-weight: 700; color: var(--on-surface); margin-top: 8px;">0</div>
            <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 4px;" class="translatable">Total
              Events</div>
          </div>

          <!-- Today's Events -->
          <div
            style="background: var(--surface); backdrop-filter: blur(14px); -webkit-backdrop-filter: blur(14px); padding: 16px; border-radius: 12px; text-align: center; border: 1px solid var(--outline);">
            <span class="material-symbols-rounded"
              style="color: var(--secondary); font-size: 28px;">event_available</span>
            <div id="todayMotionEvents"
              style="font-size: 24px; font-weight: 700; color: var(--on-surface); margin-top: 8px;">0</div>
            <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 4px;" class="translatable">
              Today's Events</div>
          </div>
        </div>

        <!-- Security Settings -->
        <div class="sec-card">
          <h3 style="margin: 0 0 16px 0; font-size: 18px; font-weight: 600; color: var(--on-surface);">
            <span class="material-symbols-rounded"
              style="vertical-align: middle; margin-right: 8px; font-size: 20px;">settings</span>
            <span class="translatable">Security Settings</span>
          </h3>

          <!-- Motion Alerts Toggle -->
          <div
            style="display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid var(--outline-variant);">
            <div>
              <div style="font-size: 15px; font-weight: 500; color: var(--on-surface);" class="translatable">Motion
                Alerts</div>
              <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 2px;" class="translatable">
                Receive notifications on motion detection</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="motionAlertsToggle">
              <span class="toggle-slider"></span>
            </label>
          </div>

          <!-- Event Logging -->
          <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px 0;">
            <div>
              <div style="font-size: 15px; font-weight: 500; color: var(--on-surface);" class="translatable">Event
                Logging</div>
              <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 2px;" class="translatable">Save
                motion events to Firebase</div>
            </div>
            <label class="toggle-switch">
              <input type="checkbox" id="eventLoggingToggle" checked>
              <span class="toggle-slider"></span>
            </label>
          </div>

          <!-- Auto-Stop Alarm Timer -->
          <div
            style="display: flex; align-items: center; justify-content: space-between; padding: 12px 0; border-top: 1px solid var(--outline-variant);">
            <div>
              <div style="font-size: 15px; font-weight: 500; color: var(--on-surface);" class="translatable">Auto-Stop
                Alarm</div>
              <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 2px;" class="translatable">
                Automatically stop alarm after duration</div>
            </div>
            <select id="alarmDurationSelect"
              style="background: var(--surface-container-highest); color: var(--on-surface); border: none; padding: 8px 12px; border-radius: 8px; outline: none; font-family: inherit; font-size: 14px; cursor: pointer;">
              <option value="0" class="translatable">Manual Only</option>
              <option value="30" class="translatable">30 Seconds</option>
              <option value="60" class="translatable">1 Minute</option>
              <option value="300" class="translatable">5 Minutes</option>
            </select>
          </div>
        </div>
      </article>
    </div>

    <!-- ==========================================
         MORE TAB - Settings & Analysis Logs
         ========================================== -->
    <div id="moreTab" class="tab-content">
      <!-- More Tab Menu -->
      <div id="moreMenu" class="more-menu">
        <article class="card" style="padding: 0; overflow: hidden;">
          <div class="head" style="padding: 20px 20px 10px 20px; margin-bottom: 0;">
            <h2 class="translatable">Menu</h2>
          </div>
          <div style="display: flex; flex-direction: column;">

            <!-- Language Setting -->
            <div class="btn sec"
              style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; width: 100%; cursor: default; border: none; border-bottom: 1px solid var(--outline-variant); border-radius: 0; background: transparent; box-shadow: none;">
              <div style="display: flex; align-items: center; gap: 16px;">
                <div
                  style="width: 40px; height: 40px; border-radius: 50%; background: var(--surface-container); display: flex; align-items: center; justify-content: center;">
                  <span class="material-symbols-rounded"
                    style="font-size: 20px; color: var(--on-surface);">translate</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <span class="translatable"
                    style="font-weight: 600; font-size: 15px; color: var(--on-surface);">Language</span>
                  <span class="translatable" style="font-size: 12px; color: var(--on-surface-variant);">English /
                    বাংলা</span>
                </div>
              </div>
              <div id="languageSelector">
                <button onclick="translateToEnglish()" class="active">EN</button>
                <button onclick="translateToBangla()">BN</button>
              </div>
            </div>

            <!-- Theme Toggle Setting -->
            <div onclick="toggleTheme()" class="btn sec"
              style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; width: 100%; cursor: pointer; border: none; border-bottom: 1px solid var(--outline-variant); border-radius: 0; background: transparent; box-shadow: none;">
              <div style="display: flex; align-items: center; gap: 16px;">
                <div
                  style="width: 40px; height: 40px; border-radius: 50%; background: var(--surface-container); display: flex; align-items: center; justify-content: center;">
                  <span class="material-symbols-rounded" id="themeToggleBtn"
                    style="font-size: 20px; color: var(--on-surface);">dark_mode</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <span class="translatable"
                    style="font-weight: 600; font-size: 15px; color: var(--on-surface);">Appearance</span>
                  <span class="translatable" style="font-size: 12px; color: var(--on-surface-variant);">Dark / Light
                    theme</span>
                </div>
              </div>
              <span class="material-symbols-rounded theme-switch-on"
                style="font-size: 32px; color: var(--primary);">toggle_on</span>
              <span class="material-symbols-rounded theme-switch-off"
                style="font-size: 32px; color: var(--on-surface-variant);">toggle_off</span>
            </div>

            <!-- Analytics Page Shortcut -->
            <button class="btn sec" onclick="switchTab('analyticsTab');"
              style="display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; width: 100%; cursor: pointer; border: none; border-bottom: 1px solid var(--outline-variant); border-radius: 0; background: transparent; box-shadow: none; text-align: left;">
              <div style="display: flex; align-items: center; gap: 16px;">
                <div
                  style="width: 40px; height: 40px; border-radius: 50%; background: var(--surface-container); display: flex; align-items: center; justify-content: center;">
                  <span class="material-symbols-rounded"
                    style="font-size: 20px; color: var(--primary);">monitoring</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <span class="translatable"
                    style="font-weight: 600; font-size: 15px; color: var(--on-surface);">Analytics</span>
                  <span class="translatable" style="font-size: 12px; color: var(--on-surface-variant);">View Charts &
                    Reports</span>
                </div>
              </div>
              <span class="material-symbols-rounded"
                style="font-size: 24px; color: var(--on-surface-variant);">chevron_right</span>
            </button>

            <button class="btn sec" onclick="showLogsPage()"
              style="justify-content: flex-start; text-align: left; padding: 16px 20px; border: none; border-radius: 0; background: transparent; box-shadow: none; width: 100%;">
              <div style="display: flex; align-items: center; gap: 16px; width: 100%;">
                <div
                  style="width: 40px; height: 40px; border-radius: 50%; background: var(--surface-container); display: flex; align-items: center; justify-content: center;">
                  <span class="material-symbols-rounded"
                    style="font-size: 20px; color: var(--on-surface);">list_alt</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: flex-start;">
                  <span class="translatable"
                    style="font-weight: 600; font-size: 15px; color: var(--on-surface);">Analysis Logs</span>
                  <span class="translatable" style="font-size: 12px; color: var(--on-surface-variant);">View
                    history</span>
                </div>
                <span class="material-symbols-rounded"
                  style="margin-left: auto; color: var(--on-surface-variant);">chevron_right</span>
              </div>
            </button>
            <!-- Future settings can be added here -->
          </div>
        </article>
      </div>

      <!-- Analysis Logs Page (hidden by default) -->
      <div id="logsPage" class="logs-page">
        <button class="back-button" onclick="hideLogsPage()">
          <span class="material-symbols-rounded">arrow_back</span> <span class="translatable">Back to More</span>
        </button>

        <article class="card">
          <div class="head">
            <h2 class="translatable">Diagnostic History</h2>
            <div style="display: flex; gap: 8px; align-items: center;">
              <span class="firebase-status" id="firebaseStatus">
                <span id="firebaseIcon" class="material-symbols-rounded"
                  style="font-size: 18px;">radio_button_unchecked</span>
                <span id="firebaseStatusText" class="translatable">Not connected</span>
              </span>
              <button class="btn sec" onclick="syncWithFirebase()"><span class="translatable">Sync</span></button>
              <button class="btn sec" onclick="resyncLocalLogs()"><span class="translatable">Resync</span></button>
              <div id="resyncProgress" class="resync-progress" style="display:none; align-items:center; gap:8px;">
                <div class="resync-bar" aria-hidden="true">
                  <div class="resync-bar-fill" style="width:0%"></div>
                </div>
                <div class="resync-text" id="resyncProgressText"></div>
              </div>
            </div>
          </div>

          <div class="card" style="padding: 12px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
              <h3 style="font-size: 14px; margin: 0; color: var(--on-surface-variant);" class="translatable">Analysis
                Log</h3>
              <div class="analysis-controls" style="display: flex; gap: 8px; align-items: center; width: 100%;">
                <div class="filter-group">
                  <button class="filter-chip active" onclick="filterHistory('all')" data-filter="all">All</button>
                  <button class="filter-chip" onclick="filterHistory('diseases')"
                    data-filter="diseases">Diseases</button>
                  <button class="filter-chip" onclick="filterHistory('healthy')" data-filter="healthy">Healthy</button>
                </div>
                <button class="btn sec translatable" onclick="loadFromFirebase()"
                  style="padding: 6px 12px; font-size: 12px;">📥 Load</button>
                <button class="btn pri" onclick="clearAnalyticsData()" style="padding: 8px 16px; font-size: 13px;"><span
                    class="material-symbols-rounded" style="font-size: 16px;">delete</span> <span
                    class="translatable">Clear Diagnostic Log</span></button>
              </div>
            </div>
            <div class="history-panel" id="historyPanel">
              <p style="text-align: center; color: var(--on-surface-variant); padding: 32px;" class="translatable">No
                diagnostic logs yet. Run your first analysis to get started.</p>
            </div>
          </div>
        </article>
      </div>
    </div>
    </main>

    <!-- ========================================== -->


    <!-- Toast container for user messages -->
    <div id="toasts" aria-live="polite"
      style="position: fixed; right: 16px; bottom: 16px; display: flex; flex-direction: column; gap: 8px; z-index: 9999;">
    </div>

    <script>
      // ==========================================
      // THEME MANAGEMENT
      // ==========================================
      function initTheme() {
        const savedTheme = localStorage.getItem('theme');
        const systemDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const themeBtn = document.getElementById('themeToggleBtn');

        let theme = savedTheme;
        if (!theme) {
          theme = systemDark ? 'dark' : 'light';
        }

        document.documentElement.setAttribute('data-theme', theme);
        if (themeBtn) themeBtn.textContent = theme === 'dark' ? 'dark_mode' : 'light_mode';
      }

      function toggleTheme() {
        const current = document.documentElement.getAttribute('data-theme');
        const newTheme = current === 'dark' ? 'light' : 'dark';

        document.documentElement.setAttribute('data-theme', newTheme);
        localStorage.setItem('theme', newTheme);

        const themeBtn = document.getElementById('themeToggleBtn');
        if (themeBtn) themeBtn.textContent = newTheme === 'dark' ? 'dark_mode' : 'light_mode';

        // Update charts to reflect new theme colors
        setTimeout(updateCharts, 100);
      }

      // Initialize immediately
      initTheme();

      // Listen for system changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        if (!localStorage.getItem('theme')) {
          const newTheme = e.matches ? 'dark' : 'light';
          document.documentElement.setAttribute('data-theme', newTheme);
          const themeBtn = document.getElementById('themeToggleBtn');
          if (themeBtn) themeBtn.textContent = newTheme === 'dark' ? 'dark_mode' : 'light_mode';
          setTimeout(updateCharts, 100);
        }
      });

      // ==========================================
      // TAB NAVIGATION SYSTEM
      // ==========================================

      /**
       * Show a specific tab and hide others
       * @param {string} tabName - The tab to show ('home', 'analyse', 'monitor', 'analytics', 'more')
       */
      function showTab(tabName) {
        // Hide all tabs
        const allTabs = document.querySelectorAll('.tab-content');
        allTabs.forEach(tab => {
          tab.classList.remove('active');
        });

        // Show selected tab
        const targetTab = document.getElementById(tabName + 'Tab');
        if (targetTab) {
          targetTab.classList.add('active');

          // Scroll to top smoothly
          window.scrollTo({
            top: 0,
            behavior: 'smooth'
          });
        }

        // Update nav items
        const navItems = document.querySelectorAll('.bottom-nav .nav-item');
        navItems.forEach(item => {
          item.classList.remove('active');
        });

        // Add active class to clicked nav item
        event.currentTarget.classList.add('active');

        // Store active tab in localStorage for persistence
        try {
          localStorage.setItem('activeTab', tabName);
        } catch (e) {
          console.warn('Could not save active tab to localStorage');
        }

        // Trigger chart updates if analytics tab is opened
        if (tabName === 'analytics') {
          setTimeout(() => {
            updateCharts();
          }, 100);
        }
      }

      /**
       * Show the Analysis Logs page (nested under More tab)
       */
      function showLogsPage() {
        document.getElementById('moreMenu').style.display = 'none';
        document.getElementById('logsPage').classList.add('active');
      }

      /**
       * Hide the Analysis Logs page and return to More menu
       */
      function hideLogsPage() {
        document.getElementById('logsPage').classList.remove('active');
        document.getElementById('moreMenu').style.display = 'block';
      }

      // Restore last active tab on page load
      document.addEventListener('DOMContentLoaded', () => {
        try {
          const savedTab = localStorage.getItem('activeTab');
          if (savedTab && savedTab !== 'home') {
            // Find and click the corresponding nav item
            const navItems = document.querySelectorAll('.bottom-nav .nav-item');
            navItems.forEach(item => {
              const onclick = item.getAttribute('onclick');
              if (onclick && onclick.includes(savedTab)) {
                // Manually trigger tab switch
                document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
                document.getElementById(savedTab + 'Tab')?.classList.add('active');
                document.querySelectorAll('.bottom-nav .nav-item').forEach(i => i.classList.remove('active'));
                item.classList.add('active');
              }
            });
          }
        } catch (e) {
          console.warn('Could not restore active tab');
        }
      });

      function toggleTdsInfo() {
        const content = document.getElementById('tdsInfoContent');
        const arrow = document.getElementById('tdsInfoArrow');
        if (content.style.display === 'none') {
          content.style.display = 'block';
          arrow.style.transform = 'rotate(180deg)';
        } else {
          content.style.display = 'none';
          arrow.style.transform = 'rotate(0deg)';
        }
      }
    </script>

    <script>
      document.addEventListener('DOMContentLoaded', () => {
        const cards = document.querySelectorAll('.card');
        cards.forEach((card, index) => {
          card.classList.add('card-enter');
          card.style.animationDelay = `${index * 100}ms`;
        });

        // Handle local image selection (camera input)
        function handleLocalImageFile(file) {
          if (!file) return;
          const reader = new FileReader();
          reader.onload = (e) => {
            const preview = document.getElementById('localImagePreview');
            const placeholder = document.getElementById('localImagePlaceholder');
            preview.innerHTML = `<img src="${e.target.result}" style="max-width:100%; max-height:400px; border-radius:8px;" alt="Selected image">`;
            preview.style.display = 'block';
            if (placeholder) placeholder.style.display = 'none';
            document.getElementById('localAnalyzeBtn').disabled = false;
          };
          reader.readAsDataURL(file);
        }

        document.getElementById('imageInput').addEventListener('change', (event) => {
          handleLocalImageFile(event.target.files && event.target.files[0]);
        });

        // Gallery/file-manager input
        document.getElementById('imageInputGallery').addEventListener('change', (event) => {
          handleLocalImageFile(event.target.files && event.target.files[0]);
        });
      });


      async function infer(base64Image, model) {
        try {
          console.log('Calling model:', model.name);
          const rf = await fetch('https://serverless.roboflow.com/' + model.id + '?api_key=' + K, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: base64Image
          });

          if (!rf.ok) {
            throw Error('HTTP ' + rf.status);
          }

          const data = await rf.json();
          console.log(model.name + ' response:', data);

          // Apply class name mapping if model returns numeric IDs
          if (CLASS_NAME_MAPPING[model.id] && data.predictions) {
            data.predictions = data.predictions.map(pred => {
              if (CLASS_NAME_MAPPING[model.id][pred.class]) {
                console.log('Mapping class ID "' + pred.class + '" to "' + CLASS_NAME_MAPPING[model.id][pred.class] + '" for ' + model.name);
                return { ...pred, class: CLASS_NAME_MAPPING[model.id][pred.class] };
              }
              return pred;
            });
          }

          return { name: model.name, type: model.type, data: data, error: null, modelId: model.id };
        } catch (e) {
          console.error(model.name + ' error:', e);
          return { name: model.name, type: model.type, data: null, error: e.message, modelId: model.id };
        }
      }

      function calculateConsensus(results) {
        const diseaseDetections = [];
        const healthyDetections = [];

        results.forEach(r => {
          if (r.error) return;

          let disease = '';
          let conf = 0;

          if (r.type === 'detection' && r.data.predictions && r.data.predictions.length > 0) {
            const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
            disease = top.class;
            conf = top.confidence * 100;

            if (!disease || disease === '' || /^\d+$/.test(disease)) {
              console.warn('⚠️ Model "' + r.name + '" returned invalid class name:', disease);
              return;
            }
          } else if (r.type === 'classification' && (r.data.top || r.data.predicted_classes)) {
            disease = r.data.top || r.data.predicted_classes[0];
            conf = (r.data.confidence || 0) * 100;
          }

          const diseaseNormalized = (disease || '').toLowerCase().trim();

          if (conf > 0 && disease) {
            if (diseaseNormalized === 'healthy' || diseaseNormalized === 'no detection') {
              healthyDetections.push({ model: r.name, disease, confidence: conf });
            } else {
              diseaseDetections.push({ model: r.name, disease, confidence: conf });
            }
          }
        });

        let primaryDisease = 'Healthy';
        let primaryConfidence = 0;
        let consensusNote = '';

        if (diseaseDetections.length > 0) {
          const diseaseVotes = {};
          diseaseDetections.forEach(d => {
            const key = d.disease.toLowerCase();
            if (!diseaseVotes[key]) {
              diseaseVotes[key] = { disease: d.disease, votes: 0, totalConf: 0, models: [] };
            }
            diseaseVotes[key].votes++;
            diseaseVotes[key].totalConf += d.confidence;
            diseaseVotes[key].models.push(d.model);
          });

          let bestDisease = null;
          let bestScore = 0;

          for (const key in diseaseVotes) {
            const vote = diseaseVotes[key];
            const avgConf = vote.totalConf / vote.votes;
            const score = (vote.votes * 50) + avgConf;

            if (score > bestScore) {
              bestScore = score;
              bestDisease = vote;
            }
          }

          if (bestDisease) {
            primaryDisease = bestDisease.disease;
            primaryConfidence = bestDisease.totalConf / bestDisease.votes;

            if (healthyDetections.length > 0) {
              consensusNote = '⚠️ Consensus Override: ' + diseaseDetections.length + ' model(s) detected disease, ' +
                healthyDetections.length + ' said healthy. Prioritizing disease detection.';
            }

            if (bestDisease.votes > 1) {
              consensusNote += ' ✓ ' + bestDisease.votes + ' models agree on "' + primaryDisease + '"';
            }
          }
        } else if (healthyDetections.length === results.length - results.filter(r => r.error).length) {
          primaryDisease = 'Healthy';
          primaryConfidence = healthyDetections.reduce((sum, h) => sum + h.confidence, 0) / healthyDetections.length;
          consensusNote = '✓ All models agree: Leaf appears healthy';
        }

        return {
          disease: primaryDisease,
          confidence: primaryConfidence,
          note: consensusNote,
          diseaseCount: diseaseDetections.length,
          healthyCount: healthyDetections.length
        };
      }

      // Resize an image file on the client to limit CPU/memory usage on phones
      function resizeImageFile(file, maxDim = 1024, quality = 0.8) {
        return new Promise((resolve, reject) => {
          const img = new Image();
          const reader = new FileReader();
          reader.onload = (e) => {
            img.onload = () => {
              let { width, height } = img;
              const max = Math.max(width, height);
              const scale = max > maxDim ? (maxDim / max) : 1;
              const canvas = document.createElement('canvas');
              canvas.width = Math.round(width * scale);
              canvas.height = Math.round(height * scale);
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
              try {
                const dataUrl = canvas.toDataURL('image/jpeg', quality);
                resolve(dataUrl);
              } catch (err) { reject(err); }
            };
            img.onerror = (err) => reject(err);
            img.src = e.target.result;
          };
          reader.onerror = (err) => reject(err);
          reader.readAsDataURL(file);
        });
      }

      // Run inference in small batches to avoid saturating CPU/memory on mobile devices
      async function runInferenceBatched(activeModels, base64Image, batchSize = 3, progressCb = null) {
        const results = [];
        const total = activeModels.length;
        for (let i = 0; i < activeModels.length; i += batchSize) {
          const batch = activeModels.slice(i, i + batchSize);
          const promises = batch.map(m => infer(base64Image, m).catch(e => ({ error: true, message: e.message })));
          const batchResults = await Promise.all(promises);
          results.push(...batchResults);
          // Let the UI breathe and update
          await new Promise(r => setTimeout(r, 50));
          if (typeof progressCb === 'function') {
            progressCb(Math.min(results.length, total), total);
          }
        }
        return results;
      }

      async function analyzeLocalImage() {
        const camInput = document.getElementById('imageInput');
        const galleryInput = document.getElementById('imageInputGallery');
        const analyzeBtn = document.getElementById('localAnalyzeBtn');

        const file = (camInput && camInput.files && camInput.files[0]) || (galleryInput && galleryInput.files && galleryInput.files[0]);
        if (!file) {
          alert('Please select an image first.');
          return;
        }

        // Disable button and show spinner
        analyzeBtn.disabled = true;
        analyzeBtn.innerHTML = '<div style="width: 20px; height: 20px; border: 3px solid rgba(255,255,255,0.3); border-top-color: #fff; border-radius: 50%; animation: spin 1s linear infinite;"></div><span>' + translateText('Analyzing...') + '</span>';

        // Resize/compress image first to reduce memory and CPU on phones
        try {
          const resizedDataUrl = await resizeImageFile(file, 1024, 0.8);
          // show preview
          const preview = document.getElementById('localImagePreview');
          if (preview) {
            preview.style.display = 'block';
            preview.innerHTML = `<img src="${resizedDataUrl}" style="max-width:100%; max-height:400px; border-radius:8px;" alt="Selected image">`;
            const placeholder = document.getElementById('localImagePlaceholder');
            if (placeholder) placeholder.style.display = 'none';
          }

          // Get active models based on plant selection
          const plantName = PLANT_TYPES.find(p => p.id === selectedPlantType)?.name || 'All Plants';
          const activeModels = getActiveModels();

          document.getElementById('res').innerHTML = `<div class="rc"><div class="t">Analyzing local image of ${plantName} with ${activeModels.length} AI models...</div><p style="color: var(--on-surface-variant); font-size: 14px;">Processing image...</p></div>`;

          const base64Image = resizedDataUrl.split(',')[1];

          // Show and initialize progress
          const progressEl = document.getElementById('batchProgress');
          const progressBar = progressEl ? progressEl.querySelector('.bar') : null;
          const progressLabel = document.getElementById('batchProgressLabel');
          if (progressEl) { progressEl.style.display = 'block'; progressEl.setAttribute('aria-hidden', 'false'); }
          if (progressBar) { progressBar.style.width = '0%'; }
          if (progressLabel) { progressLabel.textContent = '0 / ' + activeModels.length + ' models'; }

          // Run inference in batches with progress callback
          const results = await runInferenceBatched(activeModels, base64Image, 3, (done, total) => {
            const pct = Math.round((done / total) * 100);
            if (progressBar) progressBar.style.width = pct + '%';
            if (progressLabel) progressLabel.textContent = done + ' / ' + total + ' models';
          });

          const consensusData = calculateConsensus(results);
          geminiRecommendation = null; // Set to null for local analysis
          showMultiModelResults(results, null, consensusData);

          // Hide progress after a moment
          setTimeout(() => { if (progressEl) { progressEl.style.display = 'none'; progressEl.setAttribute('aria-hidden', 'true'); } }, 700);
        } catch (e) {
          document.getElementById('res').innerHTML = `<div class="rc"><div class="t">Failed<span class="badge err">Error</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">${e.message || e}</p></div>`;
        } finally {
          // Re-enable button and restore text
          analyzeBtn.disabled = false;
          analyzeBtn.innerHTML = '<span class="material-symbols-rounded">image_search</span> <span class="translatable">' + translateText('Analyze Image') + '</span>';
        }
      }



    </script>

    <script>

    </script>

    <!-- Translation feature removed -->
    <script>
      // Simple translation toggles (English <-> Bangla)
      const TRANSLATIONS_BN = {
        /* UI */
        'Advanced Crop Diagnostics Platform': 'উন্নত ফসল নির্ণয়ের প্ল্যাটফর্ম',
        'Agri-Nigrani: Crop Analysis': 'কৃষি-নিগ্রানি: ফসল বিশ্লেষণ',
        'Real-time analysis, AI-driven insights, and sensor integration.': 'রিয়েল-টাইম বিশ্লেষণ, এআই-চালিত অন্তর্দৃষ্টি এবং সেন্সর ইন্টিগ্রেশন।',

        /* Navigation */
        'Home': 'হোম',
        'Analyse': 'বিশ্লেষণ',
        'Monitor': 'মনিটর',
        'Analytics': 'অ্যানালিটিক্স',
        'More': 'আরো',
        'More Options': 'আরো অপশন',
        'Analysis Logs': 'বিশ্লেষণ লগ',
        'Back to More': 'আরো-তে ফিরে যান',
        'Pump Control': 'পাম্প নিয়ন্ত্রণ',

        'SYSTEM DASHBOARD': 'সিস্টেম ড্যাশবোর্ড',
        'Restart': 'পুনরায় চালু করুন',
        'ESP': 'ইএসপি',
        'Camera': 'ক্যামেরা',
        'MQTT': 'এমকিউটিটি',
        'Firebase': 'ফায়ারবেস',
        'Live Camera Stream': 'লাইভ ক্যামেরা স্ট্রিম',
        'Live': 'লাইভ',
        'ESP32 Camera IP:': 'ইএসপি৩২ ক্যামেরা আইপি:',
        'Connect': 'সংযোগ করুন',
        'Enter ESP32 IP address above': 'উপরের ইএসপি৩২ আইপি ঠিকানা লিখুন',
        '🌱 Select Crop for Analysis': '🌱 বিশ্লেষণের জন্য ফসল নির্বাচন করুন',
        'Selected:': 'নির্বাচিত:',
        'Using all 7 AI models for comprehensive analysis': 'সম্পূর্ণ বিশ্লেষণের জন্য ৭টি এআই মডেল ব্যবহার করা হচ্ছে',
        'Analyze Stream': 'স্ট্রিম বিশ্লেষণ করুন',
        'Start Stream': 'স্ট্রিম শুরু করুন',
        'Analyze Local Image': 'স্থানীয় চিত্র বিশ্লেষণ করুন',
        'Local': 'স্থানীয়',
        'Select an image to analyze': 'বিশ্লেষণের জন্য একটি চিত্র নির্বাচন করুন',
        'Choose Image': 'চিত্র নির্বাচন করুন',
        'Analyze Image': 'চিত্র বিশ্লেষণ করুন',
        'Diagnostic Results': 'ডায়াগনস্টিক ফলাফল',
        'Awaiting Analysis': 'বিশ্লেষণের জন্য অপেক্ষা করছে',
        'Connect to a device and then run diagnostics.': 'একটি ডিভাইসের সাথে সংযোগ করুন এবং তারপর ডায়াগনস্টিক চালান।',
        'Environment Monitor': 'পরিবেশ মনিটর',
        'Not Connected': 'সংযুক্ত নয়',
        'Temperature': 'তাপমাত্রা',
        'Humidity': 'আর্দ্রতা',
        'Soil Moisture': 'মাটির আর্দ্রতা',
        'Toggle Pump': 'পাম্প চালু/বন্ধ করুন',
        'Diagnostic History': 'ডায়াগনস্টিক ইতিহাস',
        'Not connected': 'সংযুক্ত নয়',
        'Sync': 'সিঙ্ক',
        'Detection Timeline': 'সনাক্তকরণ সময়রেখা',
        'Analysis Log': 'বিশ্লেষণ লগ',
        'Load': 'লোড',
        'All': 'সব',
        'Diseases': 'রোগ',
        'Healthy': 'সুস্থ',
        'Clear Diagnostic Log': 'ডায়াগনস্টিক লগ মুছুন',
        'No diagnostic logs yet. Run your first analysis to get started.': 'এখনও কোনও ডায়াগনস্টিক লগ নেই। শুরু করতে আপনার প্রথম বিশ্লেষণ চালান।',

        /* Plants */
        'All Plants (General)': 'সব ফসল (সাধারণ)',
        'Rice': 'ধান',
        'Wheat': 'গম',
        'Chili/Pepper': 'মরিচ/কাঁটাবেল',
        'Potato': 'আলু',
        'Tomato': 'টমেটো',
        'Eggplant/Brinjal': 'বেগুন/ব্রিনজাল',
        'models': 'মডেল',

        /* Models */
        'Object Detection (YOLOv8)': 'অবজেক্ট সনাক্তকরণ (YOLOv8)',
        'Rice Disease Detection (YOLOv8s)': 'ধান রোগ সনাক্তকরণ (YOLOv8s)',
        'Wheat Disease (100% Accuracy)': 'গম রোগ (১০০% নির্ভুলতা)',
        'Chili Plant Disease (81% mAP)': 'মরিচ গাছের রোগ (৮১% mAP)',
        'Potato Disease (98.8% mAP)': 'আলু রোগ (৯৮.৮% mAP)',
        'Tomato Disease (92.3% mAP)': 'টমেটো রোগ (৯২.৩% mAP)',
        'Eggplant Disease (47.8% mAP)': 'বেগুন রোগ (৪৭.৮% mAP)',

        /* Result / UI strings */
        'Analyzing': 'বিশ্লেষণ করা হচ্ছে',
        'with': 'সাথে',
        'AI models': 'এআই মডেল',
        'Multi-Model Analysis': 'বহু-মডেল বিশ্লেষণ',

        'Smart Consensus Decision': 'স্মার্ট সম্মত সিদ্ধান্ত',
        'Final Verdict:': 'চূড়ান্ত সিদ্ধান্ত:',
        'Model(s) Detected Disease': 'মডেল(গুলি) রোগ সনাক্ত করেছে',
        'Model(s) Said Healthy': 'মডেল(গুলি) সুস্থ বলেছে',

        /* Table headers and labels */
        'Model': 'মডেল',
        'Disease Detected': 'সনাক্ত রোগ',
        'Confidence': 'আত্মবিশ্বাস',
        'Recommended Treatment': 'প্রস্তাবিত চিকিৎসা',
        'Your Feedback': 'আপনার প্রতিক্রিয়া',
        'No detection': 'কোনো সনাক্তকরণ নেই',
        'Unknown Disease': 'অজানা রোগ',

        /* Badges */
        'High': 'উচ্চ',
        'Medium': 'মধ্য',
        'Low': 'কম',
        'Error': 'ত্রুটি',
        'Invalid': 'অবৈধ',

        /* Common diseases (subset) */
        'Bacterial Spot': 'ব্যাকটেরিয়াল স্পট',
        'Early Blight': 'প্রাথমিক ব্লাইট',
        'Late Blight': 'পরবর্তী ব্লাইট',
        'Leaf Mold': 'পাতা ছেঁড়া',
        'Septoria Leaf Spot': 'সেপ্টোরিয়া লিফ স্পট',
        'Spider Mites': 'মাকড়শা কীট',
        'Target Spot': 'টার্গেট স্পট',
        'Mosaic Virus': 'মোজাইক ভাইরাস',
        'Yellow Leaf Curl Virus': 'হলুদ পাতার কার্ল ভাইরাস',
        'Powdery Mildew': 'পাউডারি মিলডিউ',
        'Rust': 'রস্ট',
        'Anthracnose': 'অ্যানথ্রাকনোজ',
        'Blight': 'ব্লাইট',
        'Scab': 'স্ক্যাব',
        'Wilt': 'উইল্ট',
        'Downy Mildew': 'ডাউনি মিলডিউ',
        'Alternaria': 'অলটারনারিয়া',
        'Fusarium': 'ফুসারিয়াম',
        'Damping Off': 'ডাম্পিং অফ',
        'Fruit Rot': 'ফল পচা',
        'Gray Mold': 'শুঁটকি ছত্রাক',
        'Stem Rot': 'তনু পচা',
        'Root Rot': 'মূল পচা',
        'Collar Rot': 'কলার রট',
        'Black Spot': 'কালো দাগ',
        'Brown Spot': 'পর্ণ দাগ',
        'Bacterial Wilt': 'ব্যাকটেরিয়াল উইল্ট',
        'Cercospora Leaf Spot': 'সেরকস্পোরা লিফ স্পট',
        'Sooty Mold': 'সুটি ছত্রাক',
        'Leaf Blight': 'পাতা ব্লাইট',
        'Southern Blight': 'সাদার্ন ব্লাইট',
        'Verticillium Wilt': 'ভার্টিসিলিয়াম উইল্ট',
        'Club Root': 'ক্লাব রুট',
        'Black Rot': 'কালো পচা',
        'White Rust': 'সাদা জং',
        'Purple Blotch': 'বেগুনি দাগ',
        'Soft Rot': 'নরম পচা',
        'Cucumber Mosaic': 'শসার মোজাইক',
        'Gummy Stem Blight': 'গামি স্টেম ব্লাইট',
        'Angular Leaf Spot': 'অ্যাঙ্গুলার লিফ স্পট',
        'Bacterial Canker': 'ব্যাকটেরিয়াল ক্যান্কার',
        'Aphids': 'অ্যাফিডস',
        'Whitefly': 'হোয়াইটফ্লাই',
        'Thrips': 'থ্রিপস',
        'Fruit Borer': 'ফল বোরার',
        'Leaf Miner': 'পাতা খননকারী',
        'Stem Borer': 'তনু বোরার',
        'Cutworm': 'কাটওয়ার্ম',
        'Nematodes': 'নেমাটোডস',

        /* Runtime / status */
        'Connecting...': 'সংযোগ করা হচ্ছে...',
        'ESP32 reachable': 'ইএসপি৩২ পৌঁছেছে',
        'Cannot reach ESP32 at': 'ইএসপি৩২ পৌঁছানো যাচ্ছে না',
        'Ready. Click "Start stream" to preview.': 'প্রস্তুত। পূর্বরূপ দেখতে "স্টার্ট স্ট্রিম" ক্লিক করুন।',
        'No Connection': 'সংযোগ নেই',
        '⏳ Loading...': 'লোড হচ্ছে...',
        '📥 Load': 'লোড',
        '❌ Failed to load image': 'চিত্র লোড ব্যর্থ হয়েছে',
        '⏳ Syncing...': 'সিঙ্ক হচ্ছে...',
        '🔄 Sync': 'সিঙ্ক',
        'Starting...': 'শুরু হচ্ছে...',
        'Connecting to stream...': 'স্ট্রিমে সংযোগ করা হচ্ছে...',
        'Initializing stream...': 'স্ট্রিম প্রাথমিককরণ...',
        'Stream connected': 'স্ট্রিম সংযুক্ত',
        'Stop Live View': 'লাইভ ভিউ বন্ধ করুন',
        'Stop stream': 'স্ট্রিম বন্ধ করুন',
        'Start Live View': 'লাইভ ভিউ শুরু করুন',
        'Stream paused': 'স্ট্রিম বিরত',
        '✓ Marked as correct': '✓ সঠিক হিসেবে চিহ্নিত',
        '✗ Marked as wrong': '✗ ভুল হিসেবে চিহ্নিত',
        'Feedback recorded for': 'প্রতিক্রিয়া রেকর্ড করা হয়েছে',
        'Analyzing...': 'বিশ্লেষণ চলছে...',
        'Capturing and processing image': 'চিত্র ক্যাপচার এবং প্রক্রিয়াকরণ হচ্ছে',

        /* Firebase */
        'Local storage only': 'শুধুমাত্র লোকাল স্টোরেজ',

        /* Feedback */
        'Feedback recorded for ': 'প্রতিক্রিয়া রেকর্ড করা হয়েছে: ',
        'No image available': 'কোনও চিত্র নেই',

        /* Urgency/Severity */
        'immediate': 'তাত्कालিক',
        'immediate - remove infected plants': 'তাত্ক্ষণিক - আক্রান্ত গাছ অপসারণ করুন',
        'within 24-48 hours': '২৪-৪৮ ঘণ্টার মধ্যে',
        'within 24 hours': '২৪ ঘণ্টার মধ্যে',
        'within 1 week': '১ সপ্তাহের মধ্যে',
        'routine': 'সাধারণ',
        'mild': 'মৃদু',
        'moderate': 'মধ্য',
        'severe': 'গুরুতর',
        'severity': 'তীব্রতা',
        'Connected': 'সংযুক্ত',
        'Correct': 'সঠিক',
        'Wrong': 'ভুল',
        'Model:': 'মডেল:',

        /* Menu & Navigation */
        'Menu': 'মেনু',
        'Language': 'ভাষা',
        'Appearance': 'চেহারা',
        'Dark / Light theme': 'ডার্ক / লাইট থিম',
        'Analytics': 'অ্যানালিটিক্স',
        'View Charts & Reports': 'চার্ট এবং রিপোর্ট দেখুন',
        'Analysis Logs': 'বিশ্লেষণ লগ',
        'View history': 'ইতিহাস দেখুন',
        'Back to More': 'ফিরে যান',
        'Home': 'হোম',
        'Analyse': 'বিশ্লেষণ',
        'Monitor': 'মনিটর',
        'Security': 'নিরাপত্তা',

        /* Status & Common */
        'NTP:': 'NTP:',
        'Schedule:': 'শিডিউল:',
        'Offline': 'অফলাইন',
        'Resets 00:00': 'রাত ১২টায় রিসেট',
        'Threshold:': 'সীমা:',
        'Duration:': 'সময়কাল:',
        'Status': 'অবস্থা',
        'Last Event': 'শেষ ঘটনা',
        'Not Connected': 'সংযুক্ত নয়',
        'Daytime': 'দিনের বেলা',
        'Nighttime': 'রাত',
        'Optimal': 'আদর্শ',
        'High': 'উচ্চ',
        'Toxic': 'বিষাক্ত',
        'Hungry': 'সার প্রয়োজন',
        'Add Fertilizer': 'সার দিন',
        'Do Nothing': 'কিছু করবেন না',
        'Water Only': 'শুধু জল দিন',
        'FLUSH SOIL': 'মাটি ধুয়ে ফেলুন',
        'PPM': 'PPM',

        /* Alerts & Actions */
        '🚨 SECURITY ALERT!': '🚨 নিরাপত্তা সতর্কতা!',
        'Motion detected! Intrusion alert active.': 'গতি সনাক্ত হয়েছে! অনুপ্রবেশ সতর্কতা সক্রিয়।',
        'STOP ALARM': 'অ্যালার্ম বন্ধ করুন',
        'DRY RUN DETECTED': 'ড্রাই রান সনাক্ত হয়েছে',
        'Pump stopped to prevent damage. Check water source.': 'ক্ষতি রোধে পাম্প বন্ধ করা হয়েছে। জলের উৎস পরীক্ষা করুন।',
        'Runoff Not Detected': 'জমা জল পাওয়া যায়নি',
        'Runoff Detected': 'জমা জল সনাক্ত হয়েছে',
        'No Motion Detected': 'কোনো গতি পাওয়া যায়নি',
        'Motion Detected': 'গতি সনাক্ত হয়েছে',
        'SECURE': 'নিরাপদ',
        'No events yet': 'কোনো ঘটনা ঘটেনি',
        'Today': 'আজ',
        'Total Events': 'মোট ঘটনা',
        "Today's Events": 'আজকের ঘটনা',
        'Security Settings': 'নিরাপত্তা সেটিংস',
        'Motion Alerts': 'মোশন অ্যালার্ট',
        'Receive notifications on motion detection': 'গতি সনাক্ত হলে বিজ্ঞপ্তি পান',
        'Event Logging': 'ইভেন্ট লগিং',
        'Save motion events to Firebase': 'Firebase-এ মোশন ইভেন্ট সেভ করুন',
        'Auto-Stop Alarm': 'অটো-স্টপ অ্যালার্ম',
        'Automatically stop alarm after duration': 'নির্দিষ্ট সময় পর স্বয়ংক্রিয়ভাবে অ্যালার্ম বন্ধ করুন',
        'Manual Only': 'শুধুমাত্র ম্যানুয়াল',
        '30 Seconds': '৩০ সেকেন্ড',
        '1 Minute': '১ মিনিট',
        '5 Minutes': '৫ মিনিট',

        /* Analytics & Sensor */
        'Temperature History': 'তাপমাত্রার ইতিহাস',
        'Humidity History': 'আর্দ্রতার ইতিহাস',
        'Soil Moisture History': 'মাটির আর্দ্রতার ইতিহাস',
        'Soil Temperature History': 'মাটির তাপমাত্রার ইতিহাস',
        'Soil Quality (TDS)': 'মাটির গুণমান (TDS)',
        'Light Level History': 'আলোর স্তরের ইতিহাস',
        'Water Usage History': 'জল ব্যবহারের ইতিহাস',
        'Total Usage': 'মোট ব্যবহার',
        'Daily Avg': 'দৈনিক গড়',
        'Peak Day': 'সর্বোচ্চ ব্যবহারের দিন',
        'Days Active': 'সক্রিয় দিন',
        '1 Day': '১ দিন',
        '1 Week': '১ সপ্তাহ',
        '1 Month': '১ মাস',
        '1 Year': '১ বছর',
        'All': 'সব',
        'Reset Feedback Data': 'ফিডব্যাক ডাটা রিসেট করুন',
        'Rate model predictions to see real-world accuracy. Higher bars = better performance.': 'বাস্তব নির্ভুলতা দেখতে মডেলের ফলাফলের রেটিং দিন। উঁচু বার = ভালো পারফরম্যান্স।',

        /* Analyse Tab */
        '🌱 Select Crop for Analysis': '🌱 বিশ্লেষণের জন্য ফসল নির্বাচন করুন',
        'Selected:': 'নির্বাচিত:',
        '🌿 All Plants': '🌿 সব গাছ',
        'Analyze Stream': 'স্ট্রিম বিশ্লেষণ করুন',
        'Start Stream': 'স্ট্রিম শুরু করুন',
        'Analyze Image': 'ছবি বিশ্লেষণ করুন',
        'Capture Photo': 'ছবি তুলুন',
        'Choose from Gallery': 'গ্যালারি থেকে নিন',
        'Select an image to analyze': 'বিশ্লেষণের জন্য একটি ছবি নির্বাচন করুন',

        /* Diagnostic */
        'Diagnostic History': 'ডায়াগনস্টিক ইতিহাস',
        'Sync': 'সিঙ্ক',
        'Resync': 'রিসঙ্ক',
        'Analysis Log': 'বিশ্লেষণ লগ',
        'Clear Diagnostic Log': 'লগ পরিষ্কার করুন',
        '📥 Load': '📥 লোড',

        /* Placeholders & Misc */
        'Min': 'মিনিট',
        '10.180.248.XXX': '১০.১৮০.২৪৮.XXX',
        'Enter ESP32 IP address above': 'উপরে ESP32 আইপি এড্রেস লিখুন',
        'Ready. Click "Start stream" to preview.': 'প্রস্তুত। প্রিভিউ দেখতে "Start stream" এ ক্লিক করুন।',
        'Analyze Stream': 'স্ট্রিম বিশ্লেষণ করুন',
        'Analyze Image': 'ছবি বিশ্লেষণ করুন',

        /* JavaScript Dynamic Strings */
        '⏳ Loading...': '⏳ লোড হচ্ছে...',
        '⏳ Resyncing...': '⏳ রিসঙ্ক হচ্ছে...',
        'No Connection': 'সংযোগ নেই',
        'Flowing': 'প্রবাহিত',
        'No Flow': 'প্রবাহ নেই',
        'ALERT': 'সতর্ক',
        'Starting in ': 'শুরু হচ্ছে ',
        'synced': 'সমন্বিত',
        'unsynced': 'সমন্বিত নেই',
        'Schedule: OFF': 'শিডিউল: বন্ধ',
        'Quick: active': 'কুইক: সক্রিয়',
        '(on_delay ': '(দেরি হচ্ছে ',
        'ON': 'চালু',
        'OFF': 'বন্ধ',
        'Activate Pump': 'পাম্প চালু করুন',
        'Deactivate Pump': 'পাম্প বন্ধ করুন',
        'MANUAL': 'ম্যানুয়াল',
        'AUTO': 'স্বয়ংক্রিয়',
        ' (INTRUDER!)': ' (অনুপ্রবেশকারী!)',
        ' cm': ' সেমি'
      };

      // Helper to get current language
      function getLang() {
        try { return localStorage.getItem('lang') || 'en'; } catch (e) { return 'en'; }
      }

      // Translate a single string if available
      function translateText(text) {
        if (!text || typeof text !== 'string') return text;
        const lang = getLang();
        if (lang === 'bn' && TRANSLATIONS_BN[text]) return TRANSLATIONS_BN[text];
        return text;
      }

      // Small key-based getter used by some places (e.g., Gemini blocks)
      function gl(key) {
        const KEYMAP = {
          diseaseExplanation: 'Disease Explanation',
          severity: 'Severity',
          preventiveMeasures: 'Preventive Measures',
          organicTreatment: 'Organic Treatment',
          chemicalTreatment: 'Chemical Treatment',
          riskOfCropLoss: 'Risk of Crop Loss'
        };
        const english = KEYMAP[key] || key;
        return translateText(english);
      }

      function applyTranslation(map) {
        // Text content
        document.querySelectorAll('.translatable').forEach(el => {
          const key = el.textContent.trim();
          if (map[key]) el.textContent = map[key];
        });
        // Placeholders for inputs
        document.querySelectorAll('input[placeholder]').forEach(el => {
          const key = el.getAttribute('placeholder');
          if (map[key]) el.setAttribute('placeholder', map[key]);
        });
      }

      function translateToBangla() {
        applyTranslation(TRANSLATIONS_BN);
        try { localStorage.setItem('lang', 'bn'); } catch (e) { /* ignore */ }
        const bnBtn = document.querySelector('#languageSelector button[onclick="translateToBangla()"]');
        const enBtn = document.querySelector('#languageSelector button[onclick="translateToEnglish()"]');
        if (bnBtn) bnBtn.classList.add('active');
        if (enBtn) enBtn.classList.remove('active');

        // Also re-render dynamic pieces if any are visible
        try { initPlantSelector(); displayActiveModels(); updateFirebaseStatus(firebaseReady); refreshRuntimeTranslations(); } catch (e) { /* ignore */ }
      }

      // Re-apply translations to runtime/hardware status texts where possible
      function refreshRuntimeTranslations() {
        try {
          // ESP / Stream status
          const conn = document.getElementById('connStatus');
          if (conn) {
            const t = conn.textContent || '';
            if (t.includes('ESP32 reachable') || t.includes('পৌছেছে')) {
              conn.textContent = '✅ ' + translateText('ESP32 reachable');
            } else if (t.includes('Cannot reach ESP32') || t.includes('পৌছানো')) {
              // Try to keep any IP in the message
              const ipMatch = t.match(/(\d+\.\d+\.\d+\.\d+)/);
              const ip = ipMatch ? ipMatch[0] : '';
              conn.textContent = (ip ? '❌ ' + translateText('Cannot reach ESP32 at') + ' ' + ip : translateText('Cannot reach ESP32 at'));
            } else if (t.includes('Connecting')) {
              conn.textContent = translateText('Connecting...');
            } else if (t.includes('Stream connected') || t.includes('স্ট্রিম')) {
              conn.textContent = '✅ ' + translateText('Stream connected');
            } else if (t.includes('Using capture polling')) {
              conn.textContent = '⚠️ ' + translateText('Using capture polling');
            }
          }

          const placeholder = document.getElementById('streamPlaceholder');
          if (placeholder) {
            const pt = placeholder.textContent || '';
            if (pt.includes('Ready. Click')) placeholder.textContent = translateText('Ready. Click "Start stream" to preview.');
            if (pt.includes('No Connection') || pt.includes('সংযোগ নেই')) placeholder.textContent = translateText('No Connection');
          }

          // Arduino / MQTT / Firebase statuses
          const arduinoStatus = document.getElementById('arduinoStatus');
          if (arduinoStatus) {
            const v = arduinoStatus.textContent || '';
            if (v.includes('Connected') || v.includes('সংযুক্ত')) arduinoStatus.textContent = translateText('Connected');
            if (v.includes('Not Connected') || v.includes('সংযুক্ত নয়')) arduinoStatus.textContent = translateText('Not Connected');
          }

        } catch (e) { /* ignore */ }
      }

      function translateToEnglish() {
        try { localStorage.setItem('lang', 'en'); } catch (e) { /* ignore */ }
        location.reload();
      }

      // Apply persisted language preference on load
      document.addEventListener('DOMContentLoaded', () => {
        try {
          const lang = localStorage.getItem('lang');
          if (lang === 'bn') {
            translateToBangla();
          } else if (lang === 'en') {
            const enBtn = document.querySelector('#languageSelector button[onclick="translateToEnglish()"]');
            const bnBtn = document.querySelector('#languageSelector button[onclick="translateToBangla()"]');
            if (enBtn) enBtn.classList.add('active');
            if (bnBtn) bnBtn.classList.remove('active');
          }
        } catch (e) { /* ignore storage errors */ }
      });
    </script>

    <script>
      // ==================== PRODUCTION CONFIGURATION ====================
      const PRODUCTION_MODE = false; // Set to true to disable debug logging
      // Toggle automatic migration of legacy ESP32 IP from 192.168.1.33 -> 10.180.248.33
      // Default: false to preserve user-set IP addresses (e.g., when your ESP provides 192.168.1.33)
      const ALLOW_AUTO_IP_MIGRATION = false;

      // Optimized logging wrapper
      const log = {
        info: (...args) => !PRODUCTION_MODE && console.log(...args),
        warn: (...args) => console.warn(...args),
        error: (...args) => console.error(...args),
        success: (msg) => !PRODUCTION_MODE && console.log('✅', msg),
        debug: (...args) => !PRODUCTION_MODE && console.log('🔍', ...args)
      };

      // ==================== FIREBASE CONFIGURATION ======================================
      // Firebase project: agriculture-project-diploma
      const firebaseConfig = {
        apiKey: "AIzaSyCluvsF7ChTv1nfm6HzGVbvNZ4MmIwYSqA",
        authDomain: "agriculture-project-diploma.firebaseapp.com",
        databaseURL: "https://agriculture-project-diploma-default-rtdb.firebaseio.com",
        projectId: "agriculture-project-diploma",
        storageBucket: "agriculture-project-diploma.firebasestorage.app",
        messagingSenderId: "821352370665",
        appId: "1:821352370665:web:8133f8dffdb5f84bcbbb78",
        measurementId: "G-C4YL29SEP4"
      };

      // Google Cloud services removed - using Firebase Firestore only for storage

      // Initialize Firebase
      let db = null;
      let auth = null;
      let functions = null;
      let firebaseEnabled = false;
      let aiEnabled = false;
      let aiAnalysisEnabled = false;
      let firebaseReady = false;
      let firebaseReadyPromise = null;
      let geminiRecommendation = null;

      try {
        firebase.initializeApp(firebaseConfig);
        db = firebase.firestore();
        auth = firebase.auth();
        functions = firebase.functions();

        // Note: Offline persistence is optional and causes deprecation warnings in Firebase 9.22.0+
        // System works fine without it - data is saved to Firebase and localStorage

        // Create promise that resolves when Firebase is ready
        firebaseReadyPromise = new Promise((resolve, reject) => {
          // Anonymous authentication for simplicity
          auth.signInAnonymously()
            .then(() => {
              console.log('✅ Firebase authenticated anonymously');
              console.log('User ID:', auth.currentUser.uid);
              firebaseEnabled = true;
              firebaseReady = true;
              aiEnabled = true; // Enable AI features
              updateFirebaseStatus(true);
              console.log('🤖 Firebase AI features enabled');

              // Load history only after auth
              loadSensorData();

              // Load persist settings
              loadAutoModeState();

              resolve();
            })
            .catch(err => {
              console.error('❌ Firebase auth error:', err);
              updateFirebaseStatus(false);
              reject(err);
            });
        });

        console.log('✅ Firebase initialized');
      } catch (error) {
        log.warn('⚠️ Firebase not configured or disabled:', error.message);
        log.info('ℹ️ System will work with local storage only');
        updateFirebaseStatus(false);
      }

      function updateFirebaseStatus(connected) {
        const statusEl = document.getElementById('firebaseStatus');
        const iconEl = document.getElementById('firebaseIcon');
        const textEl = document.getElementById('firebaseStatusText');
        const firebaseDot = document.getElementById('firebaseDot');

        if (connected) {
          if (statusEl) statusEl.className = 'firebase-status connected';
          if (iconEl) iconEl.textContent = 'cloud_done';
          if (textEl) textEl.textContent = '';
          if (firebaseDot) firebaseDot.classList.remove('offline');
        } else {
          if (statusEl) statusEl.className = 'firebase-status disconnected';
          if (iconEl) iconEl.textContent = 'cloud_off';
          if (textEl) textEl.textContent = translateText('Local storage only');
          if (firebaseDot) firebaseDot.classList.add('offline');
        }
      }

      // ==================== ROBOFLOW CONFIGURATION ====================
      const K = 'uRVv39iPfwzK4NJJ0Gsw';

      // Google Cloud services removed - using Firebase Firestore only

      // Storage simplified - images stored as base64 in Firestore documents

      // Class name mapping for models that return numeric IDs
      const CLASS_NAME_MAPPING = {
        'tomato-disease-k8es2/2': {
          '0': 'Tomato Early Blight',
          '1': 'Tomato Late Blight',
          '2': 'Tomato Bacterial Spot',
          '3': 'Tomato Septoria Leaf Spot',
          '4': 'Tomato Target Spot',
          '5': 'Tomato Leaf Mold',
          '6': 'Tomato Yellow Leaf Curl Virus',
          '7': 'Tomato Mosaic Virus',
          '8': 'Tomato Spider Mites',
          '9': 'Tomato Healthy'
        },
        'potato-disease-balnv/2': {
          '0': 'Potato Early Blight',
          '1': 'Potato Late Blight',
          '2': 'Potato Healthy'
        }
      };

      // Multiple models for comparison
      const MODELS = [
        { id: 'plant-disease-detection-z9xot/2', name: 'Object Detection (YOLOv8)', type: 'detection', forPlants: 'all' },
        { id: 'rice-disease-detection-zwaa8/4', name: 'Rice Disease Detection (YOLOv8s)', type: 'detection', forPlants: ['rice'] },
        { id: 'wheat-disease-detection-zsn0p/1', name: 'Wheat Disease (100% Accuracy)', type: 'classification', forPlants: ['wheat'] },
        { id: 'chili-plant/2', name: 'Chili Plant Disease (81% mAP)', type: 'detection', forPlants: ['chili', 'pepper'] },
        { id: 'potato-disease-balnv/2', name: 'Potato Disease (98.8% mAP)', type: 'detection', forPlants: ['potato'] },
        { id: 'tomato-disease-k8es2/2', name: 'Tomato Disease (92.3% mAP)', type: 'detection', forPlants: ['tomato'] },
        { id: 'eggplant-fruit-disease-detection/21', name: 'Eggplant Disease (47.8% mAP)', type: 'detection', forPlants: ['eggplant', 'brinjal'] }
      ];

      // Plant types available for selection
      const PLANT_TYPES = [
        { id: 'all', name: 'All Plants (General)', icon: '🌿', models: 7, description: 'Use all 7 models for comprehensive analysis' },
        { id: 'rice', name: 'Rice', icon: '🌾', models: 2, description: 'General model + Rice specialist' },
        { id: 'wheat', name: 'Wheat', icon: '🌾', models: 2, description: 'General model + Wheat specialist' },
        { id: 'chili', name: 'Chili/Pepper', icon: '🌶️', models: 2, description: 'General model + Chili specialist' },
        { id: 'potato', name: 'Potato', icon: '🥔', models: 2, description: 'General model + Potato specialist' },
        { id: 'tomato', name: 'Tomato', icon: '🍅', models: 2, description: 'General model + Tomato specialist' },
        { id: 'eggplant', name: 'Eggplant/Brinjal', icon: '🍆', models: 2, description: 'General model + Eggplant specialist' }
      ];

      let selectedPlantType = 'all'; // Default to all plants

      // Disease remedies database
      const REMEDIES = {
        // Enhanced with specific medicine names, brands, and dosages
        'bacterial spot': '🔹 Organic: Copper hydroxide (Kocide 3000) 2-3g/L, Streptomycin sulfate 200ppm. 🔹 Chemical: Copper oxychloride 50% WP 3g/L water, Kasugamycin 3% SL 2ml/L. Spray every 5-7 days.',
        'early blight': '🔹 Organic: Neem oil spray 5ml/L, Bacillus subtilis. 🔹 Chemical: Chlorothalonil 500g/L (Bravo) 2g/L, Mancozeb 75% WP (Dithane M-45) 2g/L, Azoxystrobin (Quadris) 1ml/L. Spray every 7-10 days.',
        'late blight': '🔹 Organic: Copper sulfate, Bordeaux mixture 1%. 🔹 Chemical: Metalaxyl + Mancozeb (Ridomil Gold MZ) 2.5g/L, Cymoxanil + Mancozeb (Curzate M) 2g/L, Dimethomorph (Forum) 1ml/L. Apply immediately.',
        'leaf mold': '🔹 Organic: Baking soda 5g/L, potassium bicarbonate. 🔹 Chemical: Chlorothalonil (Bravo 500SC) 1-2ml/L, Difenoconazole (Score 25EC) 0.5ml/L. Spray weekly.',
        'septoria leaf spot': '🔹 Organic: Copper fungicide, garlic extract. 🔹 Chemical: Chlorothalonil 2g/L, Mancozeb 75% WP 2g/L, Azoxystrobin + Difenoconazole (Amistar Top) 1ml/L. Apply at first sign.',
        'spider mites': '🔹 Organic: Neem oil (Azadirachtin 1%) 5ml/L, insecticidal soap. 🔹 Chemical: Abamectin (Vertimec 1.8% EC) 0.5-1ml/L, Spiromesifen (Oberon 240SC) 0.5ml/L. Repeat every 5 days.',
        'target spot': '🔹 Organic: Neem oil, Trichoderma viride. 🔹 Chemical: Chlorothalonil 500g/L 2g/L, Mancozeb + Carbendazim (Saaf) 2g/L, Azoxystrobin 1ml/L. Spray every 10 days.',
        'mosaic virus': '🔹 No cure available. 🔹 Control vectors: Imidacloprid 17.8% SL (Confidor) 0.5ml/L, Acetamiprid (Mospilan 20SP) 0.3g/L for aphids. Remove infected plants immediately.',
        'yellow leaf curl': '🔹 Control whiteflies: Imidacloprid (Confidor 200SL) 0.5ml/L, Thiamethoxam (Actara 25WG) 0.3g/L, Buprofezin (Applaud 25WP) 1g/L. Spray every 5-7 days.',
        'powdery mildew': '🔹 Organic: Sulfur 80% WP (Sulphex) 2g/L, potassium bicarbonate, milk spray 1:9. 🔹 Chemical: Hexaconazole (Contaf 5EC) 1ml/L, Tebuconazole (Folicur 250EC) 0.5ml/L. Spray weekly.',
        'leaf curl': '🔹 Organic: Neem oil 5ml/L. 🔹 Chemical: Carbendazim 50% WP (Bavistin) 1g/L, Mancozeb 2g/L. 🔹 Nutrient spray: NPK 19:19:19 foliar 5g/L.',
        'rust': '🔹 Organic: Sulfur 80% WP 2g/L, copper oxychloride. 🔹 Chemical: Propiconazole (Tilt 25EC) 1ml/L, Triadimefon (Bayleton 25WP) 0.5g/L, Mancozeb 2g/L. Spray every 7-10 days.',
        'anthracnose': '🔹 Organic: Copper fungicide, Trichoderma viride. 🔹 Chemical: Carbendazim 50% WP 1g/L, Thiophanate-methyl (Topsin-M 70WP) 1g/L, Azoxystrobin + Difenoconazole 1ml/L.',
        'blight': '🔹 Organic: Bordeaux mixture 1%, copper sulfate. 🔹 Chemical: Metalaxyl + Mancozeb (Ridomil Gold MZ) 2.5g/L, Fosetyl-Al (Aliette 80WP) 3g/L. Spray every 10 days.',
        'scab': '🔹 Organic: Sulfur 80% WP 2g/L. 🔹 Chemical: Captan 50% WP 2g/L, Dodine (Syllit 400SC) 1.5ml/L, Myclobutanil (Rally 40WP) 0.5ml/L. Start at bud break.',
        'wilt': '🔹 Soil drench: Carbendazim 50% WP 2g/L, Metalaxyl 35% WS 1g/L. 🔹 Biocontrol: Trichoderma harzianum 5g/L, Pseudomonas fluorescens. Apply via drip irrigation.',
        'downy mildew': '🔹 Organic: Copper fungicide, Bacillus subtilis. 🔹 Chemical: Metalaxyl (Ridomil 35SD) 2g/L, Cymoxanil + Mancozeb 2.5g/L, Fosetyl-Al 3g/L. Apply weekly.',
        'alternaria': '🔹 Organic: Neem extract, Trichoderma. 🔹 Chemical: Mancozeb 75% WP 2g/L, Iprodione (Rovral 50WP) 2ml/L, Difenoconazole 1ml/L. Rotate fungicides.',
        'fusarium': '🔹 Soil treatment: Carbendazim 2g/L drench, Metalaxyl 1g/L. 🔹 Seed treatment: Thiram 75% WS 3g/kg seed. 🔹 Biocontrol: Trichoderma viride 5g/L.',

        // Additional vegetable crop diseases
        'damping off': '🔹 Seed treatment: Thiram 75% WS 2g/kg seed, Captan 50% WP 2g/kg. 🔹 Soil drench: Metalaxyl 1g/L, Copper oxychloride 2g/L. Pre-planting treatment recommended.',
        'fruit rot': '🔹 Organic: Copper fungicide, Trichoderma. 🔹 Chemical: Carbendazim 1g/L, Thiophanate-methyl 1g/L. Spray at fruit set and repeat every 10 days.',
        'gray mold': '🔹 Organic: Potassium bicarbonate 5g/L. 🔹 Chemical: Iprodione (Rovral) 2g/L, Pyrimethanil (Scala 400SC) 1ml/L. Spray at flowering and fruit set.',
        'stem rot': '🔹 Soil drench: Carbendazim 2g/L, Metalaxyl 1g/L. 🔹 Foliar: Copper oxychloride 3g/L. Remove infected stems and burn. Apply fungicide to wounds.',
        'root rot': '🔹 Soil treatment: Metalaxyl + Mancozeb 2.5g/L drench, Fosetyl-Al 3g/L. 🔹 Biocontrol: Trichoderma harzianum + Pseudomonas 10g/L soil application.',
        'collar rot': '🔹 Soil drench: Carbendazim 2g/L + Copper oxychloride 2g/L. 🔹 Stem paint: Bordeaux paste at collar region. Apply preventively before monsoon.',
        'black spot': '🔹 Organic: Neem oil 5ml/L, Copper fungicide. 🔹 Chemical: Mancozeb 2g/L, Difenoconazole 0.5ml/L, Chlorothalonil 2g/L. Spray every 7-10 days.',
        'brown spot': '🔹 Organic: Copper sulfate, Neem extract. 🔹 Chemical: Mancozeb 75% WP 2g/L, Carbendazim 1g/L, Tricyclazole (Beam 75WP) 0.6g/L. For rice, spray at tillering.',
        'bacterial wilt': '🔹 Soil drench: Streptomycin 500ppm, Copper oxychloride 3g/L. 🔹 Prevention: Bleaching powder 50g/sq.m. Remove and burn infected plants immediately.',
        'cercospora leaf spot': '🔹 Organic: Copper fungicide. 🔹 Chemical: Mancozeb 2g/L, Carbendazim 1g/L, Tebuconazole 0.5ml/L. Spray at 15-day intervals starting 45 days after planting.',
        'sooty mold': '🔹 Control sap-sucking insects: Imidacloprid 0.5ml/L, Dimethoate 40% EC 2ml/L. 🔹 Wash leaves with soap solution. Improve air circulation.',
        'leaf blight': '🔹 Organic: Bordeaux mixture 1%, Neem oil. 🔹 Chemical: Mancozeb 2g/L, Chlorothalonil 2g/L, Propiconazole 1ml/L. Spray at first appearance of symptoms.',
        'southern blight': '🔹 Soil treatment: Carbendazim 2g/L drench, Pentachloronitrobenzene (PCNB 75% WP) 3g/L. Deep plowing and solarization recommended.',
        'verticillium wilt': '🔹 Soil fumigation: Metam sodium. 🔹 Resistant varieties recommended. 🔹 Soil amendment: Trichoderma + organic matter. No effective chemical cure.',
        'club root': '🔹 Soil pH adjustment: Apply lime 200g/sq.m. 🔹 Seed treatment: Thiram 2g/kg. 🔹 Soil drench: Carbendazim 2g/L. Crop rotation for 4-5 years.',
        'black rot': '🔹 Organic: Copper hydroxide 3g/L. 🔹 Chemical: Streptomycin 200ppm, Copper oxychloride 3g/L. Seed treatment with hot water (50°C, 30 min).',
        'white rust': '🔹 Organic: Sulfur 80% WP 2g/L. 🔹 Chemical: Metalaxyl 2g/L, Mancozeb 2g/L, Ridomil Gold 2.5g/L. Spray at early vegetative stage.',
        'purple blotch': '🔹 Organic: Neem oil, Copper fungicide. 🔹 Chemical: Mancozeb 2g/L, Chlorothalonil 2g/L, Hexaconazole 1ml/L. For onion/garlic, spray every 7 days.',
        'soft rot': '🔹 Prevention: Streptocycline 0.1g/L spray. 🔹 Post-harvest: Dip in Copper oxychloride 2g/L. Ensure proper drainage and avoid injuries.',
        'cucumber mosaic': '🔹 Control aphids: Imidacloprid 0.5ml/L, Acetamiprid 0.3g/L. 🔹 Remove infected plants. Use reflective mulch. Plant virus-resistant varieties.',
        'gummy stem blight': '🔹 Seed treatment: Thiram 2g/kg. 🔹 Foliar: Carbendazim 1g/L, Thiophanate-methyl 1g/L, Azoxystrobin 1ml/L. Rotate with non-cucurbit crops.',
        'angular leaf spot': '🔹 Organic: Copper fungicide. 🔹 Chemical: Copper oxychloride 3g/L, Streptomycin 200ppm. Spray weekly. Use disease-free seeds.',
        'bacterial canker': '🔹 Seed treatment: Hot water (56°C, 30 min). 🔹 Spray: Streptomycin 200ppm, Copper oxychloride 3g/L. Remove infected plants.',
        'aphids': '🔹 Organic: Neem oil 5ml/L, insecticidal soap. 🔹 Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Dimethoate 2ml/L. Spray early morning.',
        'whitefly': '🔹 Organic: Neem oil, yellow sticky traps. 🔹 Chemical: Imidacloprid 0.5ml/L, Buprofezin 1g/L, Spiromesifen 0.5ml/L. Spray undersides of leaves.',
        'thrips': '🔹 Organic: Neem oil 5ml/L, Spinosad (Tracer 45SC) 0.3ml/L. 🔹 Chemical: Fipronil (Regent 5SC) 2ml/L, Dimethoate 2ml/L. Spray at evening.',
        'fruit borer': '🔹 Organic: Neem oil, Bacillus thuringiensis (Bt) 1g/L. 🔹 Chemical: Chlorantraniliprole (Coragen 20SC) 0.3ml/L, Flubendiamide (Fame 480SC) 0.5ml/L.',
        'leaf miner': '🔹 Organic: Neem oil, yellow sticky traps. 🔹 Chemical: Abamectin 0.5ml/L, Cyromazine (Trigard 75WP) 0.4g/L. Remove and destroy affected leaves.',
        'stem borer': '🔹 Organic: Neem cake soil application 100g/plant. 🔹 Chemical: Chlorpyrifos 20% EC 2ml/L, Cartap hydrochloride (Padan 50SP) 1g/L. Spray at whorl stage.',
        'cutworm': '🔹 Organic: Neem cake, wood ash around stem. 🔹 Chemical: Chlorpyrifos 20% EC 2ml/L soil drench, Quinalphos 25% EC 2ml/L. Apply at evening.',
        'nematodes': '🔹 Organic: Neem cake 100g/sq.m, Paecilomyces lilacinus. 🔹 Chemical: Carbofuran 3% CG 15kg/hectare, Phorate 10% CG 10kg/hectare. Apply before planting.',

        // General crop maintenance
        'walnut': 'No disease detected. 🔹 Preventive: Bordeaux mixture 1%, Copper fungicide 3g/L. 🔹 Fertilizer: NPK 10:10:10 at 50g/plant monthly.',
        'tomato': 'No disease detected. 🔹 Preventive spray: Mancozeb 2g/L or Copper oxychloride 3g/L every 15 days. 🔹 Fertilizer: NPK 19:19:19 5g/L weekly.',
        'pepper': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L every 10 days. 🔹 Fertilizer: NPK 19:19:19 5g/L + Calcium nitrate 2g/L weekly.',
        'cucumber': 'No disease detected. 🔹 Preventive: Carbendazim 1g/L weekly. 🔹 Fertilizer: NPK 19:19:19 5g/L + Boron 0.5g/L biweekly.',
        'cabbage': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L + Chlorpyrifos 2ml/L every 10 days. 🔹 Fertilizer: NPK 19:19:19 5g/L.',
        'potato': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L every 10 days. 🔹 Fertilizer: NPK 19:19:19 5g/L + Zinc sulfate 2g/L.',
        'onion': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L + Carbendazim 1g/L every 15 days. 🔹 Fertilizer: NPK 19:19:19 5g/L.',
        'beans': 'No disease detected. 🔹 Preventive: Carbendazim 1g/L at flowering. 🔹 Fertilizer: NPK 19:19:19 3g/L + Rhizobium inoculation.',
        'eggplant': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L + Imidacloprid 0.5ml/L every 10 days. 🔹 Fertilizer: NPK 19:19:19 5g/L.',
        'banana': 'No disease detected. 🔹 Preventive: Mancozeb 2g/L monthly. 🔹 Pseudostem injection: Carbendazim 1g/L. 🔹 Fertilizer: NPK 19:19:19 10g/L.',
        'rot': '🔹 Soil drench: Metalaxyl 35% WS 1g/L, Fosetyl-Al 3g/L. 🔹 Foliar: Copper oxychloride 3g/L. 🔹 Biocontrol: Trichoderma viride soil application.',
        'canker': '🔹 Spray: Copper oxychloride 50% WP 3g/L, Bordeaux mixture 1%. 🔹 Wound paste: Carbendazim + Copper paste. Prune 15cm below infection.',

        // EGGPLANT/BRINJAL DISEASES
        'eggplant fruit rot': '🔹 Organic: Neem oil 5ml/L. 🔹 Chemical: Carbendazim 1g/L + Mancozeb 2g/L. Spray at fruit set and every 10 days.',
        'eggplant phomopsis blight': '🔹 Seed treatment: Thiram 2g/kg. 🔹 Spray: Mancozeb 2g/L + Carbendazim 1g/L. Rotate with Copper oxychloride 3g/L.',
        'eggplant little leaf': '🔹 Control leafhoppers: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L. Remove infected plants. Use virus-free seedlings.',
        'eggplant bacterial wilt': '🔹 Soil drench: Streptomycin 500ppm + Copper oxychloride 2g/L. Remove and burn infected plants immediately.',
        'eggplant damping off': '🔹 Seed treatment: Thiram 2g/kg. 🔹 Soil drench: Metalaxyl 1g/L + Copper oxychloride 2g/L before planting.',
        'eggplant cercospora leaf spot': '🔹 Mancozeb 75% WP 2g/L, Carbendazim 1g/L, Chlorothalonil 2g/L. Spray every 10-12 days.',
        'eggplant anthracnose': '🔹 Copper fungicide, Carbendazim 1g/L + Mancozeb 2g/L. Apply at first flower and fruit set.',
        'brinjal fruit borer': '🔹 Organic: Neem oil 5ml/L, Bt (Bacillus thuringiensis) 1g/L. 🔹 Chemical: Chlorantraniliprole 0.3ml/L, Spinosad 0.3ml/L. Spray at evening.',
        'brinjal shoot borer': '🔹 Remove and destroy infested shoots. 🔹 Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L every 10 days.',
        'brinjal aphids': '🔹 Organic: Neem oil 5ml/L, soap spray. 🔹 Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L. Spray undersides.',
        'brinjal whitefly': '🔹 Yellow sticky traps. 🔹 Imidacloprid 0.5ml/L, Buprofezin 1g/L, Spiromesifen 0.5ml/L. Spray every 7 days.',
        'brinjal jassids': '🔹 Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Acetamiprid 0.3g/L. Spray at tender leaf stage.',

        // WHEAT DISEASES
        'wheat rust': '🔹 Organic: Sulfur 80% WP 2g/L. 🔹 Chemical: Propiconazole (Tilt 25EC) 1ml/L, Tebuconazole (Folicur 250EC) 0.5ml/L, Mancozeb 2g/L. Spray at first sign.',
        'wheat brown rust': '🔹 Propiconazole 1ml/L, Tebuconazole 0.5ml/L, Triadimefon (Bayleton 25WP) 0.5g/L. Spray at tillering and boot stage.',
        'wheat yellow rust': '🔹 Propiconazole 1ml/L, Mancozeb 2g/L, Zineb 2g/L. Spray preventively before disease appearance. Repeat every 15 days.',
        'wheat black rust': '🔹 Mancozeb 75% WP 2g/L, Propiconazole 1ml/L. Spray at boot stage and milk stage. Use resistant varieties.',
        'wheat powdery mildew': '🔹 Organic: Sulfur 80% WP 2g/L. 🔹 Chemical: Hexaconazole (Contaf 5EC) 1ml/L, Tebuconazole 0.5ml/L, Propiconazole 1ml/L. Spray at early jointing.',
        'wheat leaf blight': '🔹 Mancozeb 2g/L, Carbendazim 1g/L, Chlorothalonil 2g/L. Spray at tillering, boot, and heading stages.',
        'wheat septoria leaf spot': '🔹 Chlorothalonil 2g/L, Mancozeb 2g/L, Propiconazole 1ml/L. Spray at flag leaf emergence and heading.',
        'fusarium head blight': '🔹 Tebuconazole 0.5ml/L, Propiconazole 1ml/L, Carbendazim 1g/L. Spray at early flowering. Repeat after 7 days.',
        'wheat tan spot': '🔹 Propiconazole 1ml/L, Tebuconazole 0.5ml/L, Azoxystrobin 1ml/L. Spray at tillering and flag leaf stage.',
        'wheat loose smut': '🔹 Seed treatment: Vitavax (Carboxin 75% WP) 2g/kg seed, Tebuconazole 2ml/kg seed. Hot water treatment 49°C for 3 hours.',
        'wheat karnal bunt': '🔹 Seed treatment: Tebuconazole 2ml/kg seed. 🔹 Foliar: Propiconazole 1ml/L at boot stage and 50% flowering. Burn infected grains.',
        'wheat flag smut': '🔹 Seed treatment: Carboxin 2g/kg, Tebuconazole 2ml/kg. Remove and burn infected plants before heading.',
        'wheat stem rust': '🔹 Propiconazole 1ml/L + Mancozeb 2g/L. Spray at boot and heading stage. Use resistant varieties like HD2967, WH1105.',
        'wheat leaf rust': '🔹 Mancozeb 2g/L, Propiconazole 1ml/L. Spray at tillering and flag leaf stage. Spray every 15 days if disease persists.',
        'wheat root rot': '🔹 Seed treatment: Carbendazim 2g/kg, Metalaxyl 2ml/kg. 🔹 Soil drench: Carbendazim 2g/L at sowing.',
        'wheat blast': '🔹 Tricyclazole (Beam 75WP) 0.6g/L, Tebuconazole 0.5ml/L. Spray at heading and repeat after 7 days. Emergency disease.',
        'wheat aphids': '🔹 Organic: Neem oil 5ml/L. 🔹 Chemical: Imidacloprid 0.5ml/L, Thiamethoxam 0.3g/L, Dimethoate 40% EC 2ml/L. Spray at tillering.',
        'wheat stem borer': '🔹 Chlorpyrifos 20% EC 2ml/L, Quinalphos 25% EC 2ml/L. Spray at early vegetative stage. Remove and destroy stubbles.',
        'wheat termites': '🔹 Chlorpyrifos 20% EC 4ml/L soil application before sowing. Treat seed with Imidacloprid 2ml/kg seed.',
        'wheat army worm': '🔹 Chlorpyrifos 2ml/L, Quinalphos 2ml/L, Malathion 50% EC 2ml/L. Spray in evening. Mechanical collection in early morning.',

        // FRUIT CROPS (100+ diseases)
        'citrus canker': '🔹 Copper oxychloride 3g/L + Streptocycline 0.1g/L. Spray every 15 days. Prune infected branches 30cm below.',
        'citrus greening': '🔹 Control psyllids: Imidacloprid 0.5ml/L. 🔹 Zinc + Manganese spray 5g/L foliar. No cure - remove infected trees.',
        'fire blight': '🔹 Streptomycin 200ppm at 5% bloom. Copper 3g/L. Prune 30cm below infection. Disinfect tools with 70% alcohol.',
        'apple scab': '🔹 Myclobutanil 0.5ml/L, Captan 2g/L. Start at green tip. Spray every 7-10 days until petal fall.',
        'mango anthracnose': '🔹 Carbendazim 1g/L, Azoxystrobin 1ml/L at flowering. Post-harvest: Hot water 52°C, 5min.',
        'mango malformation': '🔹 NAA 200ppm at panicle emergence. Prune affected panicles. Carbendazim 1g/L before flowering.',
        'grape downy mildew': '🔹 Metalaxyl 2g/L, Cymoxanil + Mancozeb 2.5g/L. Spray every 10 days from flowering.',
        'banana bunchy top': '🔹 Control aphids: Imidacloprid 0.5ml/L. Remove and destroy infected plants. Use virus-free suckers.',
        'papaya ring spot': '🔹 Control aphids: Imidacloprid 0.5ml/L. Remove infected plants. Reflective mulch. No cure available.',
        'pomegranate bacterial blight': '🔹 Copper oxychloride 3g/L + Streptocycline 0.1g/L every 10 days during monsoon.',

        // CEREAL CROPS (80+ diseases)
        'rice blast': '🔹 Tricyclazole (Beam 75WP) 0.6g/L, Isoprothiolane 1.5ml/L. Spray at tillering and panicle initiation.',
        'rice sheath blight': '🔹 Hexaconazole 2ml/L, Validamycin 2ml/L at maximum tillering. Spray lower portion of plant.',
        'rice bacterial blight': '🔹 Copper oxychloride 3g/L + Streptocycline 0.1g/L. Seed treatment with Streptocycline.',
        'rice bacterial leaf blight': '🔹 Copper oxychloride 3g/L + Streptocycline 0.1g/L. Seed treatment with Streptocycline.',
        'rice tungro': '🔹 Control leafhoppers: Imidacloprid 0.5ml/L, Fipronil 2ml/L. Remove infected plants. Resistant varieties.',
        'rice stem borer': '🔹 Chlorantraniliprole 0.3ml/L, Cartap hydrochloride 1g/L at dead heart stage.',
        'rice hispa': '🔹 Chlorpyrifos 2ml/L, Cartap hydrochloride 1g/L. Spray on leaf surface. Drain water before spraying.',
        'rice sheath rot': '🔹 Carbendazim 1g/L, Propiconazole 1ml/L at boot stage. Balanced NPK application.',
        'rice leaf folder': '🔹 Chlorantraniliprole 0.3ml/L, Fipronil 2ml/L. Spray at early infestation stage.',
        'rice false smut': '🔹 Copper oxychloride 3g/L or Propiconazole 1ml/L at boot stage and heading.',
        'rice neck blast': '🔹 Tricyclazole 0.6g/L, Azoxystrobin 1ml/L at panicle initiation and heading.',
        'rice sheath blotch': '🔹 Mancozeb 2g/L, Propiconazole 1ml/L. Spray at tillering and boot stage.',
        'bacterial leaf streak': '🔹 Copper oxychloride 3g/L. Avoid excess nitrogen. Use resistant varieties.',
        'wheat rust': '🔹 Propiconazole 1ml/L, Tebuconazole 0.5ml/L at first rust appearance. Repeat after 15 days.',
        'wheat powdery mildew': '🔹 Hexaconazole 1ml/L, Sulfur 2g/L at tillering and boot stage.',
        'maize downy mildew': '🔹 Seed treatment: Metalaxyl 6g/kg. 🔹 Foliar: Metalaxyl 2g/L at 15, 25 days.',
        'maize fall armyworm': '🔹 Chlorantraniliprole 0.3ml/L, Emamectin benzoate 0.4g/L at whorl stage.',

        // PULSE CROPS (60+ diseases)
        'chickpea wilt': '🔹 Seed: Carbendazim 2g/kg + Trichoderma 4g/kg. Soil drench: Carbendazim 2g/L. Resistant varieties.',
        'pigeon pea wilt': '🔹 Seed: Carbendazim 2g/kg + Trichoderma. Soil drench 2g/L at 30 days. Deep summer plowing.',
        'soybean rust': '🔹 Tebuconazole 0.5ml/L, Trifloxystrobin + Tebuconazole 0.5ml/L. Repeat after 15 days.',
        'groundnut tikka': '🔹 Mancozeb 2g/L, Chlorothalonil 2g/L at 30, 45, 60 days after sowing.',

        // VEGETABLES EXPANDED (120+ diseases)
        'tomato leaf curl': '🔹 Control whiteflies: Imidacloprid 0.5ml/L, Buprofezin 1g/L. Reflective mulch. Remove infected plants.',
        'tomato blossom end rot': '🔹 Calcium nitrate 5g/L foliar at fruit set. Regular irrigation. Avoid excess nitrogen.',
        'potato late blight': '🔹 Metalaxyl + Mancozeb 2.5g/L every 7-10 days. Destroy infected plants immediately.',
        'brinjal fruit borer': '🔹 Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L. Bt 1g/L organic.',
        'chili anthracnose': '🔹 Seed: Carbendazim 2g/kg. Foliar: Carbendazim 1g/L, Azoxystrobin 1ml/L at flowering.',
        'chili leaf curl': '🔹 Control whiteflies: Imidacloprid 0.5ml/L, Buprofezin 1g/L. Reflective mulch. Remove infected plants immediately.',
        'chili bacterial wilt': '🔹 Soil drench: Streptomycin 500ppm, Copper oxychloride 3g/L. Remove and burn infected plants. Crop rotation 3-4 years.',
        'chili powdery mildew': '🔹 Sulfur 80% WP 2g/L, Hexaconazole 1ml/L. Spray at first sign. Repeat every 7-10 days.',
        'chili mosaic virus': '🔹 Control aphids: Imidacloprid 0.5ml/L. Remove infected plants. Use virus-free seeds. Reflective mulch.',
        'chili thrips': '🔹 Fipronil 2ml/L, Dimethoate 2ml/L. Spray undersides of leaves. Blue sticky traps.',
        'chili fruit borer': '🔹 Chlorantraniliprole 0.3ml/L, Flubendiamide 0.5ml/L. Bt spray 1g/L organic option.',
        'potato early blight': '🔹 Mancozeb 2g/L, Chlorothalonil 2g/L. Start at first symptoms. Spray every 7-10 days.',
        'potato black scurf': '🔹 Seed treatment: Thiram 2.5g/kg. Foliar: Copper oxychloride 3g/L. Improve drainage.',
        'potato common scab': '🔹 Soil pH 5.0-5.2. Sulfur 50g/sq.m before planting. Maintain uniform moisture. Avoid excess lime.',
        'okra yellow vein mosaic': '🔹 Control whiteflies: Imidacloprid 0.5ml/L. Remove infected plants. Resistant varieties.',
        'cabbage diamondback moth': '🔹 Bt 1g/L, Chlorantraniliprole 0.3ml/L, Emamectin benzoate 0.4g/L.',
        'onion purple blotch': '🔹 Mancozeb 2g/L, Hexaconazole 1ml/L every 10 days. Crop rotation.',

        // NUTRIENT DEFICIENCIES (40+ conditions)
        'nitrogen deficiency': '🔹 Urea 10g/L foliar or Ammonium sulfate 15g/L. Soil: Urea 100-150kg/hectare. Yellowing of older leaves.',
        'phosphorus deficiency': '🔹 DAP 10g/L foliar, SSP 200kg/hectare soil. Purple/dark green leaves, stunted growth.',
        'potassium deficiency': '🔹 MOP/SOP 10g/L foliar. Soil: 100kg/hectare. Leaf margin burn, scorching.',
        'calcium deficiency': '🔹 Calcium nitrate/chloride 5g/L foliar. Gypsum 500kg/hectare. Blossom end rot, tip burn.',
        'magnesium deficiency': '🔹 Magnesium sulfate (Epsom salt) 5g/L foliar. Dolomite 300kg/hectare. Interveinal chlorosis.',
        'iron deficiency': '🔹 Ferrous sulfate 3g/L + Citric acid 1g/L or Fe-EDTA 2g/L foliar. Young leaf chlorosis.',
        'zinc deficiency': '🔹 Zinc sulfate 5g/L + Lime 2.5g/L foliar. Soil: 25kg/hectare. Little leaf, rosetting.',
        'boron deficiency': '🔹 Borax 1g/L foliar. Soil: 10-15kg/hectare. Hollow stem, flower abortion.',

        // ENVIRONMENTAL STRESS (30+ conditions)
        'heat stress': '🔹 Kaolin clay 30g/L for sun protection. Cool water spray. Shade net. Mulching.',
        'cold stress': '🔹 Brassinosteroids 0.1ppm. Cover with plastic. Light irrigation before frost. Potassium 5g/L.',
        'drought stress': '🔹 Salicylic acid 100ppm foliar. Mulching. Anti-transpirant Kaolin 30g/L. Drip irrigation.',
        'salinity stress': '🔹 Gypsum 500kg/hectare. Calcium chloride 5g/L foliar. Leaching. Salicylic acid 100ppm.',

        'healthy': '✅ No treatment needed. 🔹 Preventive: NPK 19:19:19 at 5g/L every 15 days. 🔹 Micronutrients: ZnSO4 + FeSO4 + MnSO4 mix 3g/L monthly. 🔹 Bio-stimulant: Seaweed extract 2ml/L monthly.',
        'no detection': 'Unable to detect disease. Ensure proper image quality. If disease visible, consult agricultural expert with leaf sample for proper diagnosis.',
        'default': '⚠️ Consult local agricultural extension. 🔹 General spray: Mancozeb 75% WP 2g/L + Copper oxychloride 50% WP 3g/L. 🔹 Insect control: Imidacloprid 0.5ml/L. Take leaf sample for lab analysis.'
      };

      // ==================== CONTEXT-AWARE ANALYSIS ALGORITHMS ====================

      // Sensors/context removed - return neutral context
      function analyzeEnvironmentalContext(sensorData) {
        return {
          riskFactors: [],
          severity: 'low',
          severityScore: 0,
          recommendations: [],
          metrics: {
            moistureRisk: 'normal',
            humidityRisk: 'normal',
            temperatureRisk: 'normal',
            nutrientRisk: 'normal',
            lightRisk: 'normal'
          }
        };
      }

      // Simplified severity assessment (visual-only)
      function assessDiseaseSeverity(diseaseName, confidence, envContext) {
        let severity = 'mild';
        let treatmentUrgency = 'routine';
        let spreadRisk = 'low';

        if (confidence >= 90) { severity = 'severe'; treatmentUrgency = 'immediate'; spreadRisk = 'high'; }
        else if (confidence >= 70) { severity = 'moderate'; treatmentUrgency = 'within 24-48 hours'; spreadRisk = 'medium'; }
        else if (confidence >= 50) { severity = 'mild'; treatmentUrgency = 'within 1 week'; spreadRisk = 'low'; }

        return { severity, treatmentUrgency, spreadRisk, criticalityScore: confidence };
      }

      // ==================== ANALYTICS & LOGGING SYSTEM ====================

      let analyticsData = {
        logs: [],
        charts: {
          disease: null,
          confidence: null,
          environment: null,
          severity: null,

          modelPrecision: null
        },
        modelFeedback: {} // Stores feedback for each model: { modelName: { correct: 0, wrong: 0 } }
      };

      // Initialize model feedback tracking
      function initializeModelFeedback() {
        MODELS.forEach(model => {
          if (!analyticsData.modelFeedback[model.name]) {
            analyticsData.modelFeedback[model.name] = { correct: 0, wrong: 0, total: 0 };
          }
        });
      }

      // Record feedback for a specific model and analysis
      function recordModelFeedback(analysisId, modelName, isCorrect) {
        if (!analyticsData.modelFeedback[modelName]) {
          analyticsData.modelFeedback[modelName] = { correct: 0, wrong: 0, total: 0 };
        }

        if (isCorrect) {
          analyticsData.modelFeedback[modelName].correct++;
        } else {
          analyticsData.modelFeedback[modelName].wrong++;
        }
        analyticsData.modelFeedback[modelName].total++;

        // Update the specific log entry with feedback
        const logEntry = analyticsData.logs.find(log => log.id === analysisId);
        if (logEntry) {
          if (!logEntry.modelFeedbacks) {
            logEntry.modelFeedbacks = {};
          }
          logEntry.modelFeedbacks[modelName] = isCorrect;
        }

        saveAnalytics();

        // Update chart immediately after recording feedback
        console.log('🔄 Updating chart with new feedback data:', analyticsData.modelFeedback);
        console.log('📊 Total models with feedback:', Object.keys(analyticsData.modelFeedback).length);
        updateModelPrecisionChart();

        console.log('Feedback recorded for', modelName, ':', isCorrect ? 'Correct' : 'Wrong');
        console.log('Updated stats:', analyticsData.modelFeedback[modelName]);
      }

      // Reset all model feedback data
      function resetModelFeedback() {
        if (!confirm('⚠️ Are you sure you want to reset all model feedback data?\n\nThis will:\n• Clear all precision statistics\n• Remove the chart data\n• Delete feedback from Firebase\n\nThis action cannot be undone.')) {
          return;
        }

        console.log('🗑️ Resetting all model feedback data...');

        // Clear local data
        analyticsData.modelFeedback = {};

        // Clear from Firebase
        if (firebaseReady && firebaseEnabled && db) {
          db.collection('modelFeedback').doc('current').delete().then(() => {
            console.log('✅ Model feedback deleted from Firebase');
            alert('✅ All model feedback has been reset successfully!');
          }).catch(err => {
            console.error('❌ Failed to delete feedback from Firebase:', err);
            alert('⚠️ Feedback cleared locally but Firebase deletion failed: ' + err.message);
          });
        }

        // Clear from localStorage
        const stored = localStorage.getItem('diseaseAnalytics');
        if (stored) {
          try {
            const data = JSON.parse(stored);
            data.modelFeedback = {};
            localStorage.setItem('diseaseAnalytics', JSON.stringify(data));
            console.log('✅ Model feedback cleared from localStorage');
          } catch (e) {
            console.error('Failed to clear feedback from localStorage:', e);
          }
        }

        // Update chart to show empty state
        updateModelPrecisionChart();

        console.log('✅ Model feedback reset complete');
      }

      // Enhanced log entry with complete data
      function createCompleteLogEntry(results, sensorData, envContext) {
        const timestamp = new Date().toISOString();
        const diseases = [];
        const allModelResults = [];

        results.forEach(r => {
          // Store complete model result
          const modelResult = {
            modelName: r.name,
            modelType: r.type,
            error: r.error || null,
            rawData: r.data
          };

          if (r.error) {
            allModelResults.push(modelResult);
            return;
          }

          let disease = 'Healthy';
          let confidence = 0;

          if (r.type === 'detection' && r.data.predictions && r.data.predictions.length > 0) {
            const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
            disease = top.class;
            confidence = top.confidence * 100;
            modelResult.detectedClass = disease;
            modelResult.confidence = confidence;
            modelResult.allPredictions = r.data.predictions;
          } else if (r.type === 'classification' && (r.data.top || r.data.predicted_classes)) {
            disease = r.data.top || r.data.predicted_classes[0];
            confidence = (r.data.confidence || 0) * 100;
            modelResult.detectedClass = disease;
            modelResult.confidence = confidence;
          }

          allModelResults.push(modelResult);

          if (disease !== 'Healthy' && confidence > 0) {
            const severityAssessment = assessDiseaseSeverity(disease, confidence, envContext);
            diseases.push({
              name: disease,
              confidence: confidence,
              model: r.name,
              severity: severityAssessment.severity,
              spreadRisk: severityAssessment.spreadRisk,
              urgency: severityAssessment.treatmentUrgency,
              treatment: getRemedy(disease),
              criticalityScore: severityAssessment.criticalityScore
            });
          }
        });

        return {
          id: 'log_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
          timestamp,
          timestampReadable: new Date(timestamp).toLocaleString(),
          diseases,
          allModelResults,
          sensorData: sensorData || null,
          environmentalContext: envContext || null,
          primaryDisease: diseases.length > 0 ? diseases[0].name : 'Healthy',
          avgConfidence: diseases.length > 0 ? diseases.reduce((sum, d) => sum + d.confidence, 0) / diseases.length : 0,
          overallSeverity: envContext ? envContext.severity : 'unknown',
          deviceInfo: {
            userAgent: navigator.userAgent,
            platform: navigator.platform,
            screenResolution: window.screen.width + 'x' + window.screen.height
          }
        };
      }

      // Load analytics from Firebase (primary) with localStorage as fallback cache
      async function loadAnalytics() {
        // Wait for Firebase to be ready
        if (firebaseReadyPromise) {
          try {
            await firebaseReadyPromise;
          } catch (e) {
            console.warn('Firebase authentication failed, using localStorage');
          }
        }

        // Try to load from Firebase first
        if (firebaseReady && firebaseEnabled && db) {
          try {
            console.log('📥 Loading all data from Firebase...');

            // Load all logs from Firebase
            const logsSnapshot = await db.collection('diseaseAnalytics')
              .orderBy('timestamp', 'desc')
              .get();

            const firebaseLogs = [];
            logsSnapshot.forEach(doc => {
              const logData = doc.data();
              logData.firebaseId = doc.id;
              logData.savedToFirebase = true;
              // Do not load or persist embedded images
              if (logData.imageBase64) delete logData.imageBase64;
              firebaseLogs.push(logData);
            });

            analyticsData.logs = firebaseLogs;
            console.log('✅ Loaded', firebaseLogs.length, 'logs from Firebase (images ignored)');

            // Load model feedback from Firebase
            console.log('📥 Loading model feedback from Firebase...');
            try {
              const feedbackDoc = await db.collection('modelFeedback').doc('current').get();
              console.log('📄 Feedback document exists:', feedbackDoc.exists);

              if (feedbackDoc.exists) {
                const docData = feedbackDoc.data();
                console.log('📦 Document data:', docData);
                analyticsData.modelFeedback = docData.feedback || {};
                console.log('✅ Loaded model feedback from Firebase');
                console.log('📊 Model feedback data:', analyticsData.modelFeedback);
                console.log('📊 Number of models with feedback:', Object.keys(analyticsData.modelFeedback).length);
              } else {
                console.warn('⚠️ Model feedback document does not exist in Firebase');
                analyticsData.modelFeedback = {};
              }
            } catch (fbError) {
              console.error('❌ Failed to load model feedback (continuing with logs):', fbError);
            }

            // Initialize feedback structure to ensure all models exist
            initializeModelFeedback();

            // Update dashboard and charts after loading
            updateAnalyticsDashboard();
            updateHistoryPanel();
            updateModelPrecisionChart(); // Explicitly update chart after Firebase load

          } catch (e) {
            console.error('Failed to load from Firebase, using localStorage cache:', e);
            loadFromLocalStorageCache();
          }
        } else {
          console.warn('⚠️ Firebase not enabled, loading from localStorage cache');
          loadFromLocalStorageCache();
        }
      }

      // Fallback: Load from localStorage cache
      function loadFromLocalStorageCache() {
        const stored = localStorage.getItem('diseaseAnalytics');
        if (stored) {
          try {
            const data = JSON.parse(stored);
            // Support old format (array) and new format (object with logs and feedback)
            // Sanitize loaded logs to ensure no embedded images are kept
            if (Array.isArray(data)) {
              analyticsData.logs = data.map(l => { const c = { ...l }; if (c.imageBase64) delete c.imageBase64; return c; });
              analyticsData.modelFeedback = {};
            } else {
              analyticsData.logs = (data.logs || []).map(l => { const c = { ...l }; if (c.imageBase64) delete c.imageBase64; return c; });
              analyticsData.modelFeedback = data.modelFeedback || {};
            }
            console.log('📦 Loaded', analyticsData.logs.length, 'records from localStorage cache');

            // Initialize feedback structure
            initializeModelFeedback();

            // Update dashboard and charts after loading from cache
            updateAnalyticsDashboard();
            updateHistoryPanel();
            updateModelPrecisionChart();
          } catch (e) {
            console.error('Failed to load from localStorage:', e);
            analyticsData.logs = [];
            analyticsData.modelFeedback = {};
          }
        }
      }

      // Save analytics to Firebase (primary) and localStorage (backup cache only)
      function saveAnalytics() {
        // Save to Firebase as primary storage
        if (firebaseReady && firebaseEnabled && db) {
          // Save all logs to Firebase
          analyticsData.logs.forEach(log => {
            if (!log.savedToFirebase) {
              saveToFirebase(log).then((id) => {
                log.savedToFirebase = true;
                if (id) log.firebaseId = id;
                showToast('Synced: ' + (log.id || id), 'success', 1800);
              }).catch(err => {
                console.error('Failed to save log to Firebase:', err);
                showToast('Failed to sync: ' + (log.id || ''), 'error', 3500);
              });
            }
          });

          // Save model feedback separately (only if there's data)
          const feedbackKeys = Object.keys(analyticsData.modelFeedback);
          if (feedbackKeys.length > 0) {
            console.log('💾 Saving', feedbackKeys.length, 'model feedback entries to Firebase...');
            console.log('📝 Feedback data to save:', JSON.stringify(analyticsData.modelFeedback));

            db.collection('modelFeedback').doc('current').set({
              feedback: analyticsData.modelFeedback,
              lastUpdated: new Date().toISOString(),
              userId: auth.currentUser ? auth.currentUser.uid : 'anonymous'
            }, { merge: true }).then(() => {
              console.log('✅ Model feedback saved to Firebase successfully');

              // Verify save by reading back
              db.collection('modelFeedback').doc('current').get().then(doc => {
                if (doc.exists) {
                  console.log('✅ Verified - Feedback in Firebase:', Object.keys(doc.data().feedback || {}).length, 'models');
                } else {
                  console.error('❌ Verification failed - Document does not exist after save!');
                }
              });
            }).catch(err => {
              console.error('❌ Failed to save model feedback to Firebase:', err);
            });
          } else {
            console.log('ℹ️ No model feedback to save yet');
          }

          console.log('✅ All logs saved to Firebase');
        } else {
          console.warn('⚠️ Firebase not enabled, using localStorage as fallback');
        }

        // Keep minimal cache in localStorage (last 20 records only for offline access)
        try {
          const recentLogs = analyticsData.logs.slice(-20);
          const dataToSave = {
            logs: recentLogs,
            modelFeedback: analyticsData.modelFeedback,
            cache: {}, // placeholder - ensure defined
            cacheOnly: true
          };
          localStorage.setItem('diseaseAnalytics', JSON.stringify(dataToSave));
          console.log('Cached', recentLogs.length, 'recent records to localStorage');
        } catch (e) {
          console.error('Failed to cache to localStorage:', e);
        }
      }

      // Utility: Recursively replace undefined values with null (safe for Firestore)
      function sanitizeForFirestore(obj) {
        if (obj === undefined) return null;
        if (obj === null) return null;
        if (Array.isArray(obj)) {
          return obj.map(v => sanitizeForFirestore(v));
        }
        if (typeof obj === 'object') {
          const out = {};
          Object.keys(obj).forEach(k => {
            const v = obj[k];
            if (v === undefined) {
              out[k] = null;
            } else if (typeof v === 'object' && v !== null) {
              out[k] = sanitizeForFirestore(v);
            } else {
              out[k] = v;
            }
          });
          return out;
        }
        return obj;
      }

      // Save to Firebase Firestore
      async function saveToFirebase(logEntry) {
        if (!firebaseReady || !firebaseEnabled || !db) {
          log.warn('⚠️ Firebase not available, using localStorage only');
          return;
        }

        try {
          // Store complete entry without image in Firestore
          const { imageBase64, ...firestoreEntry } = logEntry;

          // Sanitize to avoid unsupported 'undefined' values
          const cleanEntry = sanitizeForFirestore(firestoreEntry);

          // Add to Firestore without image data
          const docRef = await db.collection('diseaseAnalytics').add({
            ...cleanEntry,
            uploadedAt: firebase.firestore.FieldValue.serverTimestamp(),
            userId: auth.currentUser ? auth.currentUser.uid : 'anonymous'
          });

          console.log('✅ Saved to Firebase with ID:', docRef.id);
          console.log('ℹ️ Image not stored in Firestore. Logs only.');

          return docRef.id;
        } catch (e) {
          console.error('❌ Failed to save to Firebase:', e);
          throw e;
        }
      }

      // Convert base64 to blob
      function base64ToBlob(base64, contentType) {
        const byteCharacters = atob(base64);
        const byteArrays = [];

        for (let offset = 0; offset < byteCharacters.length; offset += 512) {
          const slice = byteCharacters.slice(offset, offset + 512);
          const byteNumbers = new Array(slice.length);
          for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
          }
          const byteArray = new Uint8Array(byteNumbers);
          byteArrays.push(byteArray);
        }

        return new Blob(byteArrays, { type: contentType });
      }

      // Log analysis result (enhanced with complete data)
      async function logAnalysis(results, sensorData, envContext, analysisId) {
        const logEntry = createCompleteLogEntry(results, sensorData, envContext);
        logEntry.id = analysisId; // Store the analysis ID
        logEntry.modelFeedbacks = {}; // Initialize empty feedback object

        analyticsData.logs.push(logEntry);
        saveAnalytics();

        // Save to Firebase asynchronously
        if (firebaseReady && firebaseEnabled) {
          saveToFirebase(logEntry).catch(err => {
            console.error('Firebase save failed, data is in localStorage:', err);
          });
        }

        updateAnalyticsDashboard();
        updateHistoryPanel();
      }

      // Load from Firebase
      async function loadFromFirebase(showAlert = true) {
        // Wait for Firebase to be ready
        if (firebaseReadyPromise) {
          try {
            await firebaseReadyPromise;
          } catch (e) {
            if (showAlert) alert('Firebase not connected. Using local data only.');
            return;
          }
        }

        if (!firebaseReady || !firebaseEnabled || !db) {
          if (showAlert) alert('Firebase not connected. Using local data only.');
          return;
        }

        try {
          // Get button element if called from UI (event exists)
          const btn = event?.target;
          if (btn) {
            btn.disabled = true;
            btn.textContent = translateText('⏳ Loading...');
          }

          const snapshot = await db.collection('diseaseAnalytics')
            .orderBy('timestamp', 'desc')
            .limit(100)
            .get();

          const firebaseLogs = [];
          snapshot.forEach(doc => {
            const data = doc.data();
            firebaseLogs.push({ ...data, firebaseId: doc.id });
          });

          console.log('✅ Loaded', firebaseLogs.length, 'records from Firebase');
          // Any embedded images in Firebase records are intentionally ignored for privacy and storage policy.

          // Merge with local data (remove duplicates by timestamp)
          const merged = [...analyticsData.logs, ...firebaseLogs];
          const unique = merged.filter((log, index, self) =>
            index === self.findIndex(l => l.timestamp === log.timestamp)
          );

          analyticsData.logs = unique.sort((a, b) =>
            new Date(a.timestamp) - new Date(b.timestamp)
          );

          saveAnalytics();
          updateAnalyticsDashboard();
          updateHistoryPanel();

          if (showAlert) alert('Loaded ' + firebaseLogs.length + ' records from Firebase');

          if (btn) {
            btn.disabled = false;
            btn.textContent = translateText('📥 Load');
          }
        } catch (e) {
          console.error('❌ Failed to load from Firebase:', e);
          if (showAlert) alert('Failed to load from Firebase: ' + e.message);
          if (event?.target) {
            event.target.disabled = false;
            event.target.textContent = translateText('📥 Load');
          }
        }
      }

      // Image loading from Firebase removed — application no longer loads or displays stored images.

      // Show transient toast notifications
      function showToast(message, type = 'info', duration = 3500) {
        try {
          const container = document.getElementById('toasts');
          if (!container) return;
          const el = document.createElement('div');
          el.className = `toast ${type}`;
          el.innerHTML = `<div class="label">${message}</div>`;
          container.appendChild(el);
          // force reflow then show
          requestAnimationFrame(() => el.classList.add('show'));
          setTimeout(() => {
            el.classList.remove('show');
            setTimeout(() => el.remove(), 300);
          }, duration);
        } catch (err) {
          console.log('Toast error:', err);
        }
      }

      // One-time resync helper: upload unsynced logs with per-record toasts and final summary
      async function resyncLocalLogs() {
        const btn = (event && event.target) ? event.target : document.querySelector('.btn.sec[onclick="resyncLocalLogs()"]');
        if (btn) { btn.disabled = true; btn.textContent = translateText('⏳ Resyncing...'); }

        if (!firebaseEnabled || !db) {
          showToast('Firebase not configured. Update firebaseConfig first.', 'error', 5000);
          if (btn) { btn.disabled = false; btn.textContent = translateText('Resync'); }
          return { success: 0, failed: 0 };
        }

        const unsynced = analyticsData.logs.filter(l => !l.firebaseId || !l.savedToFirebase);
        if (unsynced.length === 0) {
          showToast('No unsynced local logs found.', 'info');
          return { success: 0, failed: 0 };
        }

        showToast(`Resyncing ${unsynced.length} local records...`, 'info', 2500);
        let success = 0, failed = 0;

        // prepare compact progress UI
        const progressEl = document.getElementById('resyncProgress');
        const progressBarFill = progressEl ? progressEl.querySelector('.resync-bar-fill') : null;
        const progressText = document.getElementById('resyncProgressText');
        if (progressEl) { progressEl.style.display = 'inline-flex'; }

        for (let i = 0; i < unsynced.length; i++) {
          const log = unsynced[i];
          try {
            const id = await saveToFirebase(log);
            if (id) {
              log.firebaseId = id;
              log.savedToFirebase = true;
              success++;
              showToast('Synced: ' + (log.id || id), 'success', 1800);
              // update local cache
              saveAnalytics();
            } else {
              failed++;
              showToast('Failed to sync: ' + (log.id || ''), 'error', 3000);
            }
          } catch (e) {
            failed++;
            showToast('Failed to sync: ' + (log.id || '') + ' (' + e.message + ')', 'error', 4000);
            console.error('Resync error for', log.id, e);
          }

          // update compact progress UI
          const done = i + 1;
          const total = unsynced.length;
          const pct = Math.round((done / total) * 100);
          if (progressBarFill) progressBarFill.style.width = pct + '%';
          if (progressText) progressText.textContent = `${done}/${total}`;

          // small pause to avoid rapid-fire
          await new Promise(r => setTimeout(r, 200));
        }
        // hide progress UI after short delay
        setTimeout(() => { if (progressEl) progressEl.style.display = 'none'; if (progressBarFill) progressBarFill.style.width = '0%'; if (progressText) progressText.textContent = ''; }, 700);
        showToast(`Resync complete: ${success} succeeded, ${failed} failed.`, failed > 0 ? 'error' : 'success', 5000);
        if (btn) { btn.disabled = false; btn.textContent = translateText('Resync'); }
        return { success, failed };
      }

      // Sync with Firebase (wrapper that calls resync helper and provides button feedback)
      async function syncWithFirebase() {
        if (!firebaseEnabled || !db) {
          alert('Firebase not configured. Please update firebaseConfig in the code.');
          return;
        }
        const btn = (event && event.target) ? event.target : document.querySelector('.btn.sec[onclick="syncWithFirebase()"]');
        if (btn) { btn.disabled = true; btn.textContent = translateText('⏳ Syncing...'); }

        try {
          const { success, failed } = await resyncLocalLogs();
          if (btn) { btn.disabled = false; btn.textContent = translateText('Sync'); }
          return { success, failed };
        } catch (e) {
          console.error('❌ Sync failed:', e);
          if (btn) { btn.disabled = false; btn.textContent = translateText('Sync'); }
          showToast('Sync failed: ' + e.message, 'error', 5000);
        }
      }

      // Update analytics dashboard
      function updateAnalyticsDashboard() {
        if (analyticsData.logs.length === 0) {
          // No analytics logs
          updateCharts();
          return;
        }

        // Calculate statistics
        const totalScans = analyticsData.logs.length;
        const diseaseLogs = analyticsData.logs.filter(log => log.primaryDisease !== 'Healthy');
        const diseasesFound = diseaseLogs.length;

        const totalConfidence = analyticsData.logs.reduce((sum, log) => sum + log.avgConfidence, 0);
        const avgConfidence = totalScans > 0 ? (totalConfidence / totalScans).toFixed(1) : 0;

        // Risk level assessment
        const recentLogs = analyticsData.logs.slice(-10);
        const recentDiseases = recentLogs.filter(log => log.primaryDisease !== 'Healthy').length;
        const riskLevel = recentDiseases >= 7 ? 'High' : recentDiseases >= 4 ? 'Medium' : 'Low';

        // Platform analytics stats removed
        updateCharts();
      }

      // Update all charts
      function updateCharts() {
        // Disease and confidence charts removed
        // Sensor-related charts removed
        // updateTimelineChart(); // Removed
        updateModelPrecisionChart();
      }

      // Model Precision Chart based on user feedback
      function updateModelPrecisionChart() {
        const container = document.getElementById('modelPrecisionChartContainer');
        if (!container) {
          console.warn('⚠️ Chart container not found');
          return;
        }

        console.log('📊 Updating model precision chart with feedback data:', analyticsData.modelFeedback);

        const modelNames = [];
        const precisionData = [];
        const correctData = [];
        const wrongData = [];

        // Mapping for shorter names
        const shortNames = {
          'Object Detection (YOLOv8)': 'YOLOv8',
          'Rice Disease Detection (YOLOv8s)': 'Rice',
          'Wheat Disease (100% Accuracy)': 'Wheat',
          'Chili Plant Disease (81% mAP)': 'Chili',
          'Potato Disease (98.8% mAP)': 'Potato',
          'Tomato Disease (92.3% mAP)': 'Tomato',
          'Eggplant Disease (47.8% mAP)': 'Eggplant'
        };

        // Calculate precision for each model
        for (const modelName in analyticsData.modelFeedback) {
          const feedback = analyticsData.modelFeedback[modelName];
          if (feedback.total > 0) {
            // Use short name if available, else original
            modelNames.push(shortNames[modelName] || modelName);
            const precision = ((feedback.correct / feedback.total) * 100).toFixed(1);
            precisionData.push(parseFloat(precision));
            correctData.push(feedback.correct);
            wrongData.push(feedback.wrong);
          }
        }

        // If no data, show message
        if (modelNames.length === 0) {
          if (analyticsData.charts.modelPrecision) {
            analyticsData.charts.modelPrecision.destroy();
            analyticsData.charts.modelPrecision = null;
          }
          // Show message only (no canvas). When feedback arrives the canvas will be created and the message removed.
          container.innerHTML = '<p style="text-align: center; padding: 60px 20px; color: var(--on-surface-variant); font-size: 14px;">📊 No feedback data yet.<br><br>Rate model predictions using ✓ Correct or ✗ Wrong buttons to provide feedback so counts appear.</p>';
          console.log('ℹ️ No feedback data available for chart');
          return;
        }

        console.log('📊 Chart data - Models:', modelNames.length, '| Correct:', correctData, '| Wrong:', wrongData);

        // Ensure canvas exists (it might have been replaced with message)
        let canvas = document.getElementById('modelPrecisionChart');

        if (!canvas) {
          console.log('🔄 Recreating chart canvas...');
          container.innerHTML = '<canvas id="modelPrecisionChart" style="width: 100%; height: 100%;"></canvas>';
          canvas = document.getElementById('modelPrecisionChart');
        }

        // Destroy existing chart
        if (analyticsData.charts.modelPrecision) {
          analyticsData.charts.modelPrecision.destroy();
          analyticsData.charts.modelPrecision = null;
        }

        console.log('✅ Creating chart with', modelNames.length, 'models');

        // Create new chart with larger bars
        analyticsData.charts.modelPrecision = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: modelNames,
            datasets: [
              {
                label: 'Correct',
                data: correctData,
                backgroundColor: '#34A85340',
                borderColor: '#34A853',
                borderWidth: 2,
                borderRadius: 6,
                yAxisID: 'y'
              },
              {
                label: 'Wrong',
                data: wrongData,
                backgroundColor: '#EA433540',
                borderColor: '#EA4335',
                borderWidth: 2,
                borderRadius: 6,
                yAxisID: 'y'
              }
            ]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Count',
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  font: { size: 14, weight: 'bold' }
                },
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  font: { size: 13 }
                },
                grid: {
                  drawOnChartArea: true,
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant') || 'rgba(255, 255, 255, 0.1)'
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 25,
                  font: {
                    size: window.innerWidth < 600 ? 10 : 12,
                    weight: '500'
                  },
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 6 : 12
                },
                grid: {
                  display: false
                }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface'),
                  font: { size: 13, weight: '600' },
                  padding: 15,
                  usePointStyle: true
                }
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const label = context.dataset.label || '';
                    const value = context.parsed.y;
                    const modelName = context.label;
                    const feedback = analyticsData.modelFeedback[modelName];
                    if (!feedback) return label + ': ' + value;
                    if (label === 'Correct') {
                      return [
                        'Correct: ' + value,
                        'Wrong: ' + feedback.wrong,
                        'Total: ' + feedback.total
                      ];
                    } else if (label === 'Wrong') {
                      return [
                        'Wrong: ' + value,
                        'Correct: ' + feedback.correct,
                        'Total: ' + feedback.total
                      ];
                    }
                    return label + ': ' + value;
                  }
                }
              }
            }
          }
        });
      }

      // Disease and confidence chart functions removed

      // Sensor-related chart functions removed




      // History Panel Functions
      function updateHistoryPanel(filter = 'all') {
        const panel = document.getElementById('historyPanel');
        if (!panel) return;

        // Update active filter chip visual state
        document.querySelectorAll('.filter-chip').forEach(chip => {
          chip.classList.remove('active');
          if (chip.getAttribute('data-filter') === filter) chip.classList.add('active');
        });

        if (analyticsData.logs.length === 0) {
          panel.innerHTML = '<div style="text-align: center; padding: 48px 20px;"><span class="material-symbols-rounded" style="font-size: 48px; color: var(--outline); margin-bottom: 16px;">history</span><p style="color: var(--on-surface-variant);">No diagnostic history available.<br>Run an analysis to see logs here.</p></div>';
          return;
        }

        // Filter logs
        let filteredLogs = [...analyticsData.logs];
        if (filter === 'diseases') {
          filteredLogs = filteredLogs.filter(log => log.primaryDisease !== 'Healthy');
        } else if (filter === 'healthy') {
          filteredLogs = filteredLogs.filter(log => log.primaryDisease === 'Healthy');
        }

        // Sort by timestamp (newest first)
        filteredLogs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));

        let html = '<div class="timeline-feed">';

        filteredLogs.forEach((log, index) => {
          const date = new Date(log.timestamp);
          const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const dateStr = date.toLocaleDateString();

          // Determine severity and styling
          let severity = 'low';
          if (log.environmentalContext) severity = log.environmentalContext.severity;
          // Fallback severity based on disease
          if (log.primaryDisease !== 'Healthy' && !log.environmentalContext) severity = 'moderate';
          if (log.primaryDisease === 'Healthy') severity = 'low';

          const isHealthy = log.primaryDisease === 'Healthy';
          const icon = isHealthy ? 'check_circle' : 'coronavirus';

          // Generate Summary Text
          let summaryText = '';
          if (isHealthy) {
            summaryText = 'Plant appears healthy based on visual analysis.';
          } else {
            // Collect unique diseases detected
            const uniqueDiseases = [...new Set(log.diseases ? log.diseases.map(d => d.name) : [])];
            if (uniqueDiseases.length > 0) {
              summaryText = 'Detected: ' + uniqueDiseases.join(', ');
            } else {
              summaryText = 'Potential issues detected.';
            }
          }

          html += `
          <div class="log-card ${severity}" id="log_${log.id}">
            <!-- Header -->
            <div class="log-header">
              <div class="log-meta">
                <span class="log-date">${dateStr} • ${timeStr}</span>
                ${!isHealthy ? `<span class="log-badge ${severity}">${severity}</span>` : ''}
              </div>
              <button class="log-delete-btn" onclick="event.stopPropagation(); deleteAnalysis('${log.id}')" title="Delete Entry">
                <span class="material-symbols-rounded" style="font-size: 18px;">delete</span>
              </button>
            </div>

            <!-- Body (Click to expand) -->
            <div class="log-body" onclick="toggleHistoryDetails('${log.id}')">
              <div class="log-main-row">
                <div class="log-title">
                  <span class="material-symbols-rounded" style="color: ${isHealthy ? 'var(--success)' : 'var(--error)'};">${icon}</span>
                  ${log.primaryDisease}
                </div>
                <div class="log-confidence">${log.avgConfidence.toFixed(0)}<span style="font-size:12px; margin-left:2px;">%</span></div>
              </div>
              <div class="log-summary">${summaryText}</div>
            </div>

            <!-- Details (Collapsible) -->
            <div class="log-details" id="details_${log.id}">
              
              <!-- Sensor Data Section -->
              ${log.sensorData ? `
                <div class="log-section-title">Environment Sensors</div>
                <div class="log-sensor-grid">
                  <div class="log-sensor-item">
                    <span class="material-symbols-rounded">thermostat</span>
                    <span>${log.sensorData.airTemp.toFixed(1)}°C</span>
                  </div>
                  <div class="log-sensor-item">
                    <span class="material-symbols-rounded">water_drop</span>
                    <span>${log.sensorData.airHumidity.toFixed(1)}%</span>
                  </div>
                  <div class="log-sensor-item">
                    <span class="material-symbols-rounded">potted_plant</span>
                    <span>${log.sensorData.soilMoisture.toFixed(1)}%</span>
                  </div>
                </div>
              ` : ''}

              <!-- Model Results Section -->
              <div class="log-section-title">AI Model Consensus</div>
              <div class="log-model-list">
                ${(log.allModelResults || []).map(m => {
            const mName = m.modelName.replace(/\(.*\)/, '').trim(); // Clean name
            const mRes = m.error ? 'Error' : (m.detectedClass || 'No detection');
            const mConf = m.confidence ? `(${m.confidence.toFixed(0)}%)` : '';
            const mColor = m.detectedClass && m.detectedClass !== 'Healthy' ? 'var(--error)' : 'var(--on-surface-variant)';
            return `
                    <div class="log-model-row">
                      <span class="log-model-name">${mName}</span>
                      <span class="log-model-result" style="color: ${mColor}">${mRes} ${mConf}</span>
                    </div>
                  `;
          }).join('')}
              </div>
              
              <!-- Footer Actions -->
              <div style="margin-top: 16px; text-align: right;">
                 <span style="font-size: 10px; color: var(--on-surface-variant); text-transform: uppercase;">ID: ${log.id.substring(4, 14)}...</span>
              </div>
            </div>
          </div>
        `;
        });

        html += '</div>';
        panel.innerHTML = html;
      }

      function toggleHistoryDetails(logId) {
        const card = document.getElementById('log_' + logId);
        if (!card) return;

        if (card.classList.contains('expanded')) {
          card.classList.remove('expanded');
        } else {
          // Close all other expanded items
          document.querySelectorAll('.log-card.expanded').forEach(el => {
            el.classList.remove('expanded');
          });
          card.classList.add('expanded');
        }
      }

      function filterHistory(filter) {
        updateHistoryPanel(filter);
      }

      async function deleteAnalysis(logId) {
        if (!confirm('Are you sure you want to delete this analysis record? This action cannot be undone.')) {
          return;
        }

        try {
          // Remove from localStorage
          const logs = JSON.parse(localStorage.getItem('analysisLogs') || '[]');
          const updatedLogs = logs.filter(log => log.id !== logId);
          localStorage.setItem('analysisLogs', JSON.stringify(updatedLogs));

          console.log('✅ Deleted from local storage:', logId);

          // Remove from Firebase if connected
          if (firebaseEnabled && db) {
            try {
              // Find the document with matching id field
              const snapshot = await db.collection('diseaseAnalytics')
                .where('id', '==', logId)
                .limit(1)
                .get();

              if (!snapshot.empty) {
                await snapshot.docs[0].ref.delete();
                console.log('✅ Deleted from Firebase:', logId);
              }
            } catch (fbError) {
              console.error('⚠️ Failed to delete from Firebase:', fbError);
            }
          }

          // Update UI
          updateHistoryPanel();

          // Show success message
          alert('✅ Record deleted successfully!');
        } catch (error) {
          console.error('❌ Delete failed:', error);
          alert('❌ Failed to delete record: ' + error.message);
        }
      }

      function getTimeAgo(date) {
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'just now';
        if (diffMins < 60) return diffMins + ' min ago';
        if (diffHours < 24) return diffHours + ' hour' + (diffHours > 1 ? 's' : '') + ' ago';
        if (diffDays < 7) return diffDays + ' day' + (diffDays > 1 ? 's' : '') + ' ago';
        return date.toLocaleDateString();
      }

      // Export analytics data
      function exportAnalyticsData() {
        if (analyticsData.logs.length === 0) {
          alert('No analytics data to export');
          return;
        }

        const dataStr = JSON.stringify(analyticsData.logs, null, 2);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'disease_analytics_' + new Date().toISOString().split('T')[0] + '.json';
        a.click();
        URL.revokeObjectURL(url);
      }

      // Clear analytics data
      async function clearAnalyticsData() {
        if (!confirm('Are you sure you want to clear the Diagnostic Log? This will permanently delete all analysis history from this device and from Firebase. This action cannot be undone.')) {
          return;
        }

        // Clear local data
        analyticsData.logs = [];
        saveAnalytics(); // This will clear localStorage
        updateAnalyticsDashboard();
        updateHistoryPanel();

        // Clear from Firebase
        if (firebaseReady && firebaseEnabled && db) {
          console.log('🗑️ Deleting all logs from Firebase...');
          try {
            const snapshot = await db.collection('diseaseAnalytics').limit(500).get(); // Limit to 500 per batch
            if (snapshot.empty) {
              console.log('✅ No logs to delete in Firebase.');
              alert('Diagnostic Log cleared.');
              return;
            }

            const batch = db.batch();
            snapshot.docs.forEach(doc => {
              batch.delete(doc.ref);
            });

            await batch.commit();

            console.log('✅ Batch of', snapshot.size, 'logs deleted from Firebase.');

            // If there might be more logs, recursively call until empty
            if (snapshot.size === 500) {
              console.log('There might be more logs to delete, running again...');
              await clearAnalyticsData();
            } else {
              alert('Diagnostic Log cleared from this device and from Firebase.');
            }
          } catch (e) {
            console.error('❌ Failed to delete logs from Firebase:', e);
            alert('Error clearing logs from Firebase: ' + e.message);
          }
        } else {
          alert('Diagnostic Log cleared from this device.');
        }
      }

      // Disease name aliases and variations for improved matching accuracy
      const DISEASE_ALIASES = {
        'tomato_septoria_leaf_spot': ['septoria', 'septoria leaf spot', 'tomato septoria'],
        'tomato_early_blight': ['early blight', 'alternaria solani', 'target spot tomato'],
        'tomato_late_blight': ['late blight', 'phytophthora', 'tomato blight'],
        'tomato_bacterial_spot': ['bacterial spot', 'xanthomonas', 'bacterial speck'],
        'tomato_target_spot': ['target spot', 'corynespora'],
        'tomato_yellow_leaf_curl': ['yellow leaf curl', 'tylcv', 'leaf curl virus', 'tomato virus'],
        'tomato_mosaic': ['mosaic virus', 'tmv', 'tobacco mosaic', 'viral disease'],
        'tomato_leaf_mold': ['leaf mold', 'cladosporium', 'mold'],
        'tomato_spider_mites': ['spider mites', 'two spotted mites', 'mites', 'red spider'],
        'potato_early_blight': ['potato early blight', 'alternaria', 'early blight potato'],
        'potato_late_blight': ['potato late blight', 'late blight potato', 'phytophthora potato'],
        'corn_common_rust': ['corn rust', 'maize rust', 'rust', 'puccinia'],
        'corn_gray_leaf_spot': ['gray leaf spot', 'grey leaf spot', 'cercospora maize'],
        'corn_northern_leaf_blight': ['northern leaf blight', 'turcicum', 'leaf blight corn'],
        'grape_black_rot': ['black rot grape', 'guignardia', 'grape rot'],
        'grape_esca': ['esca', 'black measles', 'grapevine decline'],
        'grape_leaf_blight': ['leaf blight grape', 'isariopsis', 'grape leaf spot'],
        'strawberry_leaf_scorch': ['leaf scorch', 'diplocarpon', 'strawberry scorch'],
        'apple_black_rot': ['black rot apple', 'frog eye', 'apple rot'],
        'apple_cedar_rust': ['cedar rust', 'gymnosporangium', 'apple rust'],
        'cherry_powdery_mildew': ['cherry mildew', 'powdery mildew cherry'],
        'peach_bacterial_spot': ['peach spot', 'bacterial spot peach', 'xanthomonas peach'],
        'pepper_bacterial_spot': ['pepper spot', 'bacterial spot pepper'],
        'bell_pepper_bacterial_spot': ['bell pepper spot', 'bacterial spot bell pepper'],
        'squash_powdery_mildew': ['squash mildew', 'cucurbit mildew', 'powdery mildew squash'],
        'banana_pestalotiopsis': ['pestalotiopsis', 'banana leaf spot', 'sigatoka'],
        'banana_black_sigatoka': ['black sigatoka', 'black leaf streak', 'mycosphaerella'],
        'banana_panama_disease': ['panama disease', 'fusarium wilt banana', 'banana wilt'],
        'rice_bacterial_leaf_blight': ['bacterial blight rice', 'kresek', 'xanthomonas rice', 'bacterial leaf blight', 'blb'],
        'rice_brown_spot': ['brown spot rice', 'helminthosporium', 'narrow brown spot', 'brown spot'],
        'rice_blast': ['blast', 'leaf blast', 'neck blast', 'panicle blast', 'pyricularia', 'magnaporthe'],
        'rice_sheath_blight': ['sheath blight', 'rhizoctonia rice', 'sheath rot rice'],
        'rice_tungro': ['tungro', 'tungro disease', 'rice tungro virus', 'rtv'],
        'rice_hispa': ['hispa', 'rice hispa beetle', 'leaf miner rice'],
        'rice_leaf_folder': ['leaf folder', 'leaf roller', 'cnaphalocrocis'],
        'rice_false_smut': ['false smut', 'green smut', 'ustilaginoidea'],
        'rice_sheath_rot': ['sheath rot', 'sarocladium'],
        'bacterial_leaf_streak': ['leaf streak', 'bacterial streak', 'xanthomonas oryzae'],
        'wheat_leaf_rust': ['wheat rust', 'brown rust', 'puccinia wheat'],
        'wheat_yellow_rust': ['yellow rust', 'stripe rust', 'puccinia striiformis'],
        'soybean_sudden_death': ['sudden death', 'sds', 'fusarium soybean'],
        'cotton_bacterial_blight': ['angular leaf spot cotton', 'bacterial blight cotton'],
        'chili_leaf_curl': ['chili leaf curl', 'pepper leaf curl', 'leaf curl disease chili', 'chili virus'],
        'chili_anthracnose': ['anthracnose chili', 'fruit rot chili', 'colletotrichum chili'],
        'chili_bacterial_wilt': ['bacterial wilt chili', 'ralstonia chili', 'wilt disease chili'],
        'chili_powdery_mildew': ['powdery mildew chili', 'white mildew chili', 'leveillula chili'],
        'chili_mosaic_virus': ['chili mosaic', 'pepper mosaic', 'cmv', 'viral disease chili'],
        'chili_thrips': ['thrips chili', 'pepper thrips', 'scirtothrips', 'yellow thrips'],
        'chili_fruit_borer': ['fruit borer chili', 'helicoverpa chili', 'pod borer'],
        'potato_early_blight': ['potato early blight', 'early blight potato', 'alternaria potato'],
        'potato_black_scurf': ['black scurf', 'rhizoctonia potato', 'stem canker potato'],
        'potato_common_scab': ['common scab potato', 'scab potato', 'streptomyces scab']
      };

      // Enhanced matching function with scoring algorithm
      function getRemedy(diseaseName) {
        if (!diseaseName || diseaseName === '-') return 'N/A';

        const name = diseaseName.toLowerCase().trim();

        // Remove underscores and extra spaces
        const cleanName = name.replace(/_/g, ' ').replace(/\s+/g, ' ');

        // First, check for exact matches (highest priority)
        for (const [key, remedy] of Object.entries(REMEDIES)) {
          if (cleanName === key || name === key) {
            return getTranslatedRemedy(remedy);
          }
        }

        // Second, check disease aliases
        for (const [aliasKey, aliasList] of Object.entries(DISEASE_ALIASES)) {
          const cleanAliasKey = aliasKey.replace(/_/g, ' ');
          if (cleanName === cleanAliasKey || name === aliasKey) {
            // Find remedy by checking alias list against remedy keys
            for (const alias of aliasList) {
              for (const [key, remedy] of Object.entries(REMEDIES)) {
                if (key === alias || alias.includes(key) || key.includes(alias)) {
                  return getTranslatedRemedy(remedy);
                }
              }
            }
          }
        }

        // Third, check if any alias matches the input
        for (const [aliasKey, aliasList] of Object.entries(DISEASE_ALIASES)) {
          for (const alias of aliasList) {
            if (cleanName.includes(alias) || alias.includes(cleanName)) {
              // Found a match, now find the remedy
              for (const [key, remedy] of Object.entries(REMEDIES)) {
                if (aliasList.some(a => a === key || a.includes(key) || key.includes(a))) {
                  return remedy;
                }
              }
            }
          }
        }

        // Fourth, fuzzy matching with scoring
        let bestMatch = null;
        let bestScore = 0;

        for (const [key, remedy] of Object.entries(REMEDIES)) {
          let score = 0;

          // Calculate match score
          if (cleanName.includes(key)) score += 10;
          if (key.includes(cleanName)) score += 8;

          // Word-by-word matching
          const nameWords = cleanName.split(' ');
          const keyWords = key.split(' ');

          for (const nWord of nameWords) {
            for (const kWord of keyWords) {
              if (nWord === kWord) score += 5;
              else if (nWord.includes(kWord) || kWord.includes(nWord)) score += 3;
              // Check for common disease terms
              if (['blight', 'spot', 'rot', 'wilt', 'rust', 'mildew', 'mosaic', 'curl'].includes(nWord) &&
                ['blight', 'spot', 'rot', 'wilt', 'rust', 'mildew', 'mosaic', 'curl'].includes(kWord)) {
                score += 2;
              }
            }
          }

          // Bonus for plant name matches
          const plants = ['tomato', 'potato', 'corn', 'maize', 'wheat', 'rice', 'grape', 'apple', 'banana',
            'pepper', 'chili', 'cucumber', 'cabbage', 'onion', 'soybean', 'cotton'];
          for (const plant of plants) {
            if (cleanName.includes(plant) && key.includes(plant)) score += 4;
          }

          if (score > bestScore && score >= 5) {
            bestScore = score;
            bestMatch = remedy;
          }
        }

        if (bestMatch) return getTranslatedRemedy(bestMatch);

        const keywords = {
          'blight': 'blight',
          'spot': 'bacterial spot',
          'rot': 'rot',
          'wilt': 'wilt',
          'rust': 'rust',
          'mildew': 'powdery mildew',
          'mosaic': 'mosaic virus',
          'curl': 'leaf curl',
          'borer': 'fruit borer',
          'mite': 'spider mites',
          'aphid': 'aphids',
          'whitefly': 'whitefly',
          'thrips': 'thrips'
        };

        for (const [keyword, remedyKey] of Object.entries(keywords)) {
          if (cleanName.includes(keyword) && REMEDIES[remedyKey]) {
            return getTranslatedRemedy(REMEDIES[remedyKey]);
          }
        }

        return getTranslatedRemedy(REMEDIES.default);
      }

      let BASE_URL = 'http://10.180.248.33';  // Default ESP32 IP
      const api = (path) => BASE_URL + path;
      let streamActive = false;






      // Translate remedy text to Bengali (simple token replacements)
      function translateRemedyText(remedy) {
        const lang = getLang();
        if (lang !== 'bn' || !remedy) return remedy;
        let text = remedy;

        const tokenMap = {
          'Organic:': 'অর্গানিক:',
          '🔹 Organic:': '🔹 অর্গানিক:',
          'Chemical:': 'রাসায়নিক:',
          '🔹 Chemical:': '🔹 রাসায়নিক:',
          'Spray': 'ছিটান',
          'Apply': 'প্রয়োগ করুন',
          'Soil': 'মাটি',
          'Soil drench': 'মাটি ড্রেঞ্চ',
          'Seed treatment': 'বীজ চিকিৎসা',
          'Foliar': 'পাতায় স্প্রে',
          'Remove infected plants immediately': 'অবিলম্বে আক্রান্ত গাছ অপসারন করুন',
          'No cure available': 'কোনও চিকিৎসা নেই',
          'No disease detected': 'কোনো রোগ সনাক্ত হয়নি',
          'Unable to detect disease. Ensure proper image quality. If disease visible, consult agricultural expert with leaf sample for proper diagnosis.': 'রোগ সনাক্ত করা যায়নি। সঠিক নির্ণয়ের জন্য ছবি মান নিশ্চিত করুন; গুরুতর হলে লিফ নমুনা নিয়ে কৃষি বিশেষজ্ঞের সাথে যোগাযোগ করুন.'
        };

        Object.entries(tokenMap).forEach(([k, v]) => {
          const re = new RegExp(k.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
          text = text.replace(re, v);
        });

        return text;
      }

      function getTranslatedRemedy(remedy) {
        if (getLang() === 'bn') return translateRemedyText(remedy);
        return remedy;
      }

      // Fetch with timeout helper
      function fetchWithTimeout(url, options = {}, timeout = 5000) {
        return Promise.race([
          fetch(url, options),
          new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), timeout))
        ]);
      }

      function setIP() {
        const ip = document.getElementById('ipInput').value.trim();
        if (!ip) {
          alert('Please enter ESP32 IP address');
          return;
        }

        const cleanIP = ip.replace('http://', '').replace('https://', '');
        BASE_URL = `http://${cleanIP}`;
        localStorage.setItem('esp32_ip', BASE_URL);

        console.log('Connecting to:', BASE_URL);
        const cs = document.getElementById('connStatus');
        if (cs) { cs.textContent = translateText('Connecting...'); cs.className = 'conn-status'; }

        const espDot = document.getElementById('espDot');
        const espStatus = document.getElementById('espStatus');
        espDot.classList.remove('offline');
        // espStatus.textContent = 'Connecting...';

        const testPaths = ['/capture', '/capture.jpg', '/stream', '/'];

        function testWithImage(path, timeout = 5000) {
          return new Promise((resolve, reject) => {
            const img = new Image();
            let timer = setTimeout(() => {
              img.src = '';
              reject(new Error('Timeout'));
            }, timeout);
            img.onload = () => { clearTimeout(timer); resolve(path); };
            img.onerror = () => { clearTimeout(timer); reject(new Error('Image load error')); };
            img.src = `${BASE_URL}${path}?_t=${Date.now()}`;
          });
        }

        (async () => {
          let ok = false;
          for (const p of testPaths) {
            try {
              await testWithImage(p, 4000);
              ok = true;
              console.log('✓ ESP32 reachable via', p);
              break;
            } catch (err) {
              console.log('Attempt failed for', p, err.message);
            }
          }

          if (ok) {
            if (cs) { cs.textContent = translateText('ESP32 reachable'); cs.className = 'conn-status success'; }
            document.getElementById('visualBtn').disabled = false;
            document.getElementById('toggleBtn').disabled = false;
            document.getElementById('streamPlaceholder').textContent = translateText('Ready. Click "Start stream" to preview.');
            // document.getElementById('cs').textContent = 'Ready';
            document.getElementById('camDot').classList.remove('offline');
            espDot.classList.remove('offline');
            // espStatus.textContent = 'Online';
          } else {
            console.error('Connection failed: ESP32 not reachable at', cleanIP);
            if (cs) { cs.textContent = translateText('Cannot reach ESP32 at') + ' ' + cleanIP; cs.className = 'conn-status error'; }
            document.getElementById('streamPlaceholder').textContent = translateText('No Connection');
            // document.getElementById('cs').textContent = 'Offline';
            document.getElementById('camDot').classList.add('offline');
            espDot.classList.add('offline');
            // espStatus.textContent = 'Offline';
          }
        })();
      }

      function startStream() {
        const streamBtn = document.getElementById('toggleBtn');
        streamBtn.disabled = true; // Disable button during connection attempt
        streamBtn.textContent = translateText('Starting...');

        const cs2 = document.getElementById('connStatus');
        if (cs2) { cs2.textContent = translateText('Connecting to stream...'); cs2.className = 'conn-status'; }
        // Show loading state
        const placeholder = document.getElementById('streamPlaceholder');
        placeholder.style.display = 'block';
        placeholder.textContent = translateText('Initializing stream...');
        document.getElementById('str').style.display = 'none';

        const streamImg = document.getElementById('str');
        // Remove crossOrigin to avoid strict CORS image handling in some browsers
        // (ESP responses already include Access-Control-Allow-Origin).

        // Consolidated handlers and cache-busting to ensure fresh connection
        let startTimeout = setTimeout(() => {
          console.warn('Stream load timeout');
          // Try fallback to capture polling if MJPEG fails
          startPollingCapture();
        }, 6000);

        streamImg.onload = function () {
          clearTimeout(startTimeout);
          placeholder.style.display = 'none';
          streamImg.style.display = 'block';

          console.log('✅ Stream started successfully');
          if (cs2) { cs2.textContent = translateText('Stream connected'); cs2.className = 'conn-status success'; }
          streamBtn.textContent = translateText('Stop Live View');
          streamBtn.disabled = false;
          streamActive = true;

          // document.getElementById('cs').textContent = 'Camera: Active';
          document.getElementById('camDot').classList.remove('offline');
          renderCtx(['Visual-only analysis. Sensors removed.']);
        };

        streamImg.onerror = function () {
          clearTimeout(startTimeout);
          console.error('Stream image failed to load; switching to capture polling fallback');
          startPollingCapture();
        };

        // Warm up the camera by requesting a single capture first, then start MJPEG stream.
        // This helps when the ESP's camera needs an initial request to begin producing frames.
        streamImg.style.display = 'none';
        const warmImg = new Image();
        let warmTimer = setTimeout(() => {
          // If warmup times out, still attempt the MJPEG stream
          warmImg.src = '';
          streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
        }, 1500);
        warmImg.onload = function () {
          clearTimeout(warmTimer);
          // After a successful single capture, attach the MJPEG stream
          streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
        };
        warmImg.onerror = function () {
          clearTimeout(warmTimer);
          // If warmup fails, still try the MJPEG stream (fallback handles failures)
          streamImg.src = `${BASE_URL}/stream?_t=${Date.now()}`;
        };
        // Trigger short warm-up request (capture.jpg)
        warmImg.src = `${BASE_URL}/capture.jpg?_t=${Date.now()}`;
      }

      // Polling fallback using /capture.jpg when MJPEG /stream isn't available
      let pollIntervalId = null;
      function startPollingCapture(interval = 800) {
        // clear existing handlers and any previous polling
        const streamImg = document.getElementById('str');
        const streamBtn = document.getElementById('toggleBtn');
        const placeholder = document.getElementById('streamPlaceholder');

        if (pollIntervalId) clearInterval(pollIntervalId);

        const cs3 = document.getElementById('connStatus');
        if (cs3) { cs3.textContent = translateText('Using capture polling'); cs3.className = 'conn-status warn'; }
        placeholder.textContent = translateText('Using fallback polling (capture.jpg)');
        placeholder.style.display = 'none';
        streamImg.style.display = 'block';
        streamBtn.textContent = translateText('Stop stream');
        streamBtn.disabled = false;
        streamActive = true;
        // document.getElementById('cs').textContent = 'Camera: Active (polling)';
        document.getElementById('camDot').classList.remove('offline');

        pollIntervalId = setInterval(() => {
          // append timestamp to avoid caching
          streamImg.src = `${BASE_URL}/capture.jpg?_t=${Date.now()}`;
        }, interval);
      }



      function toggleStream() {
        const streamImg = document.getElementById('str');
        const streamBtn = document.getElementById('toggleBtn');
        const placeholder = document.getElementById('streamPlaceholder');

        if (streamActive) {
          // Stop stream
          // Stop the MJPEG connection by setting to blank and removing handlers
          streamImg.onload = null;
          streamImg.onerror = null;
          streamImg.src = 'about:blank';
          streamImg.style.display = 'none';
          placeholder.style.display = 'block';
          placeholder.textContent = translateText('Stream paused');
          streamBtn.textContent = translateText('Start Live View');
          streamActive = false;

          // stop polling fallback if active
          if (pollIntervalId) { clearInterval(pollIntervalId); pollIntervalId = null; }

          // Update status
          // document.getElementById('cs').textContent = 'Camera: Paused';
          document.getElementById('camDot').classList.add('offline');
        } else {
          // Start stream
          startStream();
        }
      }

      function renderCtx(n) {
        document.getElementById('ctx').innerHTML = '<h4>Context notes</h4><ul>' + n.map(x => '<li>' + x + '</li>').join('') + '</ul>';
      }

      // Handle feedback button clicks
      function handleModelFeedback(analysisId, modelName, isCorrect, feedbackId) {
        // Record the feedback
        recordModelFeedback(analysisId, modelName, isCorrect);

        // Update button states
        const correctBtn = document.getElementById('correct_' + feedbackId);
        const wrongBtn = document.getElementById('wrong_' + feedbackId);
        const statusDiv = document.getElementById('feedback_status_' + feedbackId);

        if (correctBtn && wrongBtn && statusDiv) {
          if (isCorrect) {
            correctBtn.style.background = '#34A853';
            correctBtn.style.color = 'white';
            correctBtn.disabled = true;
            wrongBtn.disabled = true;
            wrongBtn.style.opacity = '0.5';
            statusDiv.textContent = translateText('✓ Marked as correct');
            statusDiv.style.color = '#34A853';
          } else {
            wrongBtn.style.background = '#EA4335';
            wrongBtn.style.color = 'white';
            wrongBtn.disabled = true;
            correctBtn.disabled = true;
            correctBtn.style.opacity = '0.5';
            statusDiv.textContent = translateText('✗ Marked as wrong');
            statusDiv.style.color = '#EA4335';
          }
        }

        // Show toast notification
        const toast = document.createElement('div');
        toast.style.cssText = 'position: fixed; top: 80px; right: 20px; background: ' + (isCorrect ? '#34A853' : '#EA4335') +
          '; color: white; padding: 12px 20px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.2); z-index: 10000; font-size: 14px; font-weight: 500;';
        toast.textContent = translateText('Feedback recorded for') + ' ' + modelName;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
      }

      function ctxNotes(s) {
        return ['Visual-only analysis. Sensors removed.'];
      }

      async function loadSensors() {
        // Sensors removed - visual-only mode
        renderCtx(['Visual-only analysis. Sensors removed.']);
        return null;
      }

      // Display active models in the result box
      function displayActiveModels() {
        const modelsList = document.getElementById('modelsList');
        if (!modelsList) return;

        let html = '';
        MODELS.forEach((model, index) => {
          const typeIcon = model.type === 'detection' ? '🎯' : '📊';
          const typeBadge = model.type === 'detection' ? translateText('Detection') : translateText('Classification');

          html += '<div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: var(--surface); border-radius: 6px; border: 1px solid rgba(26, 115, 232, 0.2);">';
          html += '<div style="display: flex; align-items: center; gap: 10px;">';
          html += '<span style="font-size: 20px;">' + typeIcon + '</span>';
          html += '<div>';
          html += '<div style="font-weight: 500; font-size: 13px; color: var(--on-surface);">' + translateText(model.name) + '</div>';
          html += '<div style="font-size: 11px; color: var(--on-surface-variant); margin-top: 2px;">' + translateText('Model:') + ' ' + model.id + '</div>';
          html += '</div>';
          html += '</div>';
          html += '<span style="padding: 4px 8px; background: rgba(26, 115, 232, 0.1); color: var(--primary); border-radius: 4px; font-size: 11px; font-weight: 600;">' + typeBadge + '</span>';
          html += '</div>';
        });

        modelsList.innerHTML = html;
      }

      // Initialize plant selector
      function initPlantSelector() {
        const selector = document.getElementById('plantSelector');
        if (!selector) return;

        let html = '';
        PLANT_TYPES.forEach(plant => {
          const isSelected = selectedPlantType === plant.id;
          html += '<button onclick="selectPlant(\'' + plant.id + '\')" style="';
          html += 'padding: 16px; border: 1px solid ' + (isSelected ? 'var(--primary)' : 'var(--outline-variant)') + ' !important; ';
          html += 'background: ' + (isSelected ? 'var(--primary-container)' : 'var(--surface)') + ' !important; ';
          html += 'border-radius: 16px !important; cursor: pointer; transition: all 0.2s; text-align: center;';
          html += '" id="plant_' + plant.id + '">';
          html += '<div style="font-size: 24px; margin-bottom: 4px;">' + plant.icon + '</div>';
          html += '<div style="font-size: 12px; font-weight: 600; color: var(--on-surface);">' + translateText(plant.name) + '</div>';
          html += '<div style="font-size: 10px; color: var(--on-surface-variant); margin-top: 2px;">' + plant.models + ' ' + translateText('models') + '</div>';
          html += '</button>';
        });

        selector.innerHTML = html;
      }

      // Select plant type
      function selectPlant(plantId) {
        selectedPlantType = plantId;

        // Update button styles
        PLANT_TYPES.forEach(plant => {
          const btn = document.getElementById('plant_' + plant.id);
          if (btn) {
            const isSelected = plant.id === plantId;
            btn.style.border = '1px solid ' + (isSelected ? 'var(--primary)' : 'var(--outline-variant)') + ' !important';
            btn.style.background = (isSelected ? 'var(--primary-container)' : 'var(--surface)') + ' !important';
          }
        });

        // Update info display
        const selectedPlant = PLANT_TYPES.find(p => p.id === plantId);
        if (selectedPlant) {
          document.getElementById('selectedPlantName').textContent = selectedPlant.icon + ' ' + translateText(selectedPlant.name);
          document.getElementById('selectedPlantDesc').textContent = translateText(selectedPlant.description);
        }

        console.log('\ud83c\udf31 Plant type selected:', plantId);
      }

      // Get filtered models based on selected plant
      function getActiveModels() {
        if (selectedPlantType === 'all') {
          return MODELS; // Return all models
        }

        // Filter models: include 'all' models + models specific to selected plant
        return MODELS.filter(model => {
          if (model.forPlants === 'all') return true; // General models always included
          if (Array.isArray(model.forPlants)) {
            return model.forPlants.includes(selectedPlantType);
          }
          return false;
        });
      }

      function showAnal() {
        const activeModels = getActiveModels();
        const plantInfo = PLANT_TYPES.find(p => p.id === selectedPlantType);
        const plantName = plantInfo ? plantInfo.icon + ' ' + translateText(plantInfo.name) : translateText('Plant');
        document.getElementById('res').innerHTML = '<div class="rc"><div class="t">' + translateText('Analyzing') + ' ' + plantName + ' ' + translateText('with') + ' ' + activeModels.length + ' ' + translateText('AI models') + '...</div><p style="color: var(--on-surface-variant); font-size: 14px;">' + translateText('Capturing and processing image') + '</p></div>';
      }

      function showMultiModelResults(results, s, consensusData) {
        const res = document.getElementById('res');

        // Generate unique analysis ID FIRST
        const analysisId = 'analysis_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);

        // Context/sensors removed - record visual-only analysis
        const envContext = null;
        // Do not store any images with the log
        logAnalysis(results, null, null, analysisId);

        // Build comparison table
        let html = '<div class="rc">';
        html += '<div class="t">' + translateText('Multi-Model Analysis') + '</div>';



        // CONSENSUS DECISION BOX
        if (consensusData && consensusData.note) {
          const isDisease = consensusData.disease && consensusData.disease.toLowerCase() !== 'healthy';
          const boxColor = isDisease ? '#EA4335' : '#34A853';
          const icon = isDisease ? '<span class="material-symbols-rounded" style="color:#EA4335; vertical-align:middle;">warning</span>' : '<span class="material-symbols-rounded" style="color:#34A853; vertical-align:middle;">check_circle</span>';
          const consensusIcon = isDisease ? '<span class="material-symbols-rounded" style="color:#EA4335; vertical-align:middle;">warning</span>' : '<span class="material-symbols-rounded" style="color:#34A853; vertical-align:middle;">check_circle</span>';

          html += '<div style="background:' + boxColor + '15; border:2px solid ' + boxColor + '; padding:16px; margin:12px 0; border-radius:8px;">';
          html += '<div style="font-weight:600; margin-bottom:8px; color:' + boxColor + '; font-size:16px;">';
          html += icon + ' ' + translateText('Smart Consensus Decision') + '</div>';
          html += consensusIcon + ' ' + translateText('Smart Consensus Decision') + '</div>';
          html += '<div style="font-size:14px; color:var(--on-surface); margin-bottom:8px;">';
          html += '<strong>' + translateText('Final Verdict:') + '</strong> ' + translateText(consensusData.disease) + ' (' + consensusData.confidence.toFixed(1) + '% ' + translateText('Confidence') + ')';
          html += '</div>';
          html += '<div style="font-size:13px; color:var(--on-surface-variant); line-height:1.5;">' + consensusData.note + '</div>';
          html += '</div>';
        }

        // Environmental Context Alert
        if (envContext && envContext.severity !== 'low') {
          const severityColors = { moderate: '#FBBC04', high: '#FF9800', critical: '#EA4335' };
          const severityColor = severityColors[envContext.severity] || '#5f6368';

          html += '<div style="background:' + severityColor + '20; border-left:4px solid ' + severityColor + '; padding:16px; margin:12px 0; border-radius:8px;">';
          html += '<div style="font-weight:600; margin-bottom:8px; color:' + severityColor + '; font-size:15px;">';
          html += '⚠️ Environmental Risk: ' + envContext.severity.toUpperCase() + ' (Score: ' + envContext.severityScore + '/10)</div>';

          if (envContext.riskFactors.length > 0) {
            html += '<div style="margin-bottom:10px;"><strong style="color:var(--on-surface);">Risk Factors:</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px; color:var(--on-surface);">';
            envContext.riskFactors.forEach(r => html += '<li>' + r + '</li>');
            html += '</ul></div>';
          }

          if (envContext.recommendations.length > 0) {
            html += '<div><strong style="color:var(--on-surface);">Immediate Actions:</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px; color:var(--on-surface);">';
            envContext.recommendations.forEach(r => html += '<li>' + r + '</li>');
            html += '</ul></div>';
          }

          html += '</div>';
        }

        // Gemini Recommendation (if available)
        if (geminiRecommendation) {
          html += '<div style="background:rgba(26,115,232,0.1); border-left:3px solid var(--primary); padding:16px; margin:12px 0; border-radius:8px;">';
          html += '<div style="font-weight:600; margin-bottom:12px; color:var(--primary); font-size:15px;">🤖 AI Expert Recommendation</div>';

          // Check if it's an error object
          if (geminiRecommendation.error) {
            html += '<div style="background:#fef7e0; border:1px solid #f9ab00; padding:12px; border-radius:6px; color:#ea8600; font-size:14px;">';
            html += '⚠️ ' + geminiRecommendation.error;
            html += '<br><span style="font-size:12px; color:#5f6368;">Showing results from 4 AI models below.</span>';
            html += '</div>';
          } else if (typeof geminiRecommendation === 'object') {
            // Structured JSON response
            if (geminiRecommendation.disease_explanation) {
              html += '<div style="margin-bottom:10px;"><strong>📋 ' + gl('diseaseExplanation') + '</strong><br>';
              html += '<span style="font-size:13px; line-height:1.6;">' + geminiRecommendation.disease_explanation + '</span></div>';
            }

            if (geminiRecommendation.severity) {
              const severityColors = { mild: '#34a853', moderate: '#fbbc04', severe: '#ea4335' };
              const severityColor = severityColors[geminiRecommendation.severity.toLowerCase()] || '#5f6368';
              html += '<div style="margin-bottom:10px;"><strong>⚠️ ' + gl('severity') + '</strong> ';
              html += '<span style="padding:4px 8px; background:' + severityColor + '20; color:' + severityColor + '; border-radius:4px; font-weight:600; text-transform:uppercase; font-size:12px;">' + geminiRecommendation.severity + '</span></div>';
            }

            if (geminiRecommendation.preventive_measures && geminiRecommendation.preventive_measures.length > 0) {
              html += '<div style="margin-bottom:10px;"><strong>🛡️ ' + gl('preventiveMeasures') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
              geminiRecommendation.preventive_measures.forEach(m => html += '<li>' + m + '</li>');
              html += '</ul></div>';
            }

            if (geminiRecommendation.organic_treatment && geminiRecommendation.organic_treatment.length > 0) {
              html += '<div style="margin-bottom:10px;"><strong>🌿 ' + gl('organicTreatment') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
              geminiRecommendation.organic_treatment.forEach(t => html += '<li>' + t + '</li>');
              html += '</ul></div>';
            }

            if (geminiRecommendation.chemical_treatment && geminiRecommendation.chemical_treatment.length > 0) {
              html += '<div style="margin-bottom:10px;"><strong>⚗️ ' + gl('chemicalTreatment') + '</strong><ul style="margin:4px 0; padding-left:20px; font-size:13px;">';
              geminiRecommendation.chemical_treatment.forEach(t => html += '<li>' + t + '</li>');
              html += '</ul></div>';
            }

            if (geminiRecommendation.risk_of_crop_loss) {
              html += '<div style="margin-bottom:6px;"><strong>📊 ' + gl('riskOfCropLoss') + '</strong><br>';
              html += '<span style="font-size:13px; line-height:1.6; color:#ea4335;">' + geminiRecommendation.risk_of_crop_loss + '</span></div>';
            }
          } else {
            // Fallback for plain text response
            html += '<div style="white-space:pre-wrap; font-size:13px; line-height:1.6;">' + geminiRecommendation + '</div>';
          }

          html += '</div>';
        }

        // Start Result List
        html += '<div class="res-list">';

        results.forEach((r, index) => {
          let conf = 0;
          let disease = 'No detection';
          let rawDisease = null;
          let isHealthy = false;
          let isDisease = false;
          let badgeClass = 'low';
          let badgeText = '';

          if (r.error) {
            badgeClass = 'high';
            badgeText = translateText('Error');
            disease = r.error;
          } else if (r.type === 'detection') {
            if (r.data.predictions && r.data.predictions.length > 0) {
              const top = r.data.predictions.reduce((a, b) => a.confidence > b.confidence ? a : b);
              disease = top.class;
              rawDisease = disease;
              conf = (top.confidence * 100).toFixed(1);

              // Handle numeric class IDs or invalid names
              if (!disease || disease === '' || /^\d+$/.test(disease)) {
                console.warn(r.name + ' returned invalid class:', disease, 'Full prediction:', top);
                disease = translateText('Unknown Disease') + ' (ID: ' + disease + ')';
                badgeClass = 'med';
                badgeText = translateText('Invalid');
                isDisease = true;
              }
              // Check if this is a healthy classification
              else if (disease.toLowerCase().trim() === 'healthy') {
                isHealthy = true;
                badgeClass = 'healthy';
                badgeText = translateText('Healthy');
                disease = translateText('Healthy');
              } else {
                isDisease = true;
                if (conf >= 80) { badgeClass = 'high'; badgeText = translateText('High'); }
                else if (conf >= 50) { badgeClass = 'med'; badgeText = translateText('Medium'); }
                else { badgeClass = 'low'; badgeText = translateText('Low'); }
                disease = translateText(disease);
              }
            } else {
              disease = translateText('Healthy');
              isHealthy = true;
              badgeClass = 'healthy';
              badgeText = translateText('Healthy');
            }
          } else if (r.type === 'classification') {
            if (r.data.top || r.data.predicted_classes) {
              disease = r.data.top || (r.data.predicted_classes && r.data.predicted_classes[0]) || 'Unknown';
              rawDisease = disease;
              conf = ((r.data.confidence || 0) * 100).toFixed(1);

              // Check if this is a healthy classification
              if (disease.toLowerCase().trim() === 'healthy' || disease.toLowerCase().trim() === 'no detection') {
                isHealthy = true;
                badgeClass = 'healthy';
                badgeText = translateText('Healthy');
                disease = translateText('Healthy');
              } else {
                isDisease = true;
                if (conf >= 80) { badgeClass = 'high'; badgeText = translateText('High'); }
                else if (conf >= 50) { badgeClass = 'med'; badgeText = translateText('Medium'); }
                else { badgeClass = 'low'; badgeText = translateText('Low'); }
                disease = translateText(disease);
              }
            } else {
              disease = translateText('Healthy');
              isHealthy = true;
              badgeClass = 'healthy';
              badgeText = translateText('Healthy');
            }
          }

          const remedy = getRemedy(rawDisease || disease);

          // Calculate context-aware severity
          const severityAssessment = assessDiseaseSeverity(disease, conf, envContext);
          const urgencyColors = {
            'immediate': '#EA4335',
            'immediate - remove infected plants': '#B71C1C',
            'within 24-48 hours': '#FF9800',
            'within 24 hours': '#FF9800',
            'within 1 week': '#FBBC04',
            'routine': '#34A853'
          };
          const urgencyColor = urgencyColors[severityAssessment.treatmentUrgency] || '#5f6368';

          const feedbackId = analysisId + '_' + index;

          // CARD START
          html += `<div class="res-card">`;

          // HEADER
          html += `<div class="res-header">`;
          html += `<div class="res-title-group">`;
          html += `<h3 class="res-disease-name">${disease}</h3>`;
          html += `<span class="res-model-name">${r.name}</span>`;
          html += `</div>`;
          html += `<span class="res-badge ${badgeClass}">${badgeText}</span>`;
          html += `</div>`;

          // BODY
          html += `<div class="res-body">`;

          // METRICS
          html += `<div class="res-metrics">`;
          html += `<div class="res-metric"><span class="res-metric-label">${translateText('Confidence')}</span><span class="res-metric-value">${conf ? conf + '%' : 'N/A'}</span></div>`;
          if (isDisease) {
            html += `<div class="res-metric"><span class="res-metric-label">${translateText('Urgency')}</span><span class="res-metric-value" style="color:${urgencyColor}">${translateText(severityAssessment.treatmentUrgency)}</span></div>`;
          }
          html += `</div>`;

          // REMEDY
          if (remedy && remedy !== 'N/A') {
            let formattedRemedy = remedy;
            // Format Organic/Chemical sections if present
            formattedRemedy = formattedRemedy.replace(/(?:🔹 )?(Organic:)/g, '<div class="remedy-block"><span class="remedy-type">🌿 Organic:</span>');
            formattedRemedy = formattedRemedy.replace(/(?:🔹 )?(Chemical:)/g, '</div><div class="remedy-block"><span class="remedy-type">⚗️ Chemical:</span>');

            html += `<div class="res-remedy">`;
            html += `<div class="res-remedy-header"><span class="material-symbols-rounded" style="font-size:16px;">medical_services</span> ${translateText('Recommended Treatment')}</div>`;
            html += `<div class="res-remedy-content">${formattedRemedy}</div>`;
            html += `</div>`;
          }
          html += `</div>`; // End Body

          // FEEDBACK
          html += `<div class="res-feedback">`;
          html += `<span class="res-feedback-text" id="feedback_status_${feedbackId}">${translateText('Was this correct?')}</span>`;
          html += `<div class="res-feedback-actions">`;
          html += `<button class="res-btn-feedback correct" id="correct_${feedbackId}" onclick="handleModelFeedback('${analysisId}', '${r.name}', true, '${feedbackId}')"><span class="material-symbols-rounded" style="font-size:14px;">check</span> ${translateText('Correct')}</button>`;
          html += `<button class="res-btn-feedback wrong" id="wrong_${feedbackId}" onclick="handleModelFeedback('${analysisId}', '${r.name}', false, '${feedbackId}')"><span class="material-symbols-rounded" style="font-size:14px;">close</span> ${translateText('Wrong')}</button>`;
          html += `</div>`;
          html += `</div>`;

          html += `</div>`; // End Card
        });

        html += '</div>'; // End List
        html += '<p style="color: var(--on-surface-variant); font-size: 12px; margin-top: 16px; text-align: center;">⚠️ Remedies are general guidelines. Consult agricultural expert for specific cases.</p>';

        res.innerHTML = html;

        renderCtx(['Visual-only analysis. Sensors removed.']);
      }

      async function runAnalysis(withSensors) {
        const btn = withSensors ? document.getElementById('fullBtn') : document.getElementById('visualBtn');
        if (!btn) {
          console.error('Button not found:', withSensors ? 'fullBtn' : 'visualBtn');
          return;
        }
        btn.disabled = true;
        const origText = btn.textContent;
        btn.textContent = translateText('Analyzing...');
        showAnal();

        // Pause stream to free ESP32 resources
        const wasStreaming = streamActive;
        if (wasStreaming) {
          console.log('Stopping stream before capture...');
          toggleStream();
          console.log('Waiting 2 seconds for ESP32 camera to be released...');
          await new Promise(resolve => setTimeout(resolve, 2000)); // Wait longer for stream to fully stop
          console.log('Stream stopped, ready to capture');
        }

        try {
          console.log('Step 1: Triggering capture...');
          console.log('Capture URL:', api('/capture'));
          const captureResp = await fetchWithTimeout(api('/capture'), {}, 30000);
          console.log('Capture response:', captureResp.status, captureResp.statusText);
          const captureText = await captureResp.text();
          console.log('Capture body:', captureText);
          if (!captureResp.ok) throw Error('Capture failed: ' + captureResp.status + ' ' + captureResp.statusText + ' - ' + captureText);

          // Sensors removed; proceed with visual-only capture
          const s = null;

          console.log('Step 3: Fetching captured image...');
          console.log('Image URL:', api('/capture.jpg'));
          const imgR = await fetchWithTimeout(api('/capture.jpg'), {}, 20000);
          console.log('Image response:', imgR.status, imgR.statusText);
          if (!imgR.ok) throw Error('Image HTTP ' + imgR.status);

          console.log('Step 4: Converting to blob...');
          const blob = await imgR.blob();
          console.log('Blob size:', blob.size, 'bytes');

          const reader = new FileReader();
          reader.onloadend = async function () {
            console.log('Step 5: Converting to base64...');
            const b64 = reader.result.split(',')[1];
            console.log('Base64 length:', b64.length);

            // Get filtered models based on selected plant
            const activeModels = getActiveModels();
            console.log('Step 6: Running ' + activeModels.length + ' models for ' + selectedPlantType + '...');
            console.log('Active models:', activeModels.map(m => m.name));

            // Run active models simultaneously
            const modelPromises = activeModels.map(model => infer(b64, model));

            try {
              const results = await Promise.all(modelPromises);
              console.log('All models completed:', results);

              const consensusData = calculateConsensus(results);

              // Skip legacy Gemini API call
              geminiRecommendation = null;

              // Show results (images are not stored or displayed)
              showMultiModelResults(results, s, consensusData);

              // Trigger Firebase AI verification if enabled (pass all model results)
              if (aiAnalysisEnabled && aiEnabled) {
                triggerAIAnalysis(results, b64, s);
              }
            } catch (e) {
              console.error('Multi-model error:', e);
              document.getElementById('res').innerHTML = '<div class="rc"><div class="t">API error<span class="badge warn">Retry</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">' + e.message + '</p></div>';
              renderCtx(ctxNotes(s));
            } finally {
              btn.disabled = false;
              btn.textContent = origText;
              // Resume stream if it was active
              if (wasStreaming && !streamActive) {
                setTimeout(() => toggleStream(), 500);
              } else if (streamActive) {
                // Refresh stream to recover from capture interruption
                const streamImg = document.getElementById('str');
                streamImg.src = api('/stream') + '?t=' + Date.now();
              }
            }
          };
          reader.readAsDataURL(blob);
        } catch (e) {
          console.error('Capture error:', e);
          document.getElementById('res').innerHTML = '<div class="rc"><div class="t">Failed<span class="badge err">Error</span></div><p style="color: var(--on-surface-variant); font-size: 14px;">' + e.message + '</p></div>';
          renderCtx(['Capture failed']);
          btn.disabled = false;
          btn.textContent = origText;
          // Resume stream if it was active
          if (wasStreaming && !streamActive) {
            setTimeout(() => toggleStream(), 500);
          } else if (streamActive) {
            // Refresh stream to recover from capture interruption
            const streamImg = document.getElementById('str');
            streamImg.src = api('/stream') + '?t=' + Date.now();
          }
        }
      }

      function analyze() {
        // Full/sensor-based analysis removed — run visual-only analysis
        runAnalysis(false);
      }

      function visualOnly() {
        runAnalysis(false);
      }

      // Sensors removed — no automatic polling (visual-only mode)

      // Load analytics on page load (async from Firebase)
      (async function initializeAnalytics() {
        await loadAnalytics();
        // updateAnalyticsDashboard is now called inside loadAnalytics after data loads
      })();

      // Display active models on page load
      displayActiveModels();

      // Initialize plant selector on page load
      initPlantSelector();



      // Auto-load saved IP or use default, then auto-connect
      window.addEventListener('DOMContentLoaded', function () {


        // Restore last known daily usage from localStorage immediately (before Firebase loads)
        try {
          const lastUsage = localStorage.getItem('lastDailyUsage');
          const lastTime = localStorage.getItem('lastDailyUsageTime');
          if (lastUsage && lastTime) {
            const age = Date.now() - parseInt(lastTime);
            // Only restore if less than 24 hours old (otherwise it's from a previous day)
            if (age < 86400000) {
              const displayEl = document.getElementById('flowVolumeDisplay');
              if (displayEl) {
                const vol = Math.round(parseFloat(lastUsage) * 1000);
                displayEl.textContent = `Rate=0.0000 L/min, Vol=${vol} mL`;
                console.log('💧 Restored daily usage from localStorage: ' + lastUsage + ' L (' + vol + ' mL)');
              }
            }
          }
        } catch (e) { /* ignore */ }

        // Initialize pump card as disabled (until ESP connects)
        const pumpBtn = document.getElementById('pumpBtn');
        const pumpCard = document.getElementById('pumpCard');
        if (pumpBtn) pumpBtn.disabled = true;
        if (pumpCard) {
          pumpCard.style.opacity = '0.6';
          pumpCard.style.pointerEvents = 'none';
        }

        // Initialize scheduler
        initPumpScheduler();

        const savedIP = localStorage.getItem('esp32_ip');

        // Auto-migrate old 192.168.1.33 IP to new 10.180.248.33
        // This migration is disabled by default to preserve direct-access AP IPs (e.g. ESP32 default)
        if (ALLOW_AUTO_IP_MIGRATION && savedIP && savedIP.includes('192.168.1.33')) {
          localStorage.setItem('esp32_ip', 'http://10.180.248.33');
          log.info('🔄 Migrated IP from 192.168.1.33 to 10.180.248.33');
        }

        const currentIP = localStorage.getItem('esp32_ip') || 'http://10.180.248.33';
        const ipOnly = currentIP.replace('http://', '').replace('https://', '');
        document.getElementById('ipInput').value = ipOnly;

        // Ensure BASE_URL is set
        BASE_URL = currentIP;

        // Auto-connect after 500ms delay
        setTimeout(() => {
          const ipValue = document.getElementById('ipInput').value;
          if (ipValue) {
            log.info('Auto-connecting to:', ipValue);
            setIP();
          }
        }, 500);

        // Load from Firebase after local data (if Firebase is configured)
        // Wait for Firebase to be ready before trying to load
        if (firebaseReadyPromise) {
          firebaseReadyPromise.then(() => {
            if (firebaseReady && firebaseEnabled) {
              setTimeout(() => {
                console.log('Auto-loading from Firebase...');
                loadFromFirebase(false).catch(err => {
                  console.log('Auto-load from Firebase skipped:', err.message);
                });
                // Load historical sensor data
                loadSensorData().catch(err => console.log('Sensor history load skipped:', err.message));
              }, 500);
            }
          }).catch(err => {
            console.log('Firebase not available for auto-load');
          });
        }
      });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.js" type="text/javascript"></script>
    <!-- language.js removed (not provided). If you need localization, add language.js back into the web root. -->
    <script>
      // ========== MQTT Configuration ==========
      const mqtt_broker = 'broker.emqx.io';
      // Use secure websocket (WSS) when page is served over HTTPS to avoid Mixed Content
      const pageIsSecure = location.protocol === 'https:';
      const mqtt_port = pageIsSecure ? 8084 : 8083; // 8084 => wss, 8083 => ws
      const mqtt_path = '/mqtt';
      const mqtt_use_ssl = pageIsSecure;
      const mqtt_client_id = 'WebAppClient_' + Math.random().toString(16).substr(2, 8);
      const sensor_topic = 'esp32/cam/sensors';
      const command_topic = 'esp32/cam/command';

      // Irrigation Control Topics (Device-Side Timer Architecture)
      // Mobile app sends commands → MQTT (retained) → ESP32 executes locally
      // ESP32 continues timer operation even if app is killed or phone is off
      const TOPIC_SCHEDULE = 'irrigation_arnab/pump/schedule';
      const TOPIC_MANUAL = 'irrigation_arnab/pump/manual';
      const TOPIC_STATUS = 'irrigation_arnab/pump/status';
      const TOPIC_SENSORS = 'irrigation_arnab/sensors/data';
      const TOPIC_ALARM = 'irrigation_arnab/alarm/status';  // Synchronized alarm across devices

      // ========== Sensor Data Storage ==========
      let sensorData = {
        temperature: [],
        humidity: [],
        moisture: [],
        soilTemperature: [],
        tds: [],
        rain: [],
        motion: [],  // PIR motion sensor events
        charts: {
          temperature: null,
          humidity: null,
          moisture: null,
          soilTemperature: null,
          tds: null,
          rain: null,
          tds: null,
          rain: null,
          motion: null,
          light: null,
          water: null
        }
      };
      let currentSensorFilter = '1d'; // Default filter: 1 day

      // Load sensor data from Firebase on startup
      async function loadSensorData() {
        // Wait for Firebase to be ready if it's initializing
        if (firebaseReadyPromise) {
          try { await firebaseReadyPromise; } catch (e) { /* ignore */ }
        }

        if (!firebaseReady || !firebaseEnabled || !db) {
          console.log('⚠️ Firebase not available for sensor data');
          return;
        }

        try {
          const snapshot = await db.collection('sensorData').orderBy('timestamp', 'asc').get();
          sensorData.temperature = [];
          sensorData.humidity = [];
          sensorData.moisture = [];
          sensorData.soilTemperature = [];

          snapshot.forEach(doc => {
            const data = doc.data();
            if (data.temperature !== undefined) {
              sensorData.temperature.push({
                value: data.temperature,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.humidity !== undefined) {
              sensorData.humidity.push({
                value: data.humidity,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.moisture !== undefined) {
              sensorData.moisture.push({
                value: data.moisture,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.soilTemperature !== undefined) {
              sensorData.soilTemperature.push({
                value: data.soilTemperature,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.tds !== undefined) {
              if (!sensorData.tds) sensorData.tds = [];
              sensorData.tds.push({
                value: data.tds,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.light !== undefined) {
              if (!sensorData.light) sensorData.light = [];
              sensorData.light.push({
                value: data.light,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.today_vol !== undefined) {
              if (!sensorData.water) sensorData.water = [];
              sensorData.water.push({
                value: data.today_vol,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
            if (data.rain !== undefined) {
              if (!sensorData.rain) sensorData.rain = [];
              sensorData.rain.push({
                value: data.rain,
                timestamp: data.timestamp,
                id: doc.id
              });
            }
          });

          console.log(`📊 Loaded ${sensorData.temperature.length} sensor readings from Firebase`);

          // Restore last known daily water usage to UI
          if (sensorData.water && sensorData.water.length > 0) {
            const latestWater = sensorData.water[sensorData.water.length - 1];
            const displayEl = document.getElementById('flowVolumeDisplay');
            if (displayEl && latestWater.value !== undefined) {
              const vol = Math.round(parseFloat(latestWater.value) * 1000);
              const currentText = displayEl.textContent;
              const rateMatch = currentText.match(/Rate=([\d.]+)/);
              const rate = rateMatch ? rateMatch[1] : '0.0000';
              displayEl.textContent = `Rate=${rate} L/min, Vol=${vol} mL`;
              console.log('💧 Restored daily usage: ' + latestWater.value + ' L (' + vol + ' mL)');
            }
          }

          updateSensorCharts();
        } catch (error) {
          console.error('Error loading sensor data:', error);
        }
      }

      // Save sensor reading to Firebase
      // Save sensor reading (Local + Firebase)
      async function saveSensorReading(data) {
        const timestamp = Date.now();
        const temperature = data.temp;
        const humidity = data.hum;
        const moisture = data.moisture;
        const soilTemperature = data.soil_temp;
        const tds = data.tds;
        const rain = data.rain;
        const motion = data.motion;
        const light = data.light;
        const flow = data.flow;         // Flow Rate
        const water = data.today_vol;   // Daily Volume

        // 1. Update local arrays (always)
        if (temperature !== undefined) sensorData.temperature.push({ value: temperature, timestamp: timestamp });
        if (humidity !== undefined) sensorData.humidity.push({ value: humidity, timestamp: timestamp });
        if (moisture !== undefined) sensorData.moisture.push({ value: moisture, timestamp: timestamp });
        if (soilTemperature !== undefined) sensorData.soilTemperature.push({ value: soilTemperature, timestamp: timestamp });
        if (tds !== undefined) {
          if (!sensorData.tds) sensorData.tds = [];
          sensorData.tds.push({ value: tds, timestamp: timestamp });
        }
        if (water !== undefined) {
          if (!sensorData.water) sensorData.water = [];
          sensorData.water.push({ value: water, timestamp: timestamp });
          console.log('💧 Water added to local array:', water, 'L, Total records:', sensorData.water.length);
        }
        if (rain !== undefined) {
          if (!sensorData.rain) sensorData.rain = [];
          sensorData.rain.push({ value: rain, timestamp: timestamp });
        }
        if (motion !== undefined) {
          if (!sensorData.motion) sensorData.motion = [];
          sensorData.motion.push({ value: motion, timestamp: timestamp });
        }
        if (light !== undefined) {
          if (!sensorData.light) sensorData.light = [];
          sensorData.light.push({ value: light, timestamp: timestamp });
        }

        // 2. Update charts immediately
        try {
          updateSensorCharts();
        } catch (e) {
          console.error('Error updating charts:', e);
        }

        // 3. Save to Firebase (if available)
        if (firebaseReady && firebaseEnabled && db) {
          try {
            const fbData = {
              timestamp: timestamp,
              date: new Date(timestamp).toISOString()
            };

            if (temperature !== undefined) fbData.temperature = temperature;
            if (humidity !== undefined) fbData.humidity = humidity;
            if (moisture !== undefined) fbData.moisture = moisture;
            if (soilTemperature !== undefined) fbData.soilTemperature = soilTemperature;
            if (tds !== undefined) fbData.tds = tds;
            if (rain !== undefined) fbData.rain = rain;
            if (motion !== undefined) fbData.motion = motion;
            if (light !== undefined) fbData.light = light;
            if (flow !== undefined) fbData.flow = flow;
            if (water !== undefined) fbData.today_vol = water;

            await db.collection('sensorData').add(fbData);

            if (water !== undefined) {
              console.log('✅ Water data saved to Firebase:', water, 'L at', new Date(timestamp).toLocaleTimeString());
            }
          } catch (error) {
            console.error('Error saving sensor data to Firebase:', error);
          }
        }
      }

      // ========== SECURITY SETTINGS MANAGEMENT ==========
      async function saveSecuritySettings() {
        if (!firebaseReady || !firebaseEnabled || !db) return;

        try {
          const settings = {
            motionAlertsEnabled: document.getElementById('motionAlertsToggle')?.checked || false,
            eventLoggingEnabled: document.getElementById('eventLoggingToggle')?.checked !== false,
            alarmDuration: parseInt(document.getElementById('alarmDurationSelect')?.value || '0'),
            lastUpdated: Date.now()
          };

          await db.collection('securitySettings').doc('config').set(settings);
          console.log('✅ Security settings saved');
        } catch (error) {
          console.error('Error saving security settings:', error);
        }
      }

      async function loadSecuritySettings() {
        if (!firebaseReady || !firebaseEnabled || !db) return;

        try {
          const doc = await db.collection('securitySettings').doc('config').get();
          if (doc.exists) {
            const settings = doc.data();
            if (document.getElementById('motionAlertsToggle')) {
              document.getElementById('motionAlertsToggle').checked = settings.motionAlertsEnabled;
            }
            if (document.getElementById('eventLoggingToggle')) {
              document.getElementById('eventLoggingToggle').checked = settings.eventLoggingEnabled;
            }
            if (document.getElementById('alarmDurationSelect')) {
              document.getElementById('alarmDurationSelect').value = settings.alarmDuration || '0';
            }
            console.log('✅ Security settings loaded:', settings);
          }
        } catch (error) {
          console.error('Error loading security settings:', error);
        }
      }

      // ========== MOTION EVENT LOGGING ==========
      let motionEvents = [];
      let todayMotionCount = 0;
      let totalMotionCount = 0;

      async function addMotionEvent(timestamp) {
        const eventLoggingEnabled = document.getElementById('eventLoggingToggle')?.checked;
        if (eventLoggingEnabled === false) return;

        const event = {
          timestamp: timestamp,
          date: new Date(timestamp).toISOString(),
          timeString: new Date(timestamp).toLocaleTimeString()
        };

        motionEvents.unshift(event);
        if (motionEvents.length > 50) motionEvents.pop();

        updateMotionStatistics();
        updateMotionTimeline();

        if (firebaseReady && firebaseEnabled && db) {
          try {
            await db.collection('motionEvents').add(event);
            console.log('📍 Motion event logged');
          } catch (error) {
            console.error('Error logging motion event:', error);
          }
        }
      }

      function updateMotionStatistics() {
        const today = new Date().setHours(0, 0, 0, 0);
        todayMotionCount = motionEvents.filter(e => e.timestamp >= today).length;
        totalMotionCount = motionEvents.length;

        const todayEl = document.getElementById('todayMotionEvents');
        const totalEl = document.getElementById('totalMotionEvents');
        const countEl = document.getElementById('motionEventCount');

        if (todayEl) todayEl.textContent = todayMotionCount;
        if (totalEl) totalEl.textContent = totalMotionCount;
        if (countEl) countEl.textContent = `${todayMotionCount} Today`;
      }

      function updateMotionTimeline() {
        const listEl = document.getElementById('motionEventsList');
        if (!listEl) return;

        if (motionEvents.length === 0) {
          listEl.innerHTML = `
          <div style="text-align: center; padding: 32px; color: var(--on-surface-variant);">
            <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.3; display: block; margin-bottom: 8px;">event_note</span>
            <div style="font-size: 14px;">No motion events recorded yet</div>
            <div style="font-size: 12px; margin-top: 4px; opacity: 0.7;">Events will appear here when motion is detected</div>
          </div>
        `;
          return;
        }

        listEl.innerHTML = motionEvents.slice(0, 10).map(event => `
        <div style="display: flex; align-items: center; gap: 12px; padding: 12px; background: var(--surface-container-highest); border-radius: 8px; margin-bottom: 8px;">
          <span class="material-symbols-rounded" style="color: var(--error); font-size: 20px;">motion_sensor_alert</span>
          <div style="flex: 1;">
            <div style="font-size: 14px; font-weight: 500; color: var(--on-surface);">Motion Detected</div>
            <div style="font-size: 12px; color: var(--on-surface-variant);">${event.timeString}</div>
          </div>
          <div style="font-size: 11px; color: var(--on-surface-variant);">${getTimeAgo(event.timestamp)}</div>
        </div>
      `).join('');
      }

      function getTimeAgo(timestamp) {
        const seconds = Math.floor((Date.now() - timestamp) / 1000);
        if (seconds < 60) return `${seconds}s ago`;
        const minutes = Math.floor(seconds / 60);
        if (minutes < 60) return `${minutes}m ago`;
        const hours = Math.floor(minutes / 60);
        if (hours < 24) return `${hours}h ago`;
        return `${Math.floor(hours / 24)}d ago`;
      }

      async function loadMotionEvents() {
        if (!firebaseReady || !firebaseEnabled || !db) return;

        try {
          const snapshot = await db.collection('motionEvents')
            .orderBy('timestamp', 'desc')
            .limit(50)
            .get();

          motionEvents = snapshot.docs.map(doc => doc.data());
          updateMotionStatistics();
          updateMotionTimeline();
          console.log(`📊 Loaded ${motionEvents.length} motion events`);
        } catch (error) {
          console.error('Error loading motion events:', error);
        }
      }

      // ========== MOTION ALERT NOTIFICATIONS ==========
      let lastNotificationTime = 0;
      const NOTIFICATION_COOLDOWN = 10000; // 10 seconds between notifications

      async function sendMotionAlert() {
        // Prevent notification spam (max 1 per 10 seconds)
        const now = Date.now();
        if (now - lastNotificationTime < NOTIFICATION_COOLDOWN) {
          return;
        }
        lastNotificationTime = now;

        // Show toast notification
        showToast('🚨 Motion Detected! Intrusion alert.', 'error');

        // Request browser notification permission if not granted
        if ('Notification' in window && Notification.permission === 'default') {
          await Notification.requestPermission();
        }

        // Send browser notification if permission granted
        if ('Notification' in window && Notification.permission === 'granted') {
          const notification = new Notification('🚨 Security Alert', {
            body: 'Motion detected on your farm! Check the Security tab for details.',
            icon: 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/security/default/48px.svg',
            badge: 'https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/sensors/default/48px.svg',
            tag: 'motion-alert',
            requireInteraction: true,
            vibrate: [200, 100, 200]
          });

          notification.onclick = function () {
            window.focus();
            // Switch to Security tab
            showTab('securityTab');
            notification.close();
          };
        }

        console.log('🔔 Motion alert sent');
      }

      // ========== ALARM SYSTEM ==========
      let alarmAudio = null;
      let alarmActive = false;

      function startAlarm(fromRemote = false) {
        if (alarmActive) return; // Already active
        alarmActive = true;

        // Publish alarm state to MQTT (unless triggered from remote)
        if (!fromRemote && client && client.isConnected()) {
          const payload = JSON.stringify({
            status: 'ACTIVE',
            timestamp: Date.now(),
            time: new Date().toLocaleTimeString()
          });
          const message = new Paho.MQTT.Message(payload);
          message.destinationName = TOPIC_ALARM;
          message.retained = false;
          client.send(message);
          console.log('📢 Alarm broadcast to all devices');
        }

        // Show alarm banner
        const alarmBanner = document.getElementById('alarmBanner');
        if (alarmBanner) {
          alarmBanner.style.display = 'block';
          const alarmTime = document.getElementById('alarmTime');
          if (alarmTime) {
            alarmTime.textContent = 'Alert triggered at ' + new Date().toLocaleTimeString();
          }
        }

        // Auto-Stop Timer Logic
        const durationSelect = document.getElementById('alarmDurationSelect');
        const duration = durationSelect ? parseInt(durationSelect.value) : 0;

        if (duration > 0) {
          if (window.alarmTimeout) clearTimeout(window.alarmTimeout);
          window.alarmTimeout = setTimeout(() => {
            console.log(`⏰ Alarm auto-stopped after ${duration}s`);
            stopAlarm();
          }, duration * 1000);
        }

        // Create and play alarm sound (using Web Audio API)
        try {
          if (!window.audioCtx) {
            window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }

          // Attempt to resume if suspended (requires user interaction previously)
          if (window.audioCtx.state === 'suspended') {
            window.audioCtx.resume().catch(e => console.log('Audio resume failed:', e));
          }

          function playBeep() {
            if (!alarmActive || !window.audioCtx) return;

            const oscillator = window.audioCtx.createOscillator();
            const gainNode = window.audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(window.audioCtx.destination);

            oscillator.frequency.value = 800; // 800 Hz beep
            oscillator.type = 'square';

            gainNode.gain.setValueAtTime(0.3, window.audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, window.audioCtx.currentTime + 0.5);

            oscillator.start(window.audioCtx.currentTime);
            oscillator.stop(window.audioCtx.currentTime + 0.5);

            // Repeat beep every second while alarm is active
            if (alarmActive) {
              window.alarmTimeoutBeep = setTimeout(playBeep, 1000);
            }
          }

          playBeep();
        } catch (error) {
          console.error('Error starting alarm sound:', error);
        }

        console.log('🚨 Alarm started');
      }

      function stopAlarm(fromRemote = false) {
        if (window.alarmTimeout) {
          clearTimeout(window.alarmTimeout);
          window.alarmTimeout = null;
        }
        if (window.alarmTimeoutBeep) {
          clearTimeout(window.alarmTimeoutBeep);
          window.alarmTimeoutBeep = null;
        }
        console.log(`🔕 stopAlarm called, fromRemote=${fromRemote}, alarmActive=${alarmActive}`);
        alarmActive = false;

        // Publish stop to MQTT (unless triggered from remote)
        if (!fromRemote && client && client.isConnected()) {
          const payload = JSON.stringify({
            status: 'STOPPED',
            timestamp: Date.now()
          });
          const message = new Paho.MQTT.Message(payload);
          message.destinationName = TOPIC_ALARM;
          message.retained = false;
          client.send(message);
          console.log('📢 Alarm stop broadcast to all devices via MQTT:', TOPIC_ALARM);
        } else {
          console.log(`⚠️ MQTT not sent: fromRemote=${fromRemote}, client=${!!client}, isConnected=${client?.isConnected()}`);
        }

        // Hide alarm banner
        const alarmBanner = document.getElementById('alarmBanner');
        if (alarmBanner) {
          alarmBanner.style.display = 'none';
        }

        showToast('Alarm stopped', 'success');
        console.log('🔕 Alarm stopped');
      }

      // Filter sensor data based on timeline
      function filterSensorData(data, filter) {
        const now = Date.now();
        let cutoff = 0;

        switch (filter) {
          case '1d':
            cutoff = now - (24 * 60 * 60 * 1000); // 1 day
            break;
          case '1w':
            cutoff = now - (7 * 24 * 60 * 60 * 1000); // 1 week
            break;
          case '1m':
            cutoff = now - (30 * 24 * 60 * 60 * 1000); // 1 month
            break;
          case '1y':
            cutoff = now - (365 * 24 * 60 * 60 * 1000); // 1 year
            break;
          case 'all':
          default:
            return data; // Return all data
        }

        // Convert item timestamp to milliseconds for comparison
        return data.filter(item => {
          let ts = item.timestamp;
          // Handle ISO string timestamps
          if (typeof ts === 'string') {
            ts = new Date(ts).getTime();
          }
          // Handle Firestore Timestamp objects
          if (ts && typeof ts.toMillis === 'function') {
            ts = ts.toMillis();
          }
          return ts >= cutoff;
        });
      }

      // Update sensor timeline filter
      function filterSensorTimeline(filter) {
        currentSensorFilter = filter;

        // Update active button
        document.querySelectorAll('[data-filter]').forEach(btn => {
          if (btn.getAttribute('data-filter') === filter) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });

        updateSensorCharts();
      }

      // Format chart labels for cleaner X-axis
      function formatChartLabel(timestamp, filter) {
        const date = new Date(timestamp);
        switch (filter) {
          case '1d': return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
          case '1w': return date.toLocaleDateString([], { weekday: 'long' }); // Full Weekday, No Time
          case '1m': return date.toLocaleDateString([], { month: 'short', day: 'numeric' }); // Date Only, No Time
          case '1y': return date.toLocaleDateString([], { month: 'short', year: 'numeric' }); // Month Year, No Time
          default: return date.toLocaleDateString([], { month: 'short', day: 'numeric' }); // Default Date Only
        }
      }

      // Update sensor charts
      function updateSensorCharts() {
        updateTemperatureChart();
        updateHumidityChart();
        updateMoistureChart();
        updateSoilTemperatureChart();
        updateTdsChart();
        updateLightChart();
        updateWaterChart();
      }



      // Temperature Chart
      function updateTemperatureChart() {
        const canvas = document.getElementById('temperatureChart');
        if (!canvas) return;

        // Filter data based on current timeline
        const filteredData = filterSensorData(sensorData.temperature, currentSensorFilter);

        if (filteredData.length === 0) {
          // Show empty state
          if (sensorData.charts.temperature) {
            sensorData.charts.temperature.destroy();
            sensorData.charts.temperature = null;
          }
          return;
        }

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        const values = filteredData.map(item => item.value);

        // Destroy existing chart
        if (sensorData.charts.temperature) {
          sensorData.charts.temperature.destroy();
        }

        // Create new chart
        sensorData.charts.temperature = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Temperature (°C)',
              data: values,
              borderColor: '#EA4335',
              backgroundColor: 'rgba(234, 67, 53, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false
              }
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              }
            }
          }
        });
      }

      // Humidity Chart
      function updateHumidityChart() {
        const canvas = document.getElementById('humidityChart');
        if (!canvas) return;

        // Filter data based on current timeline
        const filteredData = filterSensorData(sensorData.humidity, currentSensorFilter);

        if (filteredData.length === 0) {
          // Show empty state
          if (sensorData.charts.humidity) {
            sensorData.charts.humidity.destroy();
            sensorData.charts.humidity = null;
          }
          return;
        }

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        const values = filteredData.map(item => item.value);

        // Destroy existing chart
        if (sensorData.charts.humidity) {
          sensorData.charts.humidity.destroy();
        }

        // Create new chart
        sensorData.charts.humidity = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Humidity (%)',
              data: values,
              borderColor: '#4285F4',
              backgroundColor: 'rgba(66, 133, 244, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false
              }
            },
            scales: {
              y: {
                beginAtZero: false,
                max: 100,
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              }
            }
          }
        });
      }

      // Moisture Chart
      function updateMoistureChart() {
        const canvas = document.getElementById('moistureChart');
        if (!canvas) return;

        // Filter data based on current timeline
        const filteredData = filterSensorData(sensorData.moisture, currentSensorFilter);

        if (filteredData.length === 0) {
          console.log(`⚠️ Moisture chart: No data after filtering (filter=${currentSensorFilter}, raw length=${sensorData.moisture.length})`);
          // Show empty state
          if (sensorData.charts.moisture) {
            sensorData.charts.moisture.destroy();
            sensorData.charts.moisture = null;
          }
          return;
        }
        console.log(`✅ Moisture chart updating with ${filteredData.length} points, last value: ${filteredData[filteredData.length - 1]?.value}`);

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        const values = filteredData.map(item => item.value);

        // Destroy existing chart
        if (sensorData.charts.moisture) {
          sensorData.charts.moisture.destroy();
        }

        // Create new chart
        sensorData.charts.moisture = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Moisture (%)',
              data: values,
              borderColor: '#34A853',
              backgroundColor: 'rgba(52, 168, 83, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              }
            }
          }
        });
      }

      // Soil Temperature Chart
      function updateSoilTemperatureChart() {
        const canvas = document.getElementById('soilTemperatureChart');
        if (!canvas) return;

        // Filter data based on current timeline
        const filteredData = filterSensorData(sensorData.soilTemperature, currentSensorFilter);

        if (filteredData.length === 0) {
          // Show empty state
          if (sensorData.charts.soilTemperature) {
            sensorData.charts.soilTemperature.destroy();
            sensorData.charts.soilTemperature = null;
          }
          return;
        }

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        const values = filteredData.map(item => item.value);

        // Destroy existing chart
        if (sensorData.charts.soilTemperature) {
          sensorData.charts.soilTemperature.destroy();
        }

        // Create new chart
        sensorData.charts.soilTemperature = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Soil Temperature (°C)',
              data: values,
              borderColor: '#8D6E63', // Earthy brown
              backgroundColor: 'rgba(141, 110, 99, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false
              }
            },
            scales: {
              y: {
                beginAtZero: false,
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              }
            }
          }
        });
      }

      // Soil Quality (TDS) Chart
      function updateTdsChart() {
        const canvas = document.getElementById('tdsChart');
        if (!canvas) return;

        // Filter data based on current timeline
        // Check if sensorData.tds exists in case of old data structure
        if (!sensorData.tds) sensorData.tds = [];
        const filteredData = filterSensorData(sensorData.tds, currentSensorFilter);

        if (filteredData.length === 0) {
          // Show empty state
          if (sensorData.charts.tds) {
            sensorData.charts.tds.destroy();
            sensorData.charts.tds = null;
          }
          return;
        }

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        const values = filteredData.map(item => item.value);

        // Destroy existing chart
        if (sensorData.charts.tds) {
          sensorData.charts.tds.destroy();
        }

        // Create new chart
        sensorData.charts.tds = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Soil Quality (PPM)',
              data: values,
              borderColor: '#9C27B0', // Purple
              backgroundColor: 'rgba(156, 39, 176, 0.1)',
              borderWidth: 2,
              fill: true,
              tension: 0.4,
              pointRadius: 3,
              pointHoverRadius: 5
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: true,
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface')
                }
              },
              tooltip: {
                mode: 'index',
                intersect: false
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  maxRotation: 45,
                  minRotation: 45,
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--outline-variant')
                }
              }
            }
          }
        });
      }

      // Light History Chart
      function updateLightChart() {
        const canvas = document.getElementById('lightChart');
        if (!canvas) return;

        // Filter data based on current timeline
        // Check if sensorData.light exists
        if (!sensorData.light) sensorData.light = [];
        const filteredData = filterSensorData(sensorData.light, currentSensorFilter);

        if (filteredData.length === 0) {
          if (sensorData.charts.light) {
            sensorData.charts.light.destroy();
            sensorData.charts.light = null;
          }
          return;
        }

        // Prepare chart data
        const labels = filteredData.map(item => formatChartLabel(item.timestamp, currentSensorFilter));
        // Map: 0(Day)->100, 1(Night)->0
        const plotValues = filteredData.map(item => item.value === 0 ? 100 : 0);

        // Destroy existing chart
        if (sensorData.charts.light) {
          sensorData.charts.light.destroy();
        }

        // Create new chart
        sensorData.charts.light = new Chart(canvas, {
          type: 'line',
          data: {
            labels: labels,
            datasets: [{
              label: 'Light Level',
              data: plotValues,
              borderColor: '#FBC02D',
              backgroundColor: 'rgba(253, 216, 53, 0.2)',
              borderWidth: 2,
              fill: true,
              stepped: true,
              pointRadius: 0,
              pointHoverRadius: 0
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    return context.raw > 50 ? 'Daytime' : 'Nighttime';
                  }
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                max: 110,
                ticks: {
                  callback: function (value) { if (value === 100) return 'Day'; if (value === 0) return 'Night'; return ''; },
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant')
                },
                grid: { color: 'rgba(255, 255, 255, 0.05)' }
              },
              x: {
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  autoSkip: true,
                  maxTicksLimit: window.innerWidth < 600 ? 5 : 8
                },
                grid: { color: 'rgba(255, 255, 255, 0.05)' }
              }
            }
          }
        });
      }

      // Water Usage Chart (Bar Chart of Daily Totals)
      function updateWaterChart() {
        const canvas = document.getElementById('waterChart');
        if (!canvas) return;

        // Use raw water data (cumulative daily volume)
        // We want to find the MAX volume for each day in the range.

        const filteredData = filterSensorData(sensorData.water || [], currentSensorFilter);
        if (filteredData.length === 0) {
          if (sensorData.charts.water) { sensorData.charts.water.destroy(); sensorData.charts.water = null; }
          // Hide stats
          const statsDiv = document.getElementById('waterStats');
          if (statsDiv) statsDiv.style.display = 'none';
          return;
        }

        // Aggregate by Day (Max val per day)
        const dailyMax = {}; // 'YYYY-MM-DD': maxVol
        filteredData.forEach(item => {
          const dateKey = new Date(item.timestamp).toLocaleDateString();
          if (!dailyMax[dateKey] || item.value > dailyMax[dateKey]) {
            dailyMax[dateKey] = item.value;
          }
        });

        const labels = Object.keys(dailyMax);
        const values = Object.values(dailyMax);

        // Calculate statistics
        const totalUsage = values.reduce((sum, val) => sum + val, 0);
        const avgUsage = totalUsage / values.length;
        const peakUsage = Math.max(...values);
        const daysActive = values.length;

        // Update stats display
        const statsDiv = document.getElementById('waterStats');
        if (statsDiv) {
          statsDiv.style.display = 'grid';
          document.getElementById('waterTotalStat').textContent = totalUsage.toFixed(1) + ' L';
          document.getElementById('waterAvgStat').textContent = avgUsage.toFixed(1) + ' L';
          document.getElementById('waterPeakStat').textContent = peakUsage.toFixed(1) + ' L';
          document.getElementById('waterDaysStat').textContent = daysActive;
        }

        if (sensorData.charts.water) sensorData.charts.water.destroy();

        // Create professional gradient
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createLinearGradient(0, 0, 0, 400);
        gradient.addColorStop(0, '#00B4D8'); // Cyan-Blue top
        gradient.addColorStop(1, 'rgba(0, 180, 216, 0.1)'); // Fade to transparent

        sensorData.charts.water = new Chart(canvas, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: [{
              label: 'Water Used',
              data: values,
              backgroundColor: gradient,
              borderColor: '#0077B6', // Darker blue border
              borderWidth: 1,
              borderRadius: 4, // Soft rounded corners
              borderSkipped: false,
              barThickness: 'flex',
              maxBarThickness: 32
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false
            },
            plugins: {
              legend: {
                display: true,
                align: 'end',
                labels: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface'),
                  font: { size: 12, weight: '500' },
                  usePointStyle: true,
                  boxWidth: 8
                }
              },
              tooltip: {
                backgroundColor: 'rgba(28, 28, 30, 0.95)',
                titleColor: '#fff',
                bodyColor: '#e0e0e0',
                borderColor: 'rgba(255,255,255,0.1)',
                borderWidth: 1,
                padding: 10,
                cornerRadius: 8,
                displayColors: false,
                callbacks: {
                  title: (items) => items[0].label,
                  label: (item) => `${item.formattedValue} L (${((item.raw / totalUsage) * 100).toFixed(0)}%)`
                }
              }
            },
            scales: {
              y: {
                beginAtZero: true,
                border: { display: false },
                grid: {
                  color: 'rgba(255, 255, 255, 0.03)',
                  drawTicks: false
                },
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  font: { size: 10 },
                  padding: 8,
                  callback: (value) => value + ' L'
                }
              },
              x: {
                border: { display: false },
                grid: { display: false },
                ticks: {
                  color: getComputedStyle(document.documentElement).getPropertyValue('--on-surface-variant'),
                  font: { size: 11 },
                  maxRotation: 0,
                  autoSkip: true,
                  maxTicksLimit: 7
                }
              }
            },
            animation: {
              duration: 1000,
              easing: 'easeOutQuart'
            }
          }
        });
      }

      let pumpOn = false;
      let autoModeEnabled = false;
      const TOPIC_AUTO = 'irrigation_arnab/pump/auto';

      // Map crop types to raw moisture thresholds
      // Raw Calibration: Dry Air = 1023 (0%), Wet Soil = 400 (100%)
      const CROP_THRESHOLDS = {
        'default': 800,   // ~36% (Legacy)
        'veg': 650,       // ~60%
        'fruit_veg': 710, // ~50%
        'grains': 710,    // ~50%
        'fruits': 805,    // ~35%
        'house': 835      // ~30%
      };


      // Save Auto Mode state to Firebase
      function saveAutoModeState(enabled) {
        if (!db || !auth.currentUser) return;

        const userId = auth.currentUser.uid;
        db.collection('settings').doc('pump_control').set({
          autoModeEnabled: enabled,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          updatedBy: userId
        }, { merge: true })
          .then(() => console.log('✅ Auto Mode state saved:', enabled))
          .catch((error) => console.error('❌ Error saving Auto Mode state:', error));
      }

      // Load Auto Mode state from Firebase
      function loadAutoModeState() {
        if (!db) return;

        db.collection('settings').doc('pump_control').get().then((doc) => {
          if (doc.exists) {
            const data = doc.data();
            if (data.autoModeEnabled !== undefined) {
              console.log('🔄 Loaded Auto Mode state:', data.autoModeEnabled);
              const toggle = document.getElementById('autoModeToggle');
              const profileDiv = document.getElementById('cropProfileDiv');

              if (toggle) {
                toggle.checked = data.autoModeEnabled;
                autoModeEnabled = data.autoModeEnabled;

                // Update UI visibility
                if (profileDiv) profileDiv.style.display = autoModeEnabled ? 'block' : 'none';

                // Sync to ESP32 if connected (ensures device matches saved state)
                // Only send if different from default or if we want to enforce it
                if (client && client.isConnected()) {
                  const profileSelector = document.getElementById('cropProfile');
                  const profile = profileSelector ? profileSelector.value : 'default';
                  const threshold = CROP_THRESHOLDS[profile] || 800;

                  const payload = JSON.stringify({
                    type: "AUTO",
                    enabled: autoModeEnabled,
                    threshold: threshold
                  });
                  publishIrrigationMessage(TOPIC_AUTO, payload, { retained: true });
                }
              }
            }
          }
        }).catch((error) => {
          console.error("Error getting Auto Mode state:", error);
        });
      }

      function toggleAutoMode() {
        const toggle = document.getElementById('autoModeToggle');
        const profileDiv = document.getElementById('cropProfileDiv');
        const newState = toggle.checked;

        // Show/Hide profile selector
        if (profileDiv) profileDiv.style.display = newState ? 'block' : 'none';

        // Get current profile threshold
        const profileSelector = document.getElementById('cropProfile');
        const profile = profileSelector ? profileSelector.value : 'default';
        const threshold = CROP_THRESHOLDS[profile] || 800;

        const payload = JSON.stringify({
          type: "AUTO",
          enabled: newState,
          threshold: threshold
        });

        publishIrrigationMessage(TOPIC_AUTO, payload, { retained: true });

        autoModeEnabled = newState;

        // Save state to Firebase
        saveAutoModeState(newState);
      }

      function updateAutoProfile() {
        if (!autoModeEnabled) return; // Only update if already running

        // Re-trigger toggle logic to send update
        const toggle = document.getElementById('autoModeToggle');
        if (toggle && toggle.checked) {
          toggleAutoMode();
          showToast('Updated moisture profile', 'success');
        }
      }

      let pendingSchedulePayload = null;
      let pendingQuickTimerPayload = null;

      // Client variable will be created by the connect routine below
      let client = null;

      function isMqttConnected() {
        return client && client.isConnected();
      }

      function publishIrrigationMessage(topic, payload, { retained = true, qos = 1, queueKey = null } = {}) {
        if (!isMqttConnected()) {
          console.warn('MQTT not connected - queuing irrigation command:', payload);
          if (queueKey === 'schedule') pendingSchedulePayload = payload;
          if (queueKey === 'quick') pendingQuickTimerPayload = payload;
          showToast('MQTT offline - command queued', 'warn');
          return false;
        }

        const message = new Paho.MQTT.Message(payload);
        message.destinationName = topic;
        message.retained = retained;
        message.qos = qos;
        client.send(message);
        return true;
      }

      function flushPendingIrrigationCommands() {
        if (!isMqttConnected()) return;

        if (pendingQuickTimerPayload) {
          publishIrrigationMessage(TOPIC_SCHEDULE, pendingQuickTimerPayload, { retained: true, qos: 1, queueKey: null });
          pendingQuickTimerPayload = null;
        }

        if (pendingSchedulePayload) {
          publishIrrigationMessage(TOPIC_SCHEDULE, pendingSchedulePayload, { retained: true, qos: 1, queueKey: null });
          pendingSchedulePayload = null;
        }
      }

      // Attempt to connect to an MQTT broker with optional fallback
      function tryConnect(brokerHost, port, path, useSSL, attemptFallback = true) {
        console.log('MQTT connecting to', (useSSL ? 'wss' : 'ws') + '://' + brokerHost + ':' + port + path);

        // (re)create client for this connection attempt
        client = new Paho.MQTT.Client(brokerHost, Number(port), path, mqtt_client_id);
        client.onConnectionLost = onConnectionLost;
        client.onMessageArrived = onMessageArrived;

        client.connect({
          onSuccess: onConnect,
          onFailure: function (err) {
            console.error('MQTT connect failed', err);
            // If this was a WSS attempt and fallback is allowed, try a known public WSS broker
            if (useSSL && attemptFallback) {
              console.log('Attempting fallback WSS broker: broker.emqx.io:8084');
              tryConnect('broker.emqx.io', 8084, '/mqtt', true, false);
            }
          },
          useSSL: useSSL
        });
      }

      // Start initial connect (use WSS on HTTPS pages)
      tryConnect(mqtt_broker, mqtt_port, mqtt_path, mqtt_use_ssl);

      function onConnect() {
        console.log("Connected to MQTT broker");
        client.subscribe(sensor_topic);
        // Subscribe to irrigation sensor data topic
        client.subscribe(TOPIC_SENSORS);
        // Also subscribe to status topic to receive acks from ESP
        client.subscribe('esp32/cam/status');
        // Subscribe to irrigation status (device-side updates)
        client.subscribe(TOPIC_STATUS);
        client.subscribe(TOPIC_ALARM);  // Subscribe for cross-device alarm sync
        console.log('Subscribed to irrigation control topics, sensor data, and alarm');
        document.getElementById('mqttDot').classList.remove('offline');
        flushPendingIrrigationCommands();
        // document.getElementById('mqttStatus').textContent = 'Online';

        // Enable pump controls when MQTT connects (independent of Camera HTTP status)
        const pumpBtn = document.getElementById('pumpBtn');
        const pumpCard = document.getElementById('pumpCard');
        if (pumpBtn) pumpBtn.disabled = false;
        if (pumpCard) {
          pumpCard.style.opacity = '1';
          pumpCard.style.pointerEvents = 'auto';
        }
      }

      function onConnectionLost(responseObject) {
        if (responseObject.errorCode !== 0) {
          console.log("onConnectionLost:" + responseObject.errorMessage);
          const mqttDot = document.getElementById('mqttDot');
          if (mqttDot) mqttDot.classList.add('offline');
          // Maybe try to reconnect here

          // Disable pump controls if MQTT is lost
          const pumpBtn = document.getElementById('pumpBtn');
          const pumpCard = document.getElementById('pumpCard');
          if (pumpBtn) pumpBtn.disabled = true;
          if (pumpCard) {
            pumpCard.style.opacity = '0.6';
            pumpCard.style.pointerEvents = 'none';
          }
        }
      }

      // Update Soil Health Card based on TDS value
      function updateSoilHealthUI(ppm) {
        const healthCard = document.getElementById('soilHealthCard');
        const statusEl = document.getElementById('soilHealthStatus');
        const actionEl = document.getElementById('soilHealthAction');

        if (!healthCard || !statusEl || !actionEl) return;

        let status = 'Unknown';
        let action = '';
        let color = 'var(--on-surface)';
        let bg = 'var(--surface-container-high)';
        let border = 'var(--outline-variant)';

        if (ppm < 200) {
          status = 'Hungry Soil';
          action = 'Add Fertilizer';
          color = 'var(--error)';
          border = 'var(--error)';
          bg = 'rgba(176, 0, 32, 0.05)';
        } else if (ppm >= 200 && ppm < 800) {
          status = 'Optimal';
          action = 'Do Nothing';
          color = 'var(--primary)';
          border = 'var(--primary)';
          bg = 'rgba(0, 100, 0, 0.05)';
        } else if (ppm >= 800 && ppm < 2000) {
          status = 'High Nutrient';
          action = 'Water Only';
          color = '#F9A825'; // Yellow/Orange
          border = '#F9A825';
          bg = 'rgba(249, 168, 37, 0.05)';
        } else if (ppm >= 2000) {
          status = 'Toxic Runoff';
          action = 'FLUSH SOIL'; // Urgent
          color = 'var(--error)';
          border = 'var(--error)';
          bg = 'rgba(176, 0, 32, 0.1)';
        }

        statusEl.textContent = status;
        statusEl.style.color = color;
        actionEl.textContent = action;
        healthCard.style.borderColor = border;
        healthCard.style.backgroundColor = bg;
      }

      function onMessageArrived(message) {
        const payload = message.payloadString;

        // Handle sensor data from irrigation_arnab/sensors/data
        if (message.destinationName === TOPIC_SENSORS) {
          try {
            const data = JSON.parse(payload);
            console.log('📊 Sensor Data:', data);

            if (data.temperature !== undefined && data.humidity !== undefined) {
              let msg = `Sensor Data: ${data.temperature}°C, ${data.humidity}%`;
              if (data.moisture !== undefined) msg += `, ${data.moisture}%`;
              if (data.soilTemperature !== undefined) msg += `, Soil: ${data.soilTemperature}°C`;
              if (data.tds !== undefined) msg += `, TDS: ${Math.round(data.tds)}ppm`;
              if (data.rain !== undefined) msg += `, Rain: ${data.rain}%`;
              showToast(msg, 'success');
            }

            // Update live display in Monitor tab
            if (data.temperature !== undefined) {
              document.getElementById('temperature').innerText = parseFloat(data.temperature).toFixed(1);
            }
            if (data.humidity !== undefined) {
              document.getElementById('humidity').innerText = parseFloat(data.humidity).toFixed(1);
            }
            if (data.moisture !== undefined) {
              // Try both IDs just in case
              let mEl = document.getElementById('soilMoisture');
              if (!mEl) mEl = document.getElementById('moisture');

              if (mEl) mEl.innerText = data.moisture + '%';
            }
            if (data.soilTemperature !== undefined) {
              const stEl = document.getElementById('soilTemperature');
              if (stEl) stEl.innerText = parseFloat(data.soilTemperature).toFixed(1);
            }
            if (data.tds !== undefined) {
              const tdsVal = Math.round(data.tds);
              const el = document.getElementById('tdsValue');
              if (el) el.textContent = tdsVal;
              // Update Soil Health Card
              if (typeof updateSoilHealthUI === 'function') {
                updateSoilHealthUI(tdsVal);
              }
            }
            if (data.rain !== undefined) {
              const rainVal = Math.round(data.rain);
              // Update Rain UI (assuming element exists, if not we'll create it)
              const rainValEl = document.getElementById('rainValue');
              const rainStatusEl = document.getElementById('rainStatus');
              if (rainValEl) rainValEl.textContent = rainVal + '%';
              if (rainStatusEl) {
                // Rain sensor: High=Dry (0%), Low=Wet (100%) - Logic handled in Arduino
                // Arduino sends 0-100% where 100% is wettest
                if (rainVal > 50) {
                  rainStatusEl.textContent = translateText('Runoff Detected');
                  rainStatusEl.style.color = 'var(--primary)';
                } else {
                  rainStatusEl.textContent = translateText('Runoff Not Detected');
                  rainStatusEl.style.color = 'var(--on-surface-variant)';
                }
              }
            }

            // Update Motion Sensor UI
            if (data.motion !== undefined) {
              const motionStatus = document.getElementById('motionStatus');
              const motionIcon = document.getElementById('motionIcon');
              const motionIndicator = document.getElementById('motionIndicator');
              const motionCard = document.getElementById('motionSensorCard');
              const motionStatusBadge = document.getElementById('motionStatusBadge');
              const lastMotionTime = document.getElementById('lastMotionTime');

              if (data.motion === 1) {
                // Motion detected!
                if (motionStatus) motionStatus.textContent = translateText('Motion Detected!');

                // Log event to Firebase
                addMotionEvent(Date.now());

                // Start alarm if Motion Alerts enabled
                const motionAlertsEnabled = document.getElementById('motionAlertsToggle')?.checked;
                if (motionAlertsEnabled) {
                  startAlarm();
                  sendMotionAlert();
                }

                if (motionIcon) {
                  motionIcon.textContent = 'sensors';
                  motionIcon.style.color = 'var(--error)';
                  motionIcon.style.background = 'rgba(234, 67, 53, 0.2)';
                  motionIcon.style.animation = 'pulse 1s infinite';
                }
                if (motionIndicator) {
                  motionIndicator.style.background = 'var(--error)';
                  motionIndicator.style.boxShadow = '0 0 8px var(--error)';
                }
                if (motionCard) {
                  motionCard.style.borderColor = 'var(--error)';
                }
                if (motionStatusBadge) {
                  motionStatusBadge.textContent = translateText('ALERT');
                  motionStatusBadge.style.background = 'rgba(234, 67, 53, 0.2)';
                  motionStatusBadge.style.color = 'var(--error)';
                }
                if (lastMotionTime) {
                  lastMotionTime.textContent = new Date().toLocaleTimeString();
                }
                console.log('🚨 Motion Detected!');
              } else {
                // No motion
                if (motionStatus) motionStatus.textContent = translateText('No Motion Detected');
                if (motionIcon) {
                  motionIcon.textContent = 'shield';
                  motionIcon.style.color = 'var(--success)';
                  motionIcon.style.background = 'rgba(52, 168, 83, 0.2)';
                  motionIcon.style.animation = 'none';
                }
                if (motionIndicator) {
                  motionIndicator.style.background = 'var(--success)';
                  motionIndicator.style.boxShadow = '0 0 0 4px rgba(52, 168, 83, 0.2)';
                }
                if (motionCard) {
                  motionCard.style.borderColor = 'var(--outline-variant)';
                }
                if (motionStatusBadge) {
                  motionStatusBadge.textContent = translateText('SECURE');
                  motionStatusBadge.style.background = 'rgba(52, 168, 83, 0.2)';
                  motionStatusBadge.style.color = 'var(--success)';
                }
              }
            }

            // Update Ultrasonic Sensor UI
            if (data.distance !== undefined) {
              const dist = parseInt(data.distance);
              const distStatus = document.getElementById('distanceStatus');
              const distIcon = document.getElementById('distanceIcon');
              const distIndicator = document.getElementById('distanceIndicator');
              const distCard = document.getElementById('ultrasonicCard');
              const distBar = document.getElementById('distanceBar');

              if (distStatus) distStatus.textContent = dist + translateText(' cm');

              // Update Bar (Max 400cm)
              if (distBar) distBar.style.width = Math.min((dist / 400) * 100, 100) + '%';

              // Alarm Logic (Threshold < 50cm) -> Only trigger if distance > 0 (valid reading)
              if (dist > 0 && dist < 50) {
                // INTRUDER ALERT
                if (distStatus) distStatus.textContent = dist + translateText(' cm') + ' ' + translateText(' (INTRUDER!)');

                // Visual Alarm
                if (distIcon) {
                  distIcon.textContent = 'warning';
                  distIcon.style.color = 'var(--error)';
                  distIcon.style.background = 'rgba(234, 67, 53, 0.2)';
                  distIcon.style.animation = 'pulse 0.5s infinite';
                }
                if (distIndicator) {
                  distIndicator.style.background = 'var(--error)';
                  distIndicator.style.boxShadow = '0 0 8px var(--error)';
                }
                if (distCard) {
                  distCard.style.borderColor = 'var(--error)';
                }

                // Trigger Main Alarm if enabled
                const motionAlertsEnabled = document.getElementById('motionAlertsToggle')?.checked;
                if (motionAlertsEnabled) {
                  startAlarm();
                  // Log specific ultrasonic event (Throttle logging? maybe once per 5s)
                  // For now, rely on startAlarm de-bouncing or add simple throttle
                  const now = Date.now();
                  if (!window.lastDistLog || now - window.lastDistLog > 5000) {
                    addMotionEvent(now, `Intruder detected at ${dist}cm`); // Reusing addMotionEvent to log to same collection
                    window.lastDistLog = now;
                  }
                }
              } else {
                // Clear Status
                if (distIcon) {
                  distIcon.textContent = 'straighten';
                  distIcon.style.color = 'var(--primary)';
                  distIcon.style.background = 'rgba(62, 166, 255, 0.2)';
                  distIcon.style.animation = 'none';
                }
                if (distIndicator) {
                  distIndicator.style.background = 'var(--primary)';
                  distIndicator.style.boxShadow = '0 0 0 4px rgba(62, 166, 255, 0.2)';
                }
                if (distCard) {
                  distCard.style.borderColor = 'var(--outline-variant)';
                }
              }
            }

            // Update Light Sensor UI
            if (data.light !== undefined) {
              const lightVal = parseInt(data.light); // 0=Light, 1=Dark
              const lightStatusEl = document.getElementById('lightStatus');
              const lightIconEl = document.getElementById('lightIcon');
              const lightIconBgEl = document.getElementById('lightIconBg');
              const lightDurationEl = document.getElementById('lightDuration');

              // State tracking for duration
              const now = Date.now();
              let lastState = localStorage.getItem('lastLightState');
              let lastChange = localStorage.getItem('lastLightChangeTime');

              if (lastState === null || parseInt(lastState) !== lightVal) {
                lastState = lightVal;
                lastChange = now;
                localStorage.setItem('lastLightState', lastState);
                localStorage.setItem('lastLightChangeTime', lastChange);
              }

              const diffMs = now - parseInt(lastChange);
              const diffHrs = Math.floor(diffMs / 3600000);
              const diffMins = Math.floor((diffMs % 3600000) / 60000);

              if (lightVal === 1) { // Nighttime
                if (lightStatusEl) lightStatusEl.textContent = translateText('Nighttime');
                if (lightIconEl) { lightIconEl.textContent = 'dark_mode'; lightIconEl.style.color = '#7986cb'; }
                if (lightIconBgEl) lightIconBgEl.style.background = 'rgba(121, 134, 203, 0.2)';
              } else { // Daytime
                if (lightStatusEl) lightStatusEl.textContent = translateText('Daytime');
                if (lightIconEl) { lightIconEl.textContent = 'wb_sunny'; lightIconEl.style.color = 'var(--warning)'; }
                if (lightIconBgEl) lightIconBgEl.style.background = 'rgba(253, 216, 53, 0.2)';
              }
              if (lightDurationEl) lightDurationEl.textContent = `Duration: ${diffHrs}h ${diffMins}m`;
            }

            // Flow/usage UI updates (may arrive without temp/humidity)
            const flowValue = data.flow !== undefined ? data.flow : (data.flow_rate !== undefined ? data.flow_rate : null);
            const volValue = data.today_vol;

            if (flowValue !== null || volValue !== undefined) {
              console.log('💧 Water data received - Flow:', flowValue, 'L/min, Volume:', volValue, 'L');

              const displayEl = document.getElementById('flowVolumeDisplay');
              const flowStatEl = document.getElementById('flowStatus');

              // Get current or default values
              const rate = flowValue !== null ? parseFloat(flowValue).toFixed(4) : '0.0000';
              const vol = volValue !== undefined ? Math.round(parseFloat(volValue) * 1000) : 0;

              if (displayEl) {
                displayEl.textContent = `Rate=${rate} L/min, Vol=${vol} mL`;
              }

              if (flowStatEl && flowValue !== null) {
                if (parseFloat(flowValue) > 0) {
                  flowStatEl.textContent = translateText('Flowing');
                  flowStatEl.style.color = 'var(--success)';
                } else {
                  flowStatEl.textContent = translateText('No Flow');
                  flowStatEl.style.color = 'var(--on-surface-variant)';
                }
              }

              // Persist to localStorage for quick restore on refresh
              if (volValue !== undefined) {
                try {
                  localStorage.setItem('lastDailyUsage', volValue.toString());
                  localStorage.setItem('lastDailyUsageTime', Date.now().toString());
                  console.log('💾 Saved to localStorage:', volValue, 'L');
                } catch (e) { console.error('localStorage error:', e); }
              }
            }

            // Save to Firebase and update charts
            if (
              data.temperature !== undefined ||
              data.tds !== undefined ||
              data.rain !== undefined ||
              data.light !== undefined ||
              data.flow !== undefined ||
              data.flow_rate !== undefined ||
              data.today_vol !== undefined
            ) {
              try {
                saveSensorReading({
                  temp: data.temperature,
                  hum: data.humidity,
                  moisture: data.moisture,
                  soil_temp: data.soilTemperature,
                  tds: data.tds,
                  rain: data.rain,
                  light: data.light,
                  flow: data.flow !== undefined ? data.flow : data.flow_rate,
                  today_vol: data.today_vol
                });
              } catch (e) {
                console.error('❌ saveSensorReading error:', e);
              }
            }

            // Update Arduino status dot (Logic reused from cleanups)
            // We removed the dots, but if we ever decide to re-add logic, it goes here.
            // For now, these ID checks will safely fail if elements are gone.
            const arduinoDot = document.getElementById('arduinoDot');
            const arduinoStatus = document.getElementById('arduinoStatus');
            if (arduinoDot && arduinoStatus) {
              arduinoDot.classList.remove('offline');
              arduinoStatus.innerText = translateText('Connected');
            }

            return;
          } catch (e) {
            console.error('Failed to parse sensor data:', e);
          }
        }

        // Handle alarm synchronization from other devices
        if (message.destinationName === TOPIC_ALARM) {
          try {
            const alarmData = JSON.parse(payload);
            console.log('🔔 Alarm Status Update:', alarmData);

            if (alarmData.status === 'ACTIVE') {
              // Another device triggered the alarm - start it here too
              startAlarm(true);  // fromRemote=true to prevent echo
              showToast('🚨 Alarm triggered from another device!', 'error');
            } else if (alarmData.status === 'STOPPED') {
              // Another device stopped the alarm - stop it here too
              console.log('⏹️ Stopping alarm from remote device');
              stopAlarm(true);  // fromRemote=true to prevent echo
              showToast('✅ Alarm stopped from another device', 'success');
            }
            return;
          } catch (e) {
            console.error('Failed to parse alarm data:', e);
          }
        }

        // Handle irrigation status updates from ESP32
        if (message.destinationName === TOPIC_STATUS) {
          try {
            const status = JSON.parse(payload);
            console.log('📊 Pump Status Update:', status);
            if (status.mode === 'AUTO') {
              console.log(`💧 Auto Mode Active: Pump ${status.pump} | Moisture: ${document.getElementById('soilMoisture') ? document.getElementById('soilMoisture').innerText : 'Unknown'}%`);
            }
            updatePumpStatus(status);
            return;
          } catch (e) {
            console.error('Failed to parse pump status:', e);
          }
        }

        // Try JSON sensor update (legacy format)
        if (payload && payload[0] === '{') {
          try {
            const data = JSON.parse(payload);
            if (data.temperature !== undefined) document.getElementById('temperature').innerText = parseFloat(data.temperature).toFixed(1);
            if (data.humidity !== undefined) document.getElementById('humidity').innerText = parseFloat(data.humidity).toFixed(1);
            if (data.soilMoisture !== undefined) document.getElementById('soilMoisture').innerText = data.soilMoisture + '%';
            if (data.soilTemperature !== undefined) {
              const soilTempEl = document.getElementById('soilTemperature');
              if (soilTempEl) soilTempEl.innerText = parseFloat(data.soilTemperature).toFixed(1);
            }

            // Update Motion Sensor UI
            if (data.motion !== undefined) {
              const motionStatus = document.getElementById('motionStatus');
              const motionIcon = document.getElementById('motionIcon');
              const motionIndicator = document.getElementById('motionIndicator');
              const motionCard = document.getElementById('motionSensorCard');

              if (data.motion === 1) {
                // Motion detected!
                if (motionStatus) motionStatus.textContent = 'Motion Detected!';

                // Log event to Firebase
                addMotionEvent(Date.now());
                if (motionIcon) {
                  motionIcon.textContent = 'sensors';
                  motionIcon.style.color = 'var(--error)';
                  motionIcon.style.background = 'rgba(234, 67, 53, 0.2)';
                  motionIcon.style.animation = 'pulse 1s infinite';
                }
                if (motionIndicator) {
                  motionIndicator.style.background = 'var(--error)';
                  motionIndicator.style.boxShadow = '0 0 8px var(--error)';
                }
                if (motionCard) {
                  motionCard.style.borderColor = 'var(--error)';
                }
              } else {
                // No motion
                if (motionStatus) motionStatus.textContent = 'No Motion';
                if (motionIcon) {
                  motionIcon.textContent = 'shield';
                  motionIcon.style.color = 'var(--success)';
                  motionIcon.style.background = 'rgba(52, 168, 83, 0.2)';
                  motionIcon.style.animation = 'none';
                }
                if (motionIndicator) {
                  motionIndicator.style.background = 'var(--success)';
                  motionIndicator.style.boxShadow = 'none';
                }
                if (motionCard) {
                  motionCard.style.borderColor = 'var(--outline-variant)';
                }
              }
            }

            // Save to Firebase
            if (
              data.temperature !== undefined ||
              data.tds !== undefined ||
              data.flow !== undefined ||
              data.flow_rate !== undefined ||
              data.today_vol !== undefined
            ) {
              saveSensorReading({
                temp: data.temperature,
                hum: data.humidity,
                moisture: data.soilMoisture, // Note: legacy format might use soilMoisture key
                soil_temp: data.soilTemperature,
                tds: data.tds,
                motion: data.motion,
                flow: data.flow !== undefined ? data.flow : data.flow_rate,
                today_vol: data.today_vol
              });
            }

            const arduinoDot = document.getElementById('arduinoDot');
            const arduinoStatus = document.getElementById('arduinoStatus');
            if (data.arduinoConnected) {
              arduinoDot.classList.remove('offline');
              arduinoStatus.innerText = translateText('Connected');
            } else {
              arduinoDot.classList.add('offline');
              arduinoStatus.innerText = translateText('Not Connected');
            }
          } catch (e) {
            console.error("Error parsing MQTT JSON message:", e, payload);
          }
          return;
        }

        // Handle plain-text control/status messages
        // console.log("MQTT message (text) arrived:", payload);
        if (payload.indexOf('PUMP_ON') !== -1) {
          console.log('ESP acknowledged PUMP_ON');
        } else if (payload.indexOf('PUMP_OFF') !== -1) {
          console.log('ESP acknowledged PUMP_OFF');
        }
      }

      let activePumpTimer = null;
      let countdownInterval = null;
      let lastScheduleSignature = null;



      // Update UI based on ESP32 device-side status
      function updatePumpStatus(status) {
        const btn = document.getElementById('pumpBtn');
        const card = document.getElementById('pumpCard');
        const statusText = document.getElementById('pumpStatusText');
        const statusDot = document.getElementById('pumpStatusDot');
        const icon = document.getElementById('pumpIcon');

        const isOn = status.pump === 'ON';
        pumpOn = isOn;

        if (isOn) {
          if (btn) {
            btn.innerHTML = '<span class="material-symbols-rounded">stop_circle</span> <span class="translatable">' + translateText('Deactivate Pump') + '</span>';
            btn.className = 'btn err';
          }
          if (card) card.style.borderLeftColor = 'var(--primary)';
          if (statusText) statusText.textContent = translateText('ON');
          if (statusDot) {
            statusDot.style.background = 'var(--success)';
            statusDot.style.boxShadow = '0 0 8px var(--success)';
          }
          if (icon) icon.style.color = 'var(--primary)';
        } else {
          if (btn) {
            btn.innerHTML = '<span class="material-symbols-rounded">power_settings_new</span> <span class="translatable">' + translateText('Activate Pump') + '</span>';
            btn.className = 'btn pri';
          }
          if (card) card.style.borderLeftColor = 'var(--outline-variant)';
          if (statusText) statusText.textContent = translateText('OFF');
          if (statusDot) {
            statusDot.style.background = 'var(--on-surface-variant)';
            statusDot.style.boxShadow = 'none';
          }
          if (icon) icon.style.color = 'var(--on-surface-variant)';
        }

        // Update Flow & Usage UI from Status Packet
        const flowValue = status.flow_rate;
        const volValue = status.today_vol;

        if (flowValue !== undefined || volValue !== undefined) {
          console.log('💧 Water data in status - Flow:', flowValue, 'L/min, Volume:', volValue, 'L');

          const displayEl = document.getElementById('flowVolumeDisplay');
          const flowStatEl = document.getElementById('flowStatus');

          // Get current or default values
          const rate = flowValue !== undefined ? parseFloat(flowValue).toFixed(4) : '0.0000';
          const vol = volValue !== undefined ? Math.round(parseFloat(volValue) * 1000) : 0;

          if (displayEl) {
            displayEl.textContent = `Rate=${rate} L/min, Vol=${vol} mL`;
          }

          if (flowStatEl && flowValue !== undefined) {
            if (parseFloat(flowValue) > 0) {
              flowStatEl.textContent = translateText('Flowing');
              flowStatEl.style.color = 'var(--success)';
            } else {
              flowStatEl.textContent = translateText('No Flow');
              flowStatEl.style.color = 'var(--on-surface-variant)';
            }
          }

          // Persist to localStorage for quick restore on refresh
          if (volValue !== undefined) {
            try {
              localStorage.setItem('lastDailyUsage', volValue.toString());
              localStorage.setItem('lastDailyUsageTime', Date.now().toString());
              console.log('💾 Saved to localStorage:', volValue, 'L');
            } catch (e) { console.error('localStorage error:', e); }
          }

          // Immediate save with 5s throttle to prevent excessive writes
          const now = Date.now();
          // Save immediately when pump is ON or if 5s have passed since last save
          if (!window.lastWaterSave || now - window.lastWaterSave > 5000) {
            console.log('💾 Saving water data to Firebase...');
            saveSensorReading({
              flow: status.flow_rate || 0,
              today_vol: status.today_vol
            });
            window.lastWaterSave = now;
          } else {
            const timeLeft = 5 - Math.floor((now - window.lastWaterSave) / 1000);
            console.log('⏳ Throttled - next save in ' + timeLeft + 's');
          }
        }



        // Update Auto Mode Toggle
        if (status.auto_enabled !== undefined) {
          const toggle = document.getElementById('autoModeToggle');
          if (toggle) toggle.checked = status.auto_enabled;
          autoModeEnabled = status.auto_enabled;

          // Update profile visual state
          const profileDiv = document.getElementById('cropProfileDiv');
          if (profileDiv) profileDiv.style.display = status.auto_enabled ? 'block' : 'none';
        }

        // Update threshold dropdown if reported by device
        if (status.auto_threshold !== undefined && CROP_THRESHOLDS) {
          const sel = document.getElementById('cropProfile');
          if (sel) {
            // Find key for value
            let found = false;
            for (const [key, val] of Object.entries(CROP_THRESHOLDS)) {
              // Allow small margin of error (e.g. +/- 2)
              if (Math.abs(val - status.auto_threshold) < 5) {
                sel.value = key;
                found = true;
                break;
              }
            }
            if (!found) sel.value = 'default';
          }
        }

        // Show mode and remaining time
        if (status.mode && status.mode !== 'OFF') {
          let timeInfo = '';
          if (status.remaining_sec) {
            timeInfo = Math.floor(status.remaining_sec / 60) + 'm ' + (status.remaining_sec % 60) + 's';
          } else if (status.remaining_min) {
            timeInfo = status.remaining_min + 'm';
          } else if (status.on_delay_remaining) {
            timeInfo = 'Starting in ' + status.on_delay_remaining + 's';
          }

          if (timeInfo) {
            const cdDisplay = document.getElementById('timerCountdown');
            if (cdDisplay) {
              cdDisplay.style.display = 'block';
              cdDisplay.innerHTML = `⏱️ ${translateText(status.mode)}: ${timeInfo}`;
            }
          }
        }

        // Update device schedule / quick timer / NTP info
        const esps = document.getElementById('espScheduleStatus');
        if (esps) {
          const parts = [];
          if (status.ntp_synced) {
            parts.push(translateText('NTP: ') + (status.time ? status.time : translateText('synced')));
          } else {
            parts.push(translateText('NTP: ') + translateText('unsynced'));
          }
          if (status.schedule_enabled) {
            parts.push(translateText('Schedule: ') + (status.schedule_start || '--') + ' for ' + (status.schedule_duration_min || '--') + 'm');
          } else {
            parts.push(translateText('Schedule: OFF'));
          }
          if (status.quick_active) {
            let q = translateText('Quick: active');
            if (status.quick_on_delay_sec !== undefined) q += ' ' + translateText('(on_delay ') + status.quick_on_delay_sec + 's)';
            parts.push(q);
          }
          esps.textContent = parts.join(' | ');
        }

        // Detect schedule confirmation from ESP32
        const currentSig = JSON.stringify({
          en: status.schedule_enabled,
          start: status.schedule_start,
          dur: status.schedule_duration_min
        });

        if (lastScheduleSignature && lastScheduleSignature !== currentSig) {
          if (status.schedule_enabled) {
            showToast(`✅ ESP32 Confirmed: Schedule at ${status.schedule_start} for ${status.schedule_duration_min}m`, 'success');
          } else {
            try {
              const last = JSON.parse(lastScheduleSignature);
              if (last.en) showToast('✅ ESP32 Confirmed: Schedule Disabled', 'info');
            } catch (e) { }
          }
        }
        lastScheduleSignature = currentSig;
      }

      function togglePump(source = 'manual') {
        // If manually activating/deactivating, disable Auto Mode first to prevent conflict
        if (source === 'manual' && autoModeEnabled) {
          console.log('⚠️ Manual pump action detected while Auto Mode is ON. Disabling Auto Mode.');
          const toggle = document.getElementById('autoModeToggle');
          if (toggle) toggle.checked = false;
          toggleAutoMode(); // This will auto-save the disabled state too
          showToast('Disabling Auto Mode for manual control', 'info');

          // Slight delay to ensure Auto Mode disable command is sent first
          setTimeout(() => togglePump('manual'), 300);
          return;
        }

        if (source === 'manual') {
          if (activePumpTimer) {
            clearTimeout(activePumpTimer);
            activePumpTimer = null;
            showToast('Timer cancelled by manual action', 'info');
          }
          if (countdownInterval) {
            clearInterval(countdownInterval);
            countdownInterval = null;
            const cd = document.getElementById('timerCountdown');
            if (cd) cd.style.display = 'none';
          }
        }

        const newState = pumpOn ? 'OFF' : 'ON';

        // Send manual override to ESP32 (device-side control)
        const payload = JSON.stringify({
          type: 'MANUAL',
          state: newState
        });

        const message = new Paho.MQTT.Message(payload);
        message.destinationName = TOPIC_MANUAL;
        message.retained = true;  // CRITICAL: Retained message for persistence
        console.log('📤 Publishing manual override:', payload, 'to', TOPIC_MANUAL);
        client.send(message);

        // OPTIMISTIC UI UPDATE: Update UI immediately, ESP32 will confirm
        pumpOn = (newState === 'ON');
        updatePumpStatus({ pump: newState, mode: 'MANUAL' });

        showToast('Manual ' + newState + ' command sent to ESP32', 'info');

        // UI will also be updated by ESP32 status messages (device-side control)
        // No local state changes - ESP32 is the source of truth
      }

      // ==================== PUMP SCHEDULER ====================
      let pumpSchedules = []; // Array of { id, time, duration, enabled, lastTriggered }

      function initPumpScheduler() {
        // Always load from local storage first as baseline/fallback
        const saved = localStorage.getItem('pumpSchedules');
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            // Handle migration from old single object to array
            if (!Array.isArray(parsed) && parsed.time) {
              pumpSchedules = [{ id: Date.now(), time: parsed.time, duration: parsed.duration || 5, enabled: parsed.enabled || false }];
            } else {
              pumpSchedules = parsed || [];
            }
            renderSchedules();
          } catch (e) { }
        }

        // Check schedule every 10 seconds
        // setInterval(checkPumpSchedule, 10000); // Client-side scheduler disabled to rely on ESP32
      }

      function renderSchedules() {
        const list = document.getElementById('scheduleList');
        if (!list) return;
        list.innerHTML = '';

        if (pumpSchedules.length === 0) {
          list.innerHTML = '<div style="font-size:12px; color:var(--on-surface-variant); text-align:center; padding:8px;">No schedules set</div>';
          return;
        }

        pumpSchedules.forEach((sch, index) => {
          const row = document.createElement('div');
          row.style.cssText = 'display: flex; gap: 8px; align-items: center; background: var(--surface-container); padding: 8px; border-radius: 8px;';
          row.innerHTML = `
          <input type="time" value="${sch.time}" onchange="updateSchedule(${index}, 'time', this.value)" style="background:transparent; border:none; color:var(--on-surface); font-family:var(--font-sans); font-size:13px;">
          <span style="font-size:12px; color:var(--on-surface-variant);">for</span>
          <input type="number" value="${sch.duration}" min="1" max="60" onchange="updateSchedule(${index}, 'duration', this.value)" style="width:40px; background:transparent; border:1px solid var(--outline-variant); border-radius:4px; color:var(--on-surface); padding:4px; font-size:13px;">
          <span style="font-size:12px; color:var(--on-surface-variant);">min</span>
          <div style="flex:1;"></div>
          <label class="switch" style="display:flex; align-items:center;">
            <input type="checkbox" ${sch.enabled ? 'checked' : ''} onchange="updateSchedule(${index}, 'enabled', this.checked)">
            <span style="font-size:12px; margin-left:4px;">${sch.enabled ? 'ON' : 'OFF'}</span>
          </label>
          <button onclick="removeScheduleRow(${index})" style="background:transparent; border:none; color:var(--error); cursor:pointer; padding:4px;"><span class="material-symbols-rounded" style="font-size:18px;">delete</span></button>
        `;
          list.appendChild(row);
        });
      }

      function addScheduleRow() {
        pumpSchedules.push({ id: Date.now(), time: '08:00', duration: 5, enabled: true });
        renderSchedules();
        // Don't auto-save yet - wait for user to click Save
      }

      function removeScheduleRow(index) {
        pumpSchedules.splice(index, 1);
        renderSchedules();
        savePumpSchedules();  // Auto-save and sync with ESP32
      }

      function updateSchedule(index, field, value) {
        if (pumpSchedules[index]) {
          if (field === 'duration') {
            const val = parseInt(value);
            pumpSchedules[index][field] = isNaN(val) ? 5 : val;
          } else {
            pumpSchedules[index][field] = value;
          }
        }
      }

      function setDelayTimer(mode) {
        const mins = parseInt(document.getElementById('delayMinutes').value) || 0;
        if (mins <= 0) return showToast('Invalid duration', 'error');

        const cdDisplay = document.getElementById('timerCountdown');

        // Helper to start visual countdown
        const startVisualCountdown = (label) => {
          if (countdownInterval) clearInterval(countdownInterval);
          if (cdDisplay) {
            cdDisplay.style.display = 'block';
            let seconds = mins * 60;

            const update = () => {
              const m = Math.floor(seconds / 60);
              const s = seconds % 60;
              cdDisplay.innerHTML = `
              <div style="display: flex; align-items: center; justify-content: center; gap: 12px;">
                <span>⏳ <span class="translatable">${label}</span>: ${m}m ${s}s</span>
                <button onclick="cancelTimer()" style="background: rgba(0,0,0,0.1); border: 1px solid currentColor; color: inherit; border-radius: 4px; padding: 2px 8px; cursor: pointer; font-size: 12px; font-weight: 600; display: flex; align-items: center; gap: 4px;"><span class="material-symbols-rounded" style="font-size: 14px;">close</span> Cancel</button>
              </div>`;
              if (seconds <= 0) {
                clearInterval(countdownInterval);
                cdDisplay.style.display = 'none';
              }
              seconds--;
            };
            update(); // Initial call
            countdownInterval = setInterval(update, 1000);
          }
        };

        console.log(`[Timer] Setting quick timer: Mode=${mode}, Duration=${mins} mins`);

        // Send QUICK_TIMER message to ESP32 (device-side execution)
        let onDelaySec = 0;
        let offDelayMin = mins;

        let toastMsg = '';
        let toastType = 'info';
        let countdownLabel = '';

        if (mode === 'run') {
          // Run immediately for X minutes
          onDelaySec = 0;
          offDelayMin = mins;
          toastMsg = `Quick Timer: Run for ${mins} minutes`;
          toastType = 'success';
          countdownLabel = 'Running';
        } else if (mode === 'on') {
          // Turn ON after X minutes delay
          onDelaySec = mins * 60;
          offDelayMin = 0; // Will stay on until manual stop
          toastMsg = `Quick Timer: ON after ${mins} minutes`;
          toastType = 'info';
          countdownLabel = 'Starting in';
        } else {
          // Turn OFF after X minutes delay
          onDelaySec = 0;
          offDelayMin = mins;
          toastMsg = `Quick Timer: OFF after ${mins} minutes`;
          toastType = 'info';
          countdownLabel = 'Stopping in';
        }

        const payload = JSON.stringify({
          type: 'QUICK_TIMER',
          on_delay_sec: onDelaySec,
          off_delay_min: offDelayMin
        });

        if (!publishIrrigationMessage(TOPIC_SCHEDULE, payload, { retained: true, qos: 1, queueKey: 'quick' })) {
          return;
        }

        console.log('📤 Publishing quick timer:', payload);
        showToast(toastMsg, toastType);
        startVisualCountdown(countdownLabel);

        // Note: Timer runs on ESP32 - no local countdown needed
        // ESP32 will send status updates via TOPIC_STATUS
      }

      function cancelTimer() {
        if (activePumpTimer) {
          clearTimeout(activePumpTimer);
          activePumpTimer = null;
        }
        if (countdownInterval) {
          clearInterval(countdownInterval);
          countdownInterval = null;
        }
        const cd = document.getElementById('timerCountdown');
        if (cd) cd.style.display = 'none';

        // Send command to cancel device timer (Force OFF)
        if (client && client.isConnected()) {
          const payload = JSON.stringify({ type: 'MANUAL', state: 'OFF' });
          const message = new Paho.MQTT.Message(payload);
          message.destinationName = TOPIC_MANUAL;
          message.retained = true;
          client.send(message);
        }

        showToast('Timer cancelled', 'info');
      }

      function savePumpSchedules() {
        localStorage.setItem('pumpSchedules', JSON.stringify(pumpSchedules));

        // Send first enabled schedule to ESP32 (device-side execution)
        const enabledSchedule = pumpSchedules.find(s => s.enabled);

        if (!enabledSchedule) {
          // No enabled schedules - send disable message to ESP32
          const payload = JSON.stringify({
            type: 'SCHEDULE',
            enabled: false
          });

          if (!publishIrrigationMessage(TOPIC_SCHEDULE, payload, { retained: true, qos: 1, queueKey: 'schedule' })) {
            return;
          }

          showToast('All schedules disabled', 'info');
          console.log('📡 Disabled schedule on ESP32');
          return;
        }

        // Ensure time is strictly HH:MM (5 chars) for ESP32 parser
        let timeStr = enabledSchedule.time || '08:00';
        if (timeStr.length === 4) timeStr = '0' + timeStr; // Fix 8:00 -> 08:00

        // Ensure duration is a valid integer
        const duration = parseInt(enabledSchedule.duration) || 5;

        // Send enabled schedule to ESP32
        const payload = JSON.stringify({
          type: 'SCHEDULE',
          start: timeStr,
          duration_min: duration,
          enabled: true
        });

        if (!publishIrrigationMessage(TOPIC_SCHEDULE, payload, { retained: true, qos: 1, queueKey: 'schedule' })) {
          return;
        }

        showToast(`Schedule set: ${timeStr} for ${duration}m`, 'success');
        console.log('📡 Sent schedule to ESP32:', payload);
      }

      function checkPumpSchedule() {
        // Client-side scheduler disabled to prevent conflicts with ESP32 device-side scheduler
        if (!pumpSchedules || !Array.isArray(pumpSchedules) || pumpSchedules.length === 0) {
          // console.log('🕒 Scheduler: No schedules active');
          return;
        }

        const now = new Date();
        const currentTime = now.getHours().toString().padStart(2, '0') + ':' + now.getMinutes().toString().padStart(2, '0');
        const todayDate = now.toDateString();

        console.log(`🕒 Scheduler Check: Current Time=${currentTime}, Active Schedules=${pumpSchedules.length}`);

        pumpSchedules.forEach(sch => {
          if (!sch.enabled) return;

          // Trigger only once per day at the specific time
          if (sch.time === currentTime && sch.lastTriggered !== todayDate) {
            sch.lastTriggered = todayDate;

            if (!pumpOn) {
              console.log('✅ ⏰ Schedule MATCHED for time:', sch.time, '| Duration:', sch.duration);
              togglePump('auto'); // Turn ON
              showToast('Scheduled watering started (' + sch.duration + ' min)', 'info');

              // Auto-off timer
              if (activePumpTimer) clearTimeout(activePumpTimer);
              activePumpTimer = setTimeout(() => {
                if (pumpOn) {
                  console.log('🛑 ⏰ Schedule duration (' + sch.duration + 'm) ended. Deactivating pump.');
                  togglePump('auto'); // Turn OFF
                  showToast('Scheduled watering finished', 'success');
                }
                activePumpTimer = null;
              }, (sch.duration || 5) * 60 * 1000);
            }
          }
        });
      }

      // ========== SECURITY SETTINGS INITIALIZATION ==========
      // Initialize security toggles and load settings from Firebase
      setTimeout(() => {
        const motionToggle = document.getElementById('motionAlertsToggle');
        const loggingToggle = document.getElementById('eventLoggingToggle');
        const durationSelect = document.getElementById('alarmDurationSelect');

        if (motionToggle) motionToggle.addEventListener('change', saveSecuritySettings);
        if (loggingToggle) loggingToggle.addEventListener('change', saveSecuritySettings);
        if (durationSelect) durationSelect.addEventListener('change', saveSecuritySettings);

        // Resume AudioContext on first user interaction to bypass browser autoplay policy
        document.addEventListener('click', () => {
          if (!window.audioCtx) {
            window.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (window.audioCtx.state === 'suspended') {
            window.audioCtx.resume().then(() => {
              console.log('🔇 -> 🔊 AudioContext resumed by user interaction');
            }).catch(e => console.error('Audio resume failed:', e));
          }
        }, { once: true });

        // Load settings and events from Firebase
        if (typeof firebaseReady !== 'undefined' && firebaseReady) {
          if (typeof loadSecuritySettings === 'function') loadSecuritySettings();
          if (typeof loadMotionEvents === 'function') loadMotionEvents();
        }

        // Redundant check for safety if firebaseReady wasn't true yet
        if (typeof firebaseReadyPromise !== 'undefined') {
          firebaseReadyPromise.then(() => {
            if (typeof loadSecuritySettings === 'function') loadSecuritySettings();
            // if (typeof loadMotionEvents === 'function') loadMotionEvents(); 
            if (typeof loadSecurityLog === 'function') loadSecurityLog();
          });
        }
      }, 1000);

      // ========== SECURITY LOGGING IMPLEMENTATION ==========

      // Generic security event logger (Motion + Intruder)
      window.lastSecurityLogTime = 0;

      function addMotionEvent(timestamp, message = 'Motion detected') {
        // Wrapper for backward compatibility or direct call
        addSecurityEvent('MOTION', message, timestamp);
      }

      function addSecurityEvent(type, message, timestamp = Date.now()) {
        if (!firebaseReady) return;

        const user = auth.currentUser;
        if (!user) return;

        // Simple throttle to prevent spamming logs (except critical ones)
        if (Date.now() - window.lastSecurityLogTime < 2000) return;
        window.lastSecurityLogTime = Date.now();

        const logEntry = {
          type: type, // 'MOTION' or 'INTRUDER'
          message: message,
          timestamp: timestamp,
          read: false
        };

        // Add to Firestore collection 'security_logs'
        db.collection('users').doc(user.uid).collection('security_logs').add(logEntry)
          .then(() => {
            console.log('📝 Security event logged:', message);
            loadSecurityLog(); // Refresh UI
            updateSecurityStats(); // Update counters
          })
          .catch((error) => {
            console.error('Error adding security log:', error);
          });
      }

      function loadSecurityLog() {
        if (!firebaseReady) return;
        const user = auth.currentUser;
        if (!user) return;

        const list = document.getElementById('motionEventsList');
        if (!list) return;

        // Query last 20 events
        db.collection('users').doc(user.uid).collection('security_logs')
          .orderBy('timestamp', 'desc')
          .limit(20)
          .get()
          .then((querySnapshot) => {
            if (querySnapshot.empty) {
              list.innerHTML = `
                <div style="text-align: center; padding: 32px; color: var(--on-surface-variant);">
                  <span class="material-symbols-rounded" style="font-size: 48px; opacity: 0.3; display: block; margin-bottom: 8px;">event_note</span>
                  <div style="font-size: 14px;">No security events recorded</div>
                </div>`;
              return;
            }

            let html = '';
            let todayCount = 0;
            const today = new Date().toDateString();

            querySnapshot.forEach((doc) => {
              const data = doc.data();
              const date = new Date(data.timestamp);
              const isToday = date.toDateString() === today;
              if (isToday) todayCount++;

              const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
              const dateStr = isToday ? 'Today' : date.toLocaleDateString();

              let icon = 'info';
              let color = 'var(--primary)';
              let bg = 'var(--surface-container-high)';

              if (data.type === 'INTRUDER' || (data.message && data.message.includes('Intruder'))) {
                icon = 'gpp_bad';
                color = 'var(--error)';
                bg = 'rgba(176, 0, 32, 0.05)';
              } else if (data.type === 'MOTION') {
                icon = 'motion_sensor_active';
                color = 'var(--warning)';
                bg = 'rgba(255, 152, 0, 0.05)';
              }

              html += `
               <div style="display: flex; gap: 12px; padding: 12px; border-bottom: 1px solid var(--outline-variant); background: ${bg}; border-radius: 8px; margin-bottom: 4px;">
                 <div style="background: var(--surface); padding: 8px; border-radius: 50%; height: 32px; width: 32px; display: flex; align-items: center; justify-content: center; box-shadow: var(--elevation-1);">
                   <span class="material-symbols-rounded" style="font-size: 18px; color: ${color};">${icon}</span>
                 </div>
                 <div style="flex: 1;">
                   <div style="font-size: 14px; font-weight: 500; color: var(--on-surface);">${data.message}</div>
                   <div style="font-size: 12px; color: var(--on-surface-variant); margin-top: 2px;">${dateStr} • ${timeStr}</div>
                 </div>
               </div>
             `;
            });

            list.innerHTML = html;

            // Update Stats
            const todayEl = document.getElementById('todayMotionEvents');
            if (todayEl) todayEl.textContent = todayCount;

            const totalEl = document.getElementById('totalMotionEvents');
            // Note: Total count query would be expensive, just use snapshot size + known offset if needed?
            // For now just show "20+" if full or actual count
            if (totalEl) totalEl.textContent = (querySnapshot.size === 20) ? '20+' : querySnapshot.size;

          }).catch((error) => {
            console.error("Error loading security logs:", error);
          });
      }

      function updateSecurityStats() {
        // Optional: aggregate stats
      }

      // ==========================================
      // WEATHER APP LOGIC (Open-Meteo API)
      // ==========================================

      function initWeather() {
        const locationElement = document.getElementById('weatherLocation');
        if (locationElement) locationElement.textContent = 'Locating...';

        // Check for saved location
        const savedLat = localStorage.getItem('weather_lat');
        const savedLon = localStorage.getItem('weather_lon');
        const savedName = localStorage.getItem('weather_name');

        if (savedLat && savedLon) {
          if (locationElement && savedName) locationElement.textContent = savedName;
          fetchWeather(savedLat, savedLon, savedName); // Pass name to avoid overwrite if possible
          return;
        }

        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            (position) => {
              const lat = position.coords.latitude;
              const lon = position.coords.longitude;
              fetchWeather(lat, lon);
            },
            (error) => {
              console.error("Geolocation denied or error:", error);
              if (locationElement) locationElement.textContent = "Location Denied";
            }
          );
        } else {
          if (locationElement) locationElement.textContent = "Geolocation Not Supported";
        }
      }

      // Toggle Search UI
      function toggleLocationSearch() {
        const searchUI = document.getElementById('locationSearch');
        const isHidden = searchUI.style.display === 'none';
        searchUI.style.display = isHidden ? 'flex' : 'none';
        if (isHidden) {
          document.getElementById('cityInput').focus();
        }
      }

      // Search Location (Geocoding API)
      async function searchLocation() {
        const query = document.getElementById('cityInput').value;
        if (!query) return;

        const btn = document.querySelector('#locationSearch button');
        const originalText = btn.textContent;
        btn.textContent = '...';

        try {
          const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=1&language=en&format=json`;
          const response = await fetch(url);
          const data = await response.json();

          if (data.results && data.results.length > 0) {
            const result = data.results[0];
            const name = result.name;
            const lat = result.latitude;
            const lon = result.longitude;

            // Save to LocalStorage
            localStorage.setItem('weather_lat', lat);
            localStorage.setItem('weather_lon', lon);
            localStorage.setItem('weather_name', name);

            // Update Weather
            fetchWeather(lat, lon, name);

            // Reset UI
            document.getElementById('cityInput').value = '';
            toggleLocationSearch();
          } else {
            alert('City not found!');
          }
        } catch (error) {
          console.error("Geocoding error:", error);
          alert('Error searching location');
        } finally {
          btn.textContent = originalText;
        }
      }

      // Use Current Location
      function useCurrentLocation() {
        localStorage.removeItem('weather_lat');
        localStorage.removeItem('weather_lon');
        localStorage.removeItem('weather_name');
        toggleLocationSearch();
        initWeather();
      }

      async function fetchWeather(lat, lon) {
        try {
          // Fetch Location Name (Reverse Geocoding optional, or just use generic)
          // We'll use Open-Meteo's timezone auto to get general area

          // API: Current + 7 Day Forecast

          const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m&hourly=soil_moisture_3_to_9cm&daily=weather_code,temperature_2m_max,temperature_2m_min,wind_speed_10m_max,relative_humidity_2m_mean,apparent_temperature_max,et0_fao_evapotranspiration,precipitation_sum&timezone=auto`;

          const response = await fetch(url);
          const data = await response.json();

          renderWeather(data);

        } catch (error) {
          console.error("Error fetching weather:", error);
          if (document.getElementById('weatherLocation')) document.getElementById('weatherLocation').textContent = "Weather Error";
        }
      }

      let globalWeatherData = null;
      let selectedDayIndex = 0;

      function renderWeather(data) {
        if (data) globalWeatherData = data;
        if (!globalWeatherData || !globalWeatherData.current || !globalWeatherData.daily) return;

        const isToday = selectedDayIndex === 0;
        const current = globalWeatherData.current;
        const daily = globalWeatherData.daily;
        const hourly = globalWeatherData.hourly;

        // --- RENDER MAIN DISPLAY ---
        if (isToday) {
          // Show Current Conditions
          if (document.getElementById('weatherDate')) document.getElementById('weatherDate').textContent = "Now • " + new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });

          if (document.getElementById('currentTemp')) document.getElementById('currentTemp').textContent = Math.round(current.temperature_2m) + "°";
          if (document.getElementById('feelsLike')) document.getElementById('feelsLike').textContent = "Feels " + Math.round(current.apparent_temperature) + "°";
          if (document.getElementById('currentCondition')) document.getElementById('currentCondition').textContent = getWeatherDescription(current.weather_code);
          if (document.getElementById('currentWeatherIcon')) document.getElementById('currentWeatherIcon').textContent = getWeatherIcon(current.weather_code);

          if (document.getElementById('currentWind')) document.getElementById('currentWind').textContent = Math.round(current.wind_speed_10m);
          if (document.getElementById('currentHumidity')) document.getElementById('currentHumidity').textContent = current.relative_humidity_2m;

          // Agri Metrics (Current/Today)
          if (document.getElementById('agriEt0')) document.getElementById('agriEt0').textContent = daily.et0_fao_evapotranspiration[0].toFixed(1);
          if (document.getElementById('agriRain')) document.getElementById('agriRain').textContent = daily.precipitation_sum[0].toFixed(1);

          // Soil Moisture: Find index closest to current time
          // Note: hourly.time is ISO string array. current.time is ISO string.
          // Simple approx: current hour index = new Date().getHours();
          const currentHour = new Date().getHours();
          if (document.getElementById('agriSoil') && hourly && hourly.soil_moisture_3_to_9cm) {
            const val = hourly.soil_moisture_3_to_9cm[currentHour];
            document.getElementById('agriSoil').textContent = (val !== undefined && val !== null) ? val.toFixed(2) : '--';
          }

        } else {
          // Show Forecast for Selected Day
          const i = selectedDayIndex;
          const date = new Date(daily.time[i]);
          const dayName = date.toLocaleDateString('en-US', { weekday: 'long' });

          if (document.getElementById('weatherDate')) document.getElementById('weatherDate').textContent = dayName + " • Forecast";

          // Use Max Temp for main display
          if (document.getElementById('currentTemp')) document.getElementById('currentTemp').textContent = Math.round(daily.temperature_2m_max[i]) + "°";
          // Use Max Apparent Temp for feels like
          if (document.getElementById('feelsLike')) document.getElementById('feelsLike').textContent = "Max Feels " + Math.round(daily.apparent_temperature_max[i]) + "°";
          if (document.getElementById('currentCondition')) document.getElementById('currentCondition').textContent = getWeatherDescription(daily.weather_code[i]);
          if (document.getElementById('currentWeatherIcon')) document.getElementById('currentWeatherIcon').textContent = getWeatherIcon(daily.weather_code[i]);

          // Use Max Wind
          if (document.getElementById('currentWind')) document.getElementById('currentWind').textContent = Math.round(daily.wind_speed_10m_max[i]);
          // Use Mean Humidity
          if (document.getElementById('currentHumidity')) document.getElementById('currentHumidity').textContent = Math.round(daily.relative_humidity_2m_mean[i]);

          // Agri Metrics (Forecast Day)
          if (document.getElementById('agriEt0')) document.getElementById('agriEt0').textContent = daily.et0_fao_evapotranspiration[i].toFixed(1);
          if (document.getElementById('agriRain')) document.getElementById('agriRain').textContent = daily.precipitation_sum[i].toFixed(1);

          // Soil Moisture: Pick 12:00 PM for that day
          // Day index i. Hour index = i * 24 + 12
          const noonIndex = i * 24 + 12;
          if (document.getElementById('agriSoil') && hourly && hourly.soil_moisture_3_to_9cm) {
            const val = hourly.soil_moisture_3_to_9cm[noonIndex]; // Approximate noon moisture
            // Check bounds
            if (val !== undefined) {
              document.getElementById('agriSoil').textContent = val.toFixed(2);
            } else {
              document.getElementById('agriSoil').textContent = '--';
            }
          }
        }

        // --- RENDER FORECAST LIST ---
        const scrollContainer = document.getElementById('forecastScroll');
        if (scrollContainer) {
          scrollContainer.innerHTML = '';

          for (let i = 0; i < 7; i++) {
            const dateStr = daily.time[i];
            const date = new Date(dateStr);
            const dayName = i === 0 ? 'Today' : date.toLocaleDateString('en-US', { weekday: 'short' });
            const code = daily.weather_code[i];
            const maxTemp = Math.round(daily.temperature_2m_max[i]);
            const minTemp = Math.round(daily.temperature_2m_min[i]);

            const isActive = i === selectedDayIndex;
            const bg = isActive ? 'var(--primary)' : 'rgba(255,255,255,0.1)';
            const border = isActive ? '2px solid var(--primary)' : '1px solid rgba(255,255,255,0.1)';
            const textColor = isActive ? 'var(--on-primary)' : 'var(--on-widget)';
            const subTextColor = isActive ? 'rgba(0,0,0,0.6)' : 'var(--on-widget-variant)';
            const iconColor = isActive ? 'var(--on-primary)' : 'var(--primary)';

            const el = document.createElement('div');
            el.style.cssText = `min-width: 60px; text-align: center; padding: 12px 8px; background: ${bg}; border-radius: 16px; border: ${border}; flex-shrink: 0; cursor: pointer; transition: all 0.2s;`;
            el.onclick = () => selectDay(i);

            el.innerHTML = `
            <div style="font-size: 12px; font-weight: 600; color: ${subTextColor}; margin-bottom: 8px;">${dayName}</div>
            <span class="material-symbols-rounded" style="color: ${iconColor}; font-size: 24px; margin-bottom: 8px;">${getWeatherIcon(code)}</span>
            <div style="font-size: 14px; font-weight: 700; color: ${textColor};">${maxTemp}°</div>
            <div style="font-size: 11px; color: ${subTextColor};">${minTemp}°</div>
          `;
            scrollContainer.appendChild(el);
          }
        }
      }

      function selectDay(index) {
        selectedDayIndex = index;
        renderWeather(null); // Re-render using global data
      }

      // WMO Weather Code to Description & Icon Mapping
      function getWeatherDescription(code) {
        const codes = {
          0: 'Clear Sky',
          1: 'Mainly Clear', 2: 'Partly Cloudy', 3: 'Overcast',
          45: 'Fog', 48: 'Depositing Rime Fog',
          51: 'Light Drizzle', 53: 'Moderate Drizzle', 55: 'Dense Drizzle',
          61: 'Slight Rain', 63: 'Moderate Rain', 65: 'Heavy Rain',
          71: 'Slight Snow', 73: 'Moderate Snow', 75: 'Heavy Snow',
          77: 'Snow Grains',
          80: 'Slight Rain Showers', 81: 'Moderate Rain Showers', 82: 'Violent Rain Showers',
          95: 'Thunderstorm', 96: 'Thunderstorm + Hail', 99: 'Thunderstorm + Heavy Hail'
        };
        return codes[code] || 'Unknown';
      }

      function getWeatherIcon(code) {
        const icons = {
          0: 'sunny',
          1: 'partly_cloudy_day', 2: 'partly_cloudy_day', 3: 'cloud',
          45: 'foggy', 48: 'foggy',
          51: 'rainy', 53: 'rainy', 55: 'rainy',
          61: 'rainy', 63: 'rainy', 65: 'rainy',
          71: 'ac_unit', 73: 'ac_unit', 75: 'ac_unit',
          77: 'ac_unit',
          80: 'rainy', 81: 'rainy', 82: 'rainy',
          95: 'thunderstorm', 96: 'thunderstorm', 99: 'thunderstorm'
        };
        return icons[code] || 'cloud'; // Default
      }

      // Header Logic: Greeting & Clock
      function updateHeader() {
        const now = new Date();
        const hour = now.getHours();

        // Greeting
        let greetingText = "Good Morning, Farmer! 🌾";
        if (hour >= 12 && hour < 17) {
          greetingText = "Good Afternoon, Farmer! ☀️";
        } else if (hour >= 17) {
          greetingText = "Good Evening, Farmer! 🌙";
        }
        const greetingEl = document.getElementById('greeting');
        if (greetingEl) greetingEl.textContent = greetingText;

        // Clock
        const timeStr = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
        const dateStr = now.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        const clockEl = document.getElementById('clock');
        if (clockEl) clockEl.textContent = `${timeStr} • ${dateStr}`;
      }

      // Initialize Weather on Load
      document.addEventListener('DOMContentLoaded', () => {
        initWeather();
        updateHeader();
        setInterval(updateHeader, 1000); // Update every second
      });

      // Menu toggle - switch to More tab
      function toggleMenu(event) {
        const navEl = event ? event.currentTarget : null;
        switchTab('moreTab', navEl);
      }

      // Landing Page Logic
      function enterDashboard() {
        const landing = document.getElementById('landingPage');
        if (landing) {
          landing.classList.add('fade-out');
        }
        // Show the nav bar after leaving the landing page
        const nav = document.querySelector('.nav');
        if (nav) {
          nav.style.display = 'flex';
          nav.style.opacity = '1';
        }
      }

      // Tab Switching Logic
      function switchTab(tabId, navElement) {
        // 1. Hide all tab contents
        document.querySelectorAll('.tab-content').forEach(el => {
          el.classList.remove('active');
          el.style.display = 'none'; // Ensure display none is toggled
        });

        // 2. Show target tab
        const target = document.getElementById(tabId);
        if (target) {
          target.classList.add('active');
          target.style.display = 'block';
        }

        // 3. Update Navigation Active State
        document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
        if (navElement) {
          navElement.classList.add('active');
        }
      }

      // Ensure Home is visible on load
      document.addEventListener('DOMContentLoaded', () => {
        // If standard showTab exists, we might need to override or ensure compatibility
        // For now, force homeTab visible
        const home = document.getElementById('homeTab');
        if (home) {
          home.style.display = 'block';
          home.classList.add('active');
        }
      });


    </script>

    <!-- Fixed Bottom Navigation (Moved to Body Root) -->
    <nav class="nav"
      style="position: fixed !important; bottom: 16px !important; left: 50% !important; transform: translateX(-50%) !important; z-index: 99999 !important; width: calc(100% - 32px) !important; max-width: 600px !important; display: none; opacity: 0; transition: opacity 0.5s ease;">
      <a href="#" class="nav-item active" onclick="switchTab('homeTab', this); return false;">
        <span class="material-symbols-rounded">home</span>
        <span class="label translatable">Home</span>
      </a>
      <a href="#" class="nav-item" onclick="switchTab('analyseTab', this); return false;">
        <span class="material-symbols-rounded">analytics</span>
        <span class="label translatable">Analyse</span>
      </a>
      <a href="#" class="nav-item" onclick="switchTab('monitorTab', this); return false;">
        <span class="material-symbols-rounded">smart_display</span>
        <span class="label translatable">Monitor</span>
      </a>

      <a href="#" class="nav-item" onclick="switchTab('securityTab', this); return false;">
        <span class="material-symbols-rounded">security</span>
        <span class="label translatable">Security</span>
      </a>
      <a href="#" class="nav-item" onclick="toggleMenu(event); return false;">
        <span class="material-symbols-rounded">menu</span>
        <span class="label translatable">Menu</span>
      </a>
    </nav>
</body>

</html>